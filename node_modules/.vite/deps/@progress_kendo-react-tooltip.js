import {
  Popup
} from "./chunk-XVBPUVJV.js";
import {
  require_react_dom
} from "./chunk-3UUEUCWE.js";
import {
  ZIndexContext,
  classNames,
  dispatchEvent,
  validatePackage2 as validatePackage
} from "./chunk-KTMNFILY.js";
import {
  require_prop_types
} from "./chunk-O6GWARG4.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/@progress/kendo-react-tooltip/dist/es/tooltip/Tooltip.js
var React = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-tooltip/dist/es/tooltip/utils.js
var arrowWidth = 10;
var arrowHeight = 10;
var getLeftPosition = function(left, elementWidth, targetElement, anchorElement, position) {
  switch (position) {
    case "bottom":
      return anchorElement === "pointer" ? left - elementWidth / 2 : targetElement.left - elementWidth / 2 + targetElement.width / 2;
    case "left":
      return anchorElement === "pointer" ? left - elementWidth - arrowWidth : targetElement.left - elementWidth - arrowWidth;
    case "right":
      return anchorElement === "pointer" ? left + arrowWidth : targetElement.right + arrowWidth;
    case "top":
      return anchorElement === "pointer" ? left - elementWidth / 2 : targetElement.left - elementWidth / 2 + targetElement.width / 2;
    default:
      if (anchorElement === "pointer") {
        return left < window.screen.availWidth / 2 ? left - arrowWidth : left - elementWidth + arrowWidth;
      } else {
        return left < window.screen.availWidth / 2 ? targetElement.left : targetElement.right - elementWidth;
      }
  }
};
var getTopPosition = function(top, targetElement, elementHeight, anchorElement, position) {
  switch (position) {
    case "bottom":
      return anchorElement === "pointer" ? top + arrowHeight : targetElement.bottom + arrowHeight;
    case "left":
      return anchorElement === "pointer" ? top - elementHeight / 2 : targetElement.top - elementHeight / 2 + targetElement.height / 2;
    case "right":
      return anchorElement === "pointer" ? top - elementHeight / 2 : targetElement.top - elementHeight / 2 + targetElement.height / 2;
    case "top":
      return anchorElement === "pointer" ? top - elementHeight - arrowHeight : targetElement.top - elementHeight - arrowHeight;
    default:
      if (anchorElement === "pointer") {
        return top < window.innerHeight / 2 ? top + arrowWidth : top - elementHeight - arrowWidth;
      } else {
        return top < window.innerHeight / 2 ? targetElement.bottom + arrowHeight : targetElement.top - elementHeight - arrowHeight;
      }
  }
};
var getDomRect = function(currentTarget) {
  if (currentTarget !== null) {
    return currentTarget.getBoundingClientRect();
  }
  return document.body.getBoundingClientRect();
};
var toolTipSelectors = [
  "k-tooltip-content",
  "k-animation-container",
  "k-tooltip",
  "k-tooltip-title",
  "k-tooltip k-tooltip-closable",
  "k-icon k-i-close"
];
var isTooltipElement = function(element3) {
  if (element3 === null) {
    return false;
  }
  var node3 = element3;
  while (node3) {
    if (node3 !== null && node3.classList && node3.classList.contains("k-tooltip")) {
      return true;
    }
    node3.parentNode !== null ? node3 = node3.parentNode : node3 = false;
  }
  return toolTipSelectors.filter(function(t) {
    return t === element3.className;
  }).length > 0;
};

// node_modules/@progress/kendo-react-tooltip/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-react-tooltip",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1680172908,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-tooltip/dist/es/tooltip/Tooltip.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DEFAULT_TOOLTIP_ZINDEX = 100;
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip2, _super);
    function Tooltip2(props) {
      var _this = _super.call(this, props) || this;
      _this.context = 0;
      _this.state = {
        targetElement: null,
        open: false,
        title: ""
      };
      _this.top = 0;
      _this.left = 0;
      _this.willOpen = false;
      _this.handleMouseOut = function(event) {
        var targetElement = _this.state.targetElement;
        var currentDocument = targetElement ? targetElement.ownerDocument : document;
        var element3 = currentDocument && currentDocument.elementFromPoint(event.clientX, event.clientY);
        if (isTooltipElement(element3)) {
          return;
        }
        if (_this.props.open) {
          return;
        }
        clearInterval(_this.updateIntervalId);
        _this.willOpen = false;
        _this.onClose(event);
      };
      _this.handleMouseOver = function(event) {
        var target = event.target;
        if (!_this.isVisible(target) || isTooltipElement(target) || target === _this.state.targetElement) {
          return;
        }
        _this.showToolTip(event);
      };
      _this.handleBodyMousemove = function(event) {
        _this.top = event.clientY;
        _this.left = event.clientX;
      };
      _this.onClose = function(event) {
        dispatchEvent(_this.props.onClose, event, _this, void 0);
        _this.setState({ targetElement: null, open: false, title: "" });
      };
      _this.setUpdateInterval = function() {
        if (_this.props.updateInterval) {
          _this.updateIntervalId = setInterval(_this.onIntervalUpdate, _this.props.updateInterval);
        }
      };
      _this.onIntervalUpdate = function() {
        var target = _this.state.targetElement;
        if (!target) {
          return;
        }
        if (target.parentElement === null) {
          _this.onClose({ target });
        } else {
          _this.showToolTip({ target });
        }
      };
      _this.position = function(element3) {
        var domRect = getDomRect(_this.state.targetElement);
        var left = getLeftPosition(_this.left, element3.offsetWidth, domRect, _this.props.anchorElement, _this.props.position);
        var top = getTopPosition(_this.top, domRect, element3.offsetHeight, _this.props.anchorElement, _this.props.position);
        return { left, top };
      };
      _this.getTitle = function(element3) {
        while (element3) {
          if (element3.getAttribute("title") !== null || element3.titleExpando) {
            var title = element3.getAttribute("title") || element3.titleExpando;
            return { title, element: element3 };
          }
          element3 = _this.props.parentTitle && element3.parentElement || null;
        }
        return { title: "", element: element3 };
      };
      _this.calloutClassName = function() {
        switch (_this.props.position) {
          case "bottom":
            return "k-callout k-callout-n";
          case "left":
            return "k-callout k-callout-e";
          case "right":
            return "k-callout k-callout-w";
          case "top":
            return "k-callout k-callout-s";
          default:
            return _this.top < window.innerHeight / 2 ? "k-callout k-callout-n" : "k-callout k-callout-s";
        }
      };
      _this.getCurrentZIndex = function() {
        return _this.context ? _this.context : DEFAULT_TOOLTIP_ZINDEX;
      };
      validatePackage(packageMetadata);
      return _this;
    }
    Tooltip2.prototype.componentDidMount = function() {
      if (document) {
        document.body.addEventListener("mousemove", this.handleBodyMousemove);
      }
    };
    Tooltip2.prototype.componentWillUnmount = function() {
      clearTimeout(this.openTimeoutId);
      clearInterval(this.updateIntervalId);
      if (document) {
        document.body.removeEventListener("mousemove", this.handleBodyMousemove);
      }
    };
    Tooltip2.prototype.componentDidUpdate = function() {
      if (this.props.open && this.props.targetElement) {
        this.showToolTip({ target: this.props.targetElement });
      }
    };
    Tooltip2.prototype.render = function() {
      var _this = this;
      if (this.props.children) {
        var _a = this.props, children = _a.children, options = __rest(_a, ["children"]);
        var tooltip_1 = null;
        return React.createElement(
          "div",
          { onMouseOver: function(event) {
            if (tooltip_1) {
              tooltip_1.handleMouseOver(event);
            }
          }, onMouseOut: function(event) {
            if (tooltip_1) {
              tooltip_1.handleMouseOut(event);
            }
          } },
          React.createElement(Tooltip2, __assign({ ref: function(el) {
            return tooltip_1 = el;
          } }, options)),
          children
        );
      }
      if (this.props.open === false) {
        return null;
      }
      var targetElement = this.state.targetElement;
      var currentZIndex = this.getCurrentZIndex();
      return targetElement && this.state.title && targetElement.ownerDocument && ReactDOM.createPortal(React.createElement(
        "div",
        { ref: function(el) {
          if (!el) {
            return;
          }
          var position;
          if (_this.props.onPosition) {
            var ev = {
              element: el,
              targetElement: _this.state.targetElement,
              mouseTop: _this.top,
              mouseLeft: _this.left,
              anchorElement: _this.props.anchorElement,
              position: _this.props.position,
              target: _this,
              syntheticEvent: null,
              nativeEvent: null
            };
            position = _this.props.onPosition.call(void 0, ev);
          } else {
            position = _this.position(el);
          }
          el.style.left = position.left + "px";
          el.style.top = position.top + "px";
        }, className: classNames("k-animation-container", "k-animation-container-fixed", "k-animation-container-shown", this.props.className), style: __assign({ zIndex: currentZIndex }, this.props.style), tabIndex: 0 },
        React.createElement(
          "div",
          { className: "k-child-animation-container" },
          React.createElement(
            "div",
            { id: this.props.id, role: "tooltip", className: classNames("k-tooltip", this.props.tooltipClassName), style: __assign({ position: "relative" }, this.props.tooltipStyle) },
            React.createElement("div", { className: "k-tooltip-content" }, this.props.content && React.createElement(this.props.content, { title: this.state.title, target: this.state.targetElement }) || this.state.title),
            this.props.showCallout && React.createElement("div", { ref: function(el) {
              if (!el) {
                return;
              }
              el.className = _this.calloutClassName();
              if (_this.props.position === "auto") {
                _this.left < window.screen.availWidth / 2 ? el.style.left = _this.props.setCalloutOnPositionAuto || "25%" : el.style.left = _this.props.setCalloutOnPositionAuto || "75%";
              }
            } })
          )
        )
      ), this.props.appendTo ? this.props.appendTo : targetElement.ownerDocument.body);
    };
    Tooltip2.prototype.showToolTip = function(event) {
      var _this = this;
      clearTimeout(this.openTimeoutId);
      clearInterval(this.updateIntervalId);
      if (event.target.hasChildNodes()) {
        event.target.childNodes.forEach(function(childElement) {
          if (childElement.nodeName === "title") {
            event.target.titleExpando = childElement.innerHTML;
            childElement.remove();
          }
        });
      }
      var target = this.props.targetElement || event.target;
      var titleResult = this.getTitle(target);
      if (!titleResult.title) {
        if (this.state.open) {
          this.onClose(event);
        }
        return;
      }
      if (titleResult.element) {
        titleResult.element.titleExpando = titleResult.title;
        titleResult.element.title = "";
      }
      this.willOpen = true;
      if (!this.props.openDelay) {
        this.setState({ targetElement: target, open: true, title: titleResult.title }, this.setUpdateInterval);
      } else {
        this.openTimeoutId = window.setTimeout(function() {
          if (_this.willOpen) {
            _this.setState({ targetElement: target, open: true, title: titleResult.title }, _this.setUpdateInterval);
          }
        }, this.props.openDelay);
      }
      if (this.state.title !== titleResult.title) {
        dispatchEvent(this.props.onOpen, event, this, void 0);
      }
    };
    Tooltip2.prototype.isVisible = function(element3) {
      return !this.props.filter || this.props.filter(element3);
    };
    Tooltip2.propTypes = {
      anchorElement: PropTypes.oneOf(["pointer", "target"]),
      content: PropTypes.func,
      filter: PropTypes.func,
      openDelay: PropTypes.number,
      position: PropTypes.oneOf(["right", "left", "top", "bottom", "auto"]),
      updateInterval: PropTypes.number
    };
    Tooltip2.defaultProps = {
      anchorElement: "pointer",
      openDelay: 400,
      position: "auto",
      showCallout: true,
      parentTitle: false
    };
    Tooltip2.contextType = ZIndexContext;
    return Tooltip2;
  }(React.PureComponent)
);

// node_modules/@progress/kendo-react-tooltip/dist/es/popover/Popover.js
var React3 = __toESM(require_react());
var PropTypes3 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-tooltip/dist/es/popover/PopoverActionsBar.js
var React2 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());
var PopoverActionsBar = React2.forwardRef(function(props, ref) {
  var elementRef = React2.useRef(null);
  var popoverRef = React2.useRef(null);
  React2.useImperativeHandle(popoverRef, function() {
    return { props, element: elementRef.current };
  });
  React2.useImperativeHandle(ref, function() {
    return popoverRef.current;
  });
  return React2.createElement("div", { ref: elementRef, className: "k-popover-actions k-actions k-actions-stretched", style: { position: "relative" } }, props.children);
});
var defaultProps = {};
PopoverActionsBar.propTypes = {
  children: PropTypes2.oneOfType([
    PropTypes2.element,
    PropTypes2.node
  ])
};
PopoverActionsBar.defaultProps = defaultProps;
PopoverActionsBar.displayName = "KendoReactPopoverActionsBar";

// node_modules/@progress/kendo-react-tooltip/dist/es/popover/Popover.js
var DEFAULT_POPOVER_ZINDEX = 12e3;
var ZINDEX_POPOVER_STEP = 2e3;
var CALLOUT_SIZE = 15;
var calloutPositions = {
  top: "k-callout-s",
  left: "k-callout-e",
  bottom: "k-callout-n",
  right: "k-callout-w"
};
var calloutFlippedPositions = {
  top: "k-callout-n",
  left: "k-callout-w",
  bottom: "k-callout-s",
  right: "k-callout-e"
};
var popupAlignByPosition = {
  top: { vertical: "bottom", horizontal: "center" },
  left: { vertical: "center", horizontal: "right" },
  bottom: { vertical: "top", horizontal: "center" },
  right: { vertical: "center", horizontal: "left" }
};
var anchorAlignByPosition = {
  top: { vertical: "top", horizontal: "center" },
  left: { vertical: "center", horizontal: "left" },
  bottom: { vertical: "bottom", horizontal: "center" },
  right: { vertical: "center", horizontal: "right" }
};
var getActionBar = function(children) {
  return React3.Children.toArray(children).filter(function(child) {
    return child && child.type === PopoverActionsBar;
  });
};
var getContent = function(children) {
  return React3.Children.toArray(children).filter(function(child) {
    return child && child.type !== PopoverActionsBar;
  });
};
var Popover = React3.forwardRef(function(props, ref) {
  validatePackage(packageMetadata);
  var callout = props.callout, position = props.position, title = props.title, children = props.children, show = props.show, anchor = props.anchor, appendTo = props.appendTo, offset = props.offset, animate = props.animate, positionMode = props.positionMode, scale = props.scale, popoverClass = props.popoverClass, className = props.className, id = props.id, style = props.style, collision = props.collision, contentStyle = props.contentStyle, onPosition = props.onPosition, onClose = props.onClose, onOpen = props.onOpen;
  var _a = React3.useState(false), flipped = _a[0], setFlipped = _a[1];
  var isVertical = position === "top" || position === "bottom";
  var margin = props.margin || {
    vertical: callout && isVertical ? CALLOUT_SIZE : 0,
    horizontal: callout && !isVertical ? CALLOUT_SIZE : 0
  };
  var popupAlign = popupAlignByPosition[position];
  var anchorAlign = anchorAlignByPosition[position];
  var zindexContext = React3.useContext(ZIndexContext);
  var currentZindex = zindexContext ? zindexContext + ZINDEX_POPOVER_STEP : DEFAULT_POPOVER_ZINDEX;
  var popoverRef = React3.useRef(null);
  React3.useImperativeHandle(popoverRef, function() {
    return { props };
  });
  React3.useImperativeHandle(ref, function() {
    return popoverRef.current;
  });
  var handlePosition = React3.useCallback(function(e) {
    setTimeout(function() {
      return setFlipped(e.flipped);
    });
    if (onPosition) {
      var event_1 = { target: popoverRef.current, flipped: e.flipped, fitted: e.fitted };
      onPosition.call(void 0, event_1);
    }
  }, [onPosition, setFlipped]);
  var handleOpen = React3.useCallback(function() {
    if (onOpen) {
      var event_2 = { target: popoverRef.current };
      onOpen.call(void 0, event_2);
    }
  }, [onOpen]);
  var handleClose = React3.useCallback(function() {
    if (onClose) {
      var event_3 = { target: popoverRef.current };
      onClose.call(void 0, event_3);
    }
  }, [onClose]);
  var basePopupClass = { "k-popover": true, "k-popup": false };
  if (Array.isArray(popoverClass)) {
    popoverClass.forEach(function(currentClass) {
      return basePopupClass[currentClass] = true;
    });
  } else if (typeof popoverClass === "object") {
    Object.keys(popoverClass).forEach(function(key) {
      basePopupClass[key] = popoverClass[key];
    });
  } else if (popoverClass) {
    basePopupClass[popoverClass] = true;
  }
  var calloutClass = flipped ? calloutFlippedPositions[position] : calloutPositions[position];
  var popoverContent = React3.useMemo(function() {
    return React3.createElement(
      React3.Fragment,
      null,
      title && React3.createElement("div", { className: "k-popover-header" }, title),
      React3.createElement("div", { className: "k-popover-body", style: contentStyle }, getContent(children)),
      getActionBar(children)
    );
  }, [children, contentStyle, title]);
  return React3.createElement(
    ZIndexContext.Provider,
    { value: currentZindex },
    React3.createElement(Popup, { id, role: "tooltip", animate, collision, anchor, offset, margin, popupAlign, anchorAlign, appendTo, show, scale, positionMode, style, className, popupClass: basePopupClass, onOpen: handleOpen, onClose: handleClose, onPosition: handlePosition }, callout && position ? React3.createElement(
      React3.Fragment,
      null,
      React3.createElement("div", { className: classNames("k-popover-callout", calloutClass) }),
      React3.createElement("div", { className: "k-popover-inner" }, popoverContent)
    ) : popoverContent)
  );
});
var defaultProps2 = {
  callout: true,
  position: "top",
  collision: {
    horizontal: "none",
    vertical: "none"
  }
};
Popover.propTypes = {
  callout: PropTypes3.bool,
  title: PropTypes3.node,
  position: PropTypes3.oneOf(["top", "left", "bottom", "right"]),
  show: PropTypes3.bool,
  animate: PropTypes3.oneOfType([
    PropTypes3.bool,
    PropTypes3.shape({
      openDuration: PropTypes3.number,
      closeDuration: PropTypes3.number
    })
  ]),
  anchor: function(props) {
    var anchor = props.anchor;
    if (anchor && typeof anchor.nodeType !== "number") {
      return new Error("Invalid prop `anchor` supplied to `Kendo React Popover`. Validation failed.");
    }
    return null;
  },
  appendTo: function(props) {
    var element3 = props.appendTo;
    if (element3 && typeof element3.nodeType !== "number") {
      return new Error("Invalid prop `appendTo` supplied to `Kendo React Popover`. Validation failed.");
    }
    return null;
  },
  positionMode: PropTypes3.oneOf([
    "fixed",
    "absolute"
  ]),
  scale: PropTypes3.number,
  offset: PropTypes3.shape({
    left: PropTypes3.number,
    top: PropTypes3.number
  }),
  children: PropTypes3.oneOfType([
    PropTypes3.element,
    PropTypes3.node
  ]),
  className: PropTypes3.oneOfType([
    PropTypes3.string,
    PropTypes3.arrayOf(PropTypes3.string),
    PropTypes3.object
  ]),
  id: PropTypes3.string,
  popoverClass: PropTypes3.oneOfType([
    PropTypes3.string,
    PropTypes3.arrayOf(PropTypes3.string),
    PropTypes3.object
  ]),
  style: PropTypes3.object,
  onClose: PropTypes3.func,
  onPosition: PropTypes3.func,
  onOpen: PropTypes3.func
};
Popover.defaultProps = defaultProps2;
Popover.displayName = "KendoReactPopover";
export {
  Popover,
  PopoverActionsBar,
  Tooltip
};
//# sourceMappingURL=@progress_kendo-react-tooltip.js.map
