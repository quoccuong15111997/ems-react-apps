import {
  require_react_dom
} from "./chunk-3UUEUCWE.js";
import {
  ZIndexContext,
  canUseDOM,
  classNames,
  validatePackage2 as validatePackage
} from "./chunk-KTMNFILY.js";
import {
  require_prop_types
} from "./chunk-O6GWARG4.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/@progress/kendo-react-popup/dist/es/Popup.js
var React2 = __toESM(require_react());

// node_modules/@progress/kendo-react-popup/dist/es/PopupWithoutContext.js
var React = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-popup/dist/es/animation.js
var clearSlide = function(element2) {
  element2.style.transitionDuration = "";
  Array.from(element2.classList).forEach(function(c) {
    if (c.startsWith("k-slide-")) {
      element2.classList.remove(c);
    }
  });
};
var firefox = typeof window !== "undefined" && /Firefox/.test(window.navigator.userAgent);
var slide = function(element2, direction, duration, type, callback) {
  if (duration === 0) {
    return callback();
  }
  var slideClass = "k-slide-" + direction + "-" + type;
  var slideActiveClass = slideClass + "-active";
  var transitionend = function(e) {
    if (e.target === element2) {
      element2.removeEventListener("transitionend", transitionend);
      clearSlide(element2);
      if (type === "exit") {
        element2.style.display = "none";
      } else {
        element2.style.display = "";
      }
      callback();
    }
  };
  element2.addEventListener("transitionend", transitionend);
  var ownerDocument2 = element2.ownerDocument;
  if (!ownerDocument2) {
    return;
  }
  var defaultView = ownerDocument2.defaultView;
  if (!defaultView) {
    return;
  }
  var animate = function() {
    clearSlide(element2);
    element2.classList.add(slideClass);
    defaultView.requestAnimationFrame(function() {
      element2.style.transitionDuration = duration + "ms";
      element2.classList.add(slideActiveClass);
    });
  };
  if (firefox) {
    defaultView.requestAnimationFrame(animate);
  } else {
    animate();
  }
};

// node_modules/@progress/kendo-popup-common/dist/es/align-point.js
var align_point_default = {
  "bottom": "bottom",
  "center": "center",
  "middle": "middle",
  "left": "left",
  "right": "right",
  "top": "top"
};

// node_modules/@progress/kendo-popup-common/dist/es/align.js
var align = function(options) {
  var anchorRect = options.anchorRect;
  var anchorAlign = options.anchorAlign;
  var elementRect = options.elementRect;
  var elementAlign = options.elementAlign;
  var margin = options.margin;
  if (margin === void 0)
    margin = {};
  var anchorHorizontal = anchorAlign.horizontal;
  var anchorVertical = anchorAlign.vertical;
  var elementHorizontal = elementAlign.horizontal;
  var elementVertical = elementAlign.vertical;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var top = anchorRect.top;
  var left = anchorRect.left;
  if (anchorVertical === align_point_default.bottom) {
    top += anchorRect.height;
  }
  if (anchorVertical === align_point_default.center || anchorVertical === align_point_default.middle) {
    top += Math.round(anchorRect.height / 2);
  }
  if (elementVertical === align_point_default.bottom) {
    top -= elementRect.height;
    verticalMargin *= -1;
  }
  if (elementVertical === align_point_default.center || elementVertical === align_point_default.middle) {
    top -= Math.round(elementRect.height / 2);
    verticalMargin *= -1;
  }
  if (anchorHorizontal === align_point_default.right) {
    left += anchorRect.width;
  }
  if (anchorHorizontal === align_point_default.center || anchorHorizontal === align_point_default.middle) {
    left += Math.round(anchorRect.width / 2);
  }
  if (elementHorizontal === align_point_default.right) {
    left -= elementRect.width;
    horizontalMargin *= -1;
  }
  if (elementHorizontal === align_point_default.center || elementHorizontal === align_point_default.middle) {
    left -= Math.round(elementRect.width / 2);
    horizontalMargin *= -1;
  }
  return {
    top: top + verticalMargin,
    left: left + horizontalMargin
  };
};
var align_default = align;

// node_modules/@progress/kendo-popup-common/dist/es/add-scroll.js
function addScroll(rect, scroll) {
  return {
    top: rect.top + scroll.y,
    left: rect.left + scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/owner-document.js
function ownerDocument(element2) {
  return element2.ownerDocument || element2.document || element2;
}

// node_modules/@progress/kendo-popup-common/dist/es/window.js
var getWindow = function(element2) {
  return ownerDocument(element2).defaultView;
};
var window_default = getWindow;

// node_modules/@progress/kendo-popup-common/dist/es/document.js
var getDocument = function(element2) {
  return ownerDocument(element2).documentElement;
};
var document_default = getDocument;

// node_modules/@progress/kendo-popup-common/dist/es/scrollbar-width.js
var cachedWidth = 0;
function scrollbarWidth() {
  if (!cachedWidth && typeof document !== "undefined") {
    var div = document.createElement("div");
    div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    cachedWidth = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return cachedWidth;
}

// node_modules/@progress/kendo-popup-common/dist/es/window-viewport.js
function windowViewport(element2) {
  var win = window_default(element2);
  var document2 = document_default(element2);
  var result = {
    height: win.innerHeight,
    width: win.innerWidth
  };
  if (document2.scrollHeight - document2.clientHeight > 0) {
    result.width -= scrollbarWidth();
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/bounding-offset.js
var boundingOffset = function(element2) {
  if (!element2.getBoundingClientRect) {
    var viewport = windowViewport(element2);
    return {
      bottom: viewport.height,
      left: 0,
      right: viewport.width,
      top: 0
    };
  }
  var ref = element2.getBoundingClientRect();
  var bottom = ref.bottom;
  var left = ref.left;
  var right = ref.right;
  var top = ref.top;
  return {
    bottom,
    left,
    right,
    top
  };
};
var bounding_offset_default = boundingOffset;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent.js
var offsetParent = function(element2) {
  var offsetParent2 = element2.offsetParent;
  while (offsetParent2 && offsetParent2.style.position === "static") {
    offsetParent2 = offsetParent2.offsetParent;
  }
  return offsetParent2 || document_default(element2);
};
var offset_parent_default = offsetParent;

// node_modules/@progress/kendo-popup-common/dist/es/offset.js
var rectOfHiddenElement = function(element2) {
  var ref = element2.style;
  var display = ref.display;
  var left = ref.left;
  var position3 = ref.position;
  element2.style.display = "";
  element2.style.left = "-10000px";
  element2.style.position = "absolute";
  var rect = element2.getBoundingClientRect();
  element2.style.display = display;
  element2.style.left = left;
  element2.style.position = position3;
  return rect;
};
var offset = function(element2) {
  var rect = element2.getBoundingClientRect();
  var left = rect.left;
  var top = rect.top;
  if (!rect.height && !rect.width) {
    rect = rectOfHiddenElement(element2);
  }
  return {
    top,
    left,
    height: rect.height,
    width: rect.width
  };
};
var offset_default = offset;

// node_modules/@progress/kendo-popup-common/dist/es/parents.js
function parents_default(element2, until) {
  var result = [];
  var next = element2.parentNode;
  while (next) {
    result.push(next);
    if (next === until) {
      break;
    }
    next = next.parentNode;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/scroll-position.js
function scrollPosition(element2) {
  var documentElement = document_default(element2);
  var win = window_default(element2);
  return {
    x: win.pageXOffset || documentElement.scrollLeft || 0,
    y: win.pageYOffset || documentElement.scrollTop || 0
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/element-scroll-position.js
function element_scroll_position_default(element2) {
  if (element2 === (element2.ownerDocument || {}).body) {
    return scrollPosition(element2);
  }
  return {
    x: element2.scrollLeft,
    y: element2.scrollTop
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/parent-scroll-position.js
function parentScrollPosition(element2) {
  var parent = offset_parent_default(element2);
  return parent ? element_scroll_position_default(parent) : { x: 0, y: 0 };
}

// node_modules/@progress/kendo-popup-common/dist/es/position.js
var position = function(element2, parent) {
  var win = window_default(element2);
  var elementStyles = win.getComputedStyle(element2);
  var offset3 = offset_default(element2);
  var parentElement = parent || offset_parent_default(element2);
  var ownerDocument2 = element2.ownerDocument;
  var useRelative = parentElement !== ownerDocument2.body && parentElement !== ownerDocument2.documentElement;
  var parentOffset = { top: 0, left: 0 };
  if (elementStyles.position !== "fixed" && useRelative) {
    var parentStyles = win.getComputedStyle(parentElement);
    parentOffset = offset_default(parentElement);
    parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);
    parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);
  }
  return {
    top: offset3.top - parentOffset.top,
    left: offset3.left - parentOffset.left,
    height: offset3.height,
    width: offset3.width
  };
};
var position_default = position;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent-scroll-position.js
function offset_parent_scroll_position_default(offsetParentElement, element2) {
  return (
    // eslint-disable-line no-arrow-condition
    offsetParentElement ? element_scroll_position_default(offsetParentElement) : parentScrollPosition(element2)
  );
}

// node_modules/@progress/kendo-popup-common/dist/es/position-with-scroll.js
function position_with_scroll_default(element2, parent, scale) {
  if (scale === void 0)
    scale = 1;
  var offsetParentElement = parent ? offset_parent_default(parent) : null;
  var ref = position_default(element2, offsetParentElement);
  var top = ref.top;
  var left = ref.left;
  var height = ref.height;
  var width = ref.width;
  var ref$1 = offset_parent_scroll_position_default(offsetParentElement, element2);
  var x = ref$1.x;
  var y = ref$1.y;
  var ownerDocument2 = element2.ownerDocument;
  var positionScale = offsetParentElement === ownerDocument2.body || offsetParentElement === ownerDocument2.documentElement ? 1 : scale;
  return {
    top: top + y * positionScale,
    left: left + x * positionScale,
    height,
    width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/remove-scroll.js
function removeScroll(rect, scroll) {
  return {
    top: rect.top - scroll.y,
    left: rect.left - scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/collision.js
var collision_default = {
  "fit": "fit",
  "flip": "flip",
  "none": "none"
};

// node_modules/@progress/kendo-popup-common/dist/es/restrict-to-view.js
var fit = function(position3, size, viewPortSize) {
  var output = 0;
  if (position3 + size > viewPortSize) {
    output = viewPortSize - (position3 + size);
  }
  if (position3 < 0) {
    output = -position3;
  }
  return output;
};
var flip = function(ref) {
  var offset3 = ref.offset;
  var size = ref.size;
  var anchorSize = ref.anchorSize;
  var viewPortSize = ref.viewPortSize;
  var anchorAlignPoint = ref.anchorAlignPoint;
  var elementAlignPoint = ref.elementAlignPoint;
  var margin = ref.margin;
  var output = 0;
  var isPositionCentered = elementAlignPoint === align_point_default.center || elementAlignPoint === align_point_default.middle;
  var isOriginCentered = anchorAlignPoint === align_point_default.center || anchorAlignPoint === align_point_default.middle;
  var marginToAdd = 2 * margin;
  if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {
    var isBeforeAnchor = anchorAlignPoint === align_point_default.top || anchorAlignPoint === align_point_default.left;
    if (offset3 < 0 && isBeforeAnchor) {
      output = size + anchorSize + marginToAdd;
      if (offset3 + output + size > viewPortSize) {
        output = 0;
      }
    } else if (offset3 >= 0 && !isBeforeAnchor) {
      if (offset3 + size > viewPortSize) {
        output += -(anchorSize + size + marginToAdd);
      }
      if (offset3 + output < 0) {
        output = 0;
      }
    }
  }
  return output;
};
var restrictToView = function(options) {
  var anchorRect = options.anchorRect;
  var anchorAlign = options.anchorAlign;
  var elementRect = options.elementRect;
  var elementAlign = options.elementAlign;
  var collisions = options.collisions;
  var viewPort = options.viewPort;
  var margin = options.margin;
  if (margin === void 0)
    margin = {};
  var elementTop = elementRect.top;
  var elementLeft = elementRect.left;
  var elementHeight = elementRect.height;
  var elementWidth = elementRect.width;
  var viewPortHeight = viewPort.height;
  var viewPortWidth = viewPort.width;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var left = 0;
  var top = 0;
  var isVerticalFit = collisions.vertical === collision_default.fit;
  var isHorizontalFit = collisions.horizontal === collision_default.fit;
  var isVerticalFlip = collisions.vertical === collision_default.flip;
  var isHorizontalFlip = collisions.horizontal === collision_default.flip;
  if (isVerticalFit) {
    top += fit(elementTop, elementHeight, viewPortHeight);
  }
  if (isHorizontalFit) {
    left += fit(elementLeft, elementWidth, viewPortWidth);
  }
  if (isVerticalFlip) {
    top += flip({
      margin: verticalMargin,
      offset: elementTop,
      size: elementHeight,
      anchorSize: anchorRect.height,
      viewPortSize: viewPortHeight,
      anchorAlignPoint: anchorAlign.vertical,
      elementAlignPoint: elementAlign.vertical
    });
  }
  if (isHorizontalFlip) {
    left += flip({
      margin: horizontalMargin,
      offset: elementLeft,
      size: elementWidth,
      anchorSize: anchorRect.width,
      viewPortSize: viewPortWidth,
      anchorAlignPoint: anchorAlign.horizontal,
      elementAlignPoint: elementAlign.horizontal
    });
  }
  var flippedVertical = isVerticalFlip && top !== 0;
  var flippedHorizontal = isHorizontalFlip && left !== 0;
  var fittedVertical = isVerticalFit && top !== 0;
  var fittedHorizontal = isHorizontalFit && left !== 0;
  return {
    flipped: flippedHorizontal || flippedVertical,
    fitted: fittedVertical || fittedHorizontal,
    flip: {
      horizontal: flippedHorizontal,
      vertical: flippedVertical
    },
    fit: {
      horizontal: fittedHorizontal,
      vertical: fittedVertical
    },
    offset: {
      left,
      top
    }
  };
};
var restrict_to_view_default = restrictToView;

// node_modules/@progress/kendo-popup-common/dist/es/siblings.js
function siblings_default(element2) {
  var result = [];
  var sibling = element2.parentNode.firstElementChild;
  while (sibling) {
    if (sibling !== element2) {
      result.push(sibling);
    }
    sibling = sibling.nextElementSibling;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/sibling-container.js
function sibling_container_default(anchor, container) {
  var parentElements = parents_default(anchor);
  var containerElement = container;
  var siblingElements;
  var result;
  while (containerElement) {
    siblingElements = siblings_default(containerElement);
    result = parentElements.reduce(
      function(list, p) {
        return list.concat(siblingElements.filter(function(s) {
          return s === p;
        }));
      },
      []
    )[0];
    if (result) {
      break;
    }
    containerElement = containerElement.parentElement;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/utils.js
var eitherRect = function(rect, offset3) {
  if (!rect) {
    return { height: 0, left: offset3.left, top: offset3.top, width: 0 };
  }
  return rect;
};
var scaleRect = function(rect, scale) {
  if (!rect || scale === 1) {
    return rect;
  }
  return {
    height: rect.height / scale,
    left: rect.left / scale,
    top: rect.top / scale,
    width: rect.width / scale
  };
};
var removeStackingOffset = function(rect, stackingOffset) {
  if (!stackingOffset) {
    return rect;
  }
  var result = {
    height: rect.height,
    left: rect.left - stackingOffset.left,
    top: rect.top - stackingOffset.top,
    width: rect.width
  };
  return result;
};
function memoize(fun) {
  var result;
  var called = false;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (called) {
      return result;
    }
    result = fun.apply(void 0, args);
    called = true;
    return result;
  };
}
var hasRelativeStackingContext = memoize(function(elementSource) {
  if (!canUseDOM2()) {
    return false;
  }
  var currentDocument = elementSource ? elementSource.ownerDocument : document;
  if (!currentDocument || !currentDocument.body) {
    return false;
  }
  var top = 10;
  var parent = currentDocument.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  parent.innerHTML = '<div style="position: fixed; top: ' + top + 'px;">child</div>';
  currentDocument.body.appendChild(parent);
  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  currentDocument.body.removeChild(parent);
  return isDifferent;
});
var canUseDOM2 = function() {
  return Boolean(
    // from fbjs
    typeof window !== "undefined" && window.document && window.document.createElement
  );
};
var utils = {
  eitherRect,
  scaleRect,
  removeStackingOffset,
  hasRelativeStackingContext,
  canUseDOM: canUseDOM2
};
var utils_default = utils;

// node_modules/@progress/kendo-popup-common/dist/es/dom-utils.js
var STYLES = [
  "font-size",
  "font-family",
  "font-stretch",
  "font-style",
  "font-weight",
  "line-height"
];
var addOffset = function(current, addition) {
  return {
    left: current.left + addition.left,
    top: current.top + addition.top
  };
};
var getWindow2 = function() {
  return utils_default.canUseDOM() ? window : null;
};
var getFontStyles = function(el) {
  var window2 = getWindow2();
  if (!window2 || !el) {
    return [];
  }
  var computedStyles = window2.getComputedStyle(el);
  return STYLES.map(function(font) {
    return { key: font, value: computedStyles[font] };
  });
};
var hasOffsetParent = function(el) {
  if (!el) {
    return false;
  }
  return Boolean(el.offsetParent);
};
var offset2 = function(el) {
  if (!el) {
    return null;
  }
  return offset_default(el);
};
var offsetAtPoint = function(element2, currentLocation) {
  if (!element2) {
    return null;
  }
  var ref = element2.style;
  var left = ref.left;
  var top = ref.top;
  var transition = ref.transition;
  element2.style.transition = "none";
  element2.style.left = currentLocation.left + "px";
  element2.style.top = currentLocation.top + "px";
  var currentOffset = offset_default(element2);
  element2.style.left = left;
  element2.style.top = top;
  element2.offsetHeight;
  element2.style.transition = transition;
  return currentOffset;
};
var position2 = function(element2, popupElement, scale) {
  if (!element2 || !popupElement) {
    return null;
  }
  var currentScale = scale || 1;
  return position_with_scroll_default(element2, popupElement, currentScale);
};
var OVERFLOW_REGEXP = /auto|scroll/;
var overflowElementStyle = function(element2) {
  return "" + element2.style.overflow + element2.style.overflowX + element2.style.overflowY;
};
var overflowComputedStyle = function(element2) {
  var styles = window.getComputedStyle(element2);
  return "" + styles.overflow + styles.overflowX + styles.overflowY;
};
var overflowStyle = function(element2) {
  return overflowElementStyle(element2) || overflowComputedStyle(element2);
};
var scrollableParents = function(element2) {
  var parentElements = [];
  if (!utils_default.canUseDOM()) {
    return parentElements;
  }
  var parent = element2.parentElement;
  while (parent) {
    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute("data-scrollable")) {
      parentElements.push(parent);
    }
    parent = parent.parentElement;
  }
  parentElements.push(window);
  return parentElements;
};
var getRelativeContextElement = function(el) {
  if (!el || !utils_default.hasRelativeStackingContext()) {
    return null;
  }
  var parent = el.parentElement;
  while (parent) {
    if (window.getComputedStyle(parent).transform !== "none") {
      return parent;
    }
    parent = parent.parentElement;
  }
  return null;
};
var stackingElementOffset = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return null;
  }
  return offset_default(relativeContextElement);
};
var stackingElementScroll = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return { x: 0, y: 0 };
  }
  return {
    x: relativeContextElement.scrollLeft,
    y: relativeContextElement.scrollTop
  };
};
var stackingElementViewPort = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return null;
  }
  return {
    height: relativeContextElement.scrollHeight,
    width: relativeContextElement.scrollWidth
  };
};
var useRelativePosition = function(el) {
  return Boolean(getRelativeContextElement(el));
};
var zoomLevel = function() {
  if (!utils_default.canUseDOM()) {
    return 1;
  }
  return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;
};
var isZoomed = function() {
  return zoomLevel() > 1;
};
var zIndex = function(anchor, container) {
  if (!anchor || !utils_default.canUseDOM()) {
    return null;
  }
  var sibling = sibling_container_default(anchor, container);
  if (!sibling) {
    return null;
  }
  var result = [anchor].concat(parents_default(anchor, sibling)).reduce(
    function(index, p) {
      var zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
      var current = parseInt(zIndexStyle, 10);
      return current > index ? current : index;
    },
    0
  );
  return result ? result + 1 : null;
};
var domUtils = {
  addOffset,
  addScroll,
  align: align_default,
  boundingOffset: bounding_offset_default,
  getFontStyles,
  getWindow: getWindow2,
  hasOffsetParent,
  offset: offset2,
  offsetAtPoint,
  position: position2,
  removeScroll,
  restrictToView: restrict_to_view_default,
  scrollPosition,
  scrollableParents,
  getRelativeContextElement,
  stackingElementOffset,
  stackingElementScroll,
  stackingElementViewPort,
  useRelativePosition,
  windowViewPort: windowViewport,
  zoomLevel,
  isZoomed,
  zIndex
};
var dom_utils_default = domUtils;

// node_modules/@progress/kendo-popup-common/dist/es/align-element.js
var absoluteRect = function(anchor, element2, offset3, scale) {
  var scrollPos = elementScrollPosition(anchor, element2);
  var rect = utils_default.eitherRect(dom_utils_default.offset(anchor), offset3);
  var stackScale = 2 * scale;
  var stackScroll = dom_utils_default.stackingElementScroll(element2);
  if (scale !== 1 && stackScroll) {
    stackScroll.x /= stackScale;
    stackScroll.y /= stackScale;
  }
  var stackOffset = dom_utils_default.stackingElementOffset(element2);
  if (scale !== 1 && stackOffset) {
    stackOffset.left /= stackScale;
    stackOffset.top /= stackScale;
  }
  return dom_utils_default.removeScroll(
    dom_utils_default.addScroll(
      utils_default.removeStackingOffset(
        utils_default.scaleRect(rect, scale),
        stackOffset
      ),
      stackScroll
    ),
    scrollPos
  );
};
var relativeRect = function(anchor, element2, offset3, scale) {
  var rect = utils_default.eitherRect(dom_utils_default.position(anchor, element2, scale), offset3);
  return utils_default.scaleRect(rect, scale);
};
var elementScrollPosition = function(anchor, element2) {
  return anchor ? { x: 0, y: 0 } : dom_utils_default.scrollPosition(element2);
};
var alignElement = function(settings) {
  var anchor = settings.anchor;
  var element2 = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var margin = settings.margin;
  var offset3 = settings.offset;
  var positionMode = settings.positionMode;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var fixedMode = positionMode === "fixed" || !dom_utils_default.hasOffsetParent(element2);
  var anchorRect = fixedMode ? absoluteRect(anchor, element2, offset3, currentScale) : relativeRect(anchor, element2, offset3, currentScale);
  var elementRect = utils_default.scaleRect(dom_utils_default.offset(element2), currentScale);
  var result = dom_utils_default.align({
    anchorAlign,
    anchorRect,
    elementAlign,
    elementRect,
    margin
  });
  return result;
};
var align_element_default = alignElement;

// node_modules/@progress/kendo-popup-common/dist/es/position-element.js
var positionElement = function(settings) {
  var anchor = settings.anchor;
  var currentLocation = settings.currentLocation;
  var element2 = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var collisions = settings.collisions;
  var margin = settings.margin;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var elementOffset = dom_utils_default.offsetAtPoint(element2, currentLocation);
  var elementRect = utils_default.scaleRect(elementOffset, currentScale);
  var anchorOffset = utils_default.scaleRect(dom_utils_default.offset(anchor), currentScale);
  var anchorRect = utils_default.eitherRect(anchorOffset, currentLocation);
  var viewPort = settings.viewPort || dom_utils_default.windowViewPort(element2);
  viewPort.width = viewPort.width / currentScale;
  viewPort.height = viewPort.height / currentScale;
  var result = dom_utils_default.restrictToView({
    anchorAlign,
    anchorRect,
    collisions,
    elementAlign,
    elementRect,
    margin,
    viewPort
  });
  var offset3 = dom_utils_default.addOffset(currentLocation, result.offset);
  return {
    flip: result.flip,
    flipped: result.flipped,
    offset: offset3
  };
};
var position_element_default = positionElement;

// node_modules/@progress/kendo-react-popup/dist/es/util.js
var FRAME_DURATION = 1e3 / 60;
var throttle = function(func2, wait, options) {
  if (options === void 0) {
    options = {};
  }
  var timeout, context, args, result;
  var previous = 0;
  options = options || {};
  var later = function() {
    previous = options.leading === false ? 0 : new Date().getTime();
    timeout = void 0;
    result = func2.apply(context, args);
    if (!timeout) {
      context = args = null;
    }
  };
  var throttled = function() {
    var now = new Date().getTime();
    if (!previous && options.leading === false) {
      previous = now;
    }
    var remaining = wait - (now - previous);
    context = void 0;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      previous = now;
      result = func2.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    } else if (!timeout && options.trailing !== false) {
      timeout = window.setTimeout(later, remaining);
    }
    return result;
  };
  return throttled;
};

// node_modules/@progress/kendo-react-popup/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-react-popup",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1680171506,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-popup/dist/es/PopupWithoutContext.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var DEFAULT_POPUP_ZINDEX = 100;
var ZINDEX_POPUP_STEP = 1;
function isEquivalent(a, b) {
  if (a === b) {
    return true;
  }
  if (!!a !== !!b) {
    return false;
  }
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);
  if (aProps.length !== bProps.length) {
    return false;
  }
  for (var i = 0; i < aProps.length; i++) {
    var propName = aProps[i];
    if (a[propName] !== b[propName]) {
      return false;
    }
  }
  return true;
}
var DEFAULT_OFFSET = {
  left: -1e3,
  top: 0
};
var Status;
(function(Status2) {
  Status2["hiding"] = "hiding";
  Status2["hidden"] = "hidden";
  Status2["showing"] = "showing";
  Status2["shown"] = "shown";
  Status2["reposition"] = "reposition";
})(Status || (Status = {}));
var ANIMATION_CONTAINER = "k-animation-container";
var ANIMATION_CONTAINER_SHOWN = "k-animation-container-shown";
var ANIMATION_CONTAINER_RELATIVE = "k-animation-container-relative";
var ANIMATION_CONTAINER_CHILD = "k-child-animation-container";
var K_POPUP = "k-popup";
var PopupWithoutContext = (
  /** @class */
  function(_super) {
    __extends(PopupWithoutContext2, _super);
    function PopupWithoutContext2(props) {
      var _this = _super.call(this, props) || this;
      _this.context = 0;
      _this.state = { current: Status.hidden, previous: Status.hidden, props: {} };
      _this._popup = null;
      _this.show = function(popup) {
        _this.setPosition(popup);
        _this.animate(popup.firstChild, "enter", _this.onOpened);
        _this.setState({ current: Status.shown, previous: _this.state.current });
      };
      _this.setPosition = function(popup) {
        var _a = _this.props, anchorAlign = _a.anchorAlign, popupAlign = _a.popupAlign, collision = _a.collision, offset3 = _a.offset, anchor = _a.anchor, margin = _a.margin, scale = _a.scale, positionMode = _a.positionMode;
        var _b = popup.style, width = _b.width, height = _b.height;
        popup.style.width = popup.offsetWidth + "px";
        popup.style.height = popup.offsetHeight + "px";
        var alignedOffset = align_element_default({
          anchor,
          anchorAlign,
          element: popup,
          elementAlign: popupAlign,
          offset: offset3,
          margin,
          positionMode,
          scale
        });
        var position3 = position_element_default({
          anchor,
          anchorAlign,
          element: popup,
          elementAlign: popupAlign,
          collisions: collision,
          currentLocation: alignedOffset,
          margin: _this.props.margin
        });
        popup.style.top = position3.offset.top + "px";
        popup.style.left = position3.offset.left + "px";
        popup.style.width = width;
        popup.style.height = height;
        _this._collisions = {
          fit: position3.fit,
          fitted: position3.fitted,
          flip: position3.flip,
          flipped: position3.flipped
        };
        if (_this.props.onPosition) {
          var event_1 = {
            target: _this,
            flipped: position3.flipped,
            fitted: position3.fitted
          };
          _this.props.onPosition.call(void 0, event_1);
        }
      };
      _this.onOpened = function() {
        var element2 = _this._popup;
        if (!element2) {
          return;
        }
        if (_this.props.show) {
          element2.classList.add(ANIMATION_CONTAINER_SHOWN);
        }
        _this.attachRepositionHandlers(element2);
        if (_this.props.onOpen) {
          _this.props.onOpen.call(void 0, { target: _this });
        }
      };
      _this.animate = function(element2, type, callback) {
        if (!_this.props.popupAlign) {
          return;
        }
        var animationDirection;
        var _a = _this.props.popupAlign, horizontal = _a.horizontal, vertical = _a.vertical;
        if (horizontal === "left" && vertical === "center") {
          animationDirection = "right";
        } else if (horizontal === "right" && vertical === "center") {
          animationDirection = "left";
        } else if (vertical === "top") {
          animationDirection = "down";
        } else {
          animationDirection = "up";
        }
        var flipPositions = {
          down: "up",
          up: "down",
          left: "right",
          right: "left"
        };
        if (_this._collisions && _this._collisions.flipped) {
          animationDirection = flipPositions[animationDirection];
        }
        slide(element2, animationDirection, _this.animationDuration[type], type, callback);
      };
      _this.onClosing = function(popup) {
        if (!_this.props.show) {
          popup.classList.remove(ANIMATION_CONTAINER_SHOWN);
        }
        _this.detachRepositionHandlers();
      };
      _this.onClosed = function() {
        if (_this.state.current === Status.hiding && _this.state.previous === Status.shown) {
          _this.setState({ current: Status.hidden, previous: _this.state.current });
        }
        if (_this.props.onClose) {
          _this.props.onClose.call(void 0, { target: _this });
        }
      };
      _this.getCurrentZIndex = function() {
        return _this.context ? _this.context + ZINDEX_POPUP_STEP : DEFAULT_POPUP_ZINDEX;
      };
      validatePackage(packageMetadata);
      _this.reposition = throttle(_this.reposition.bind(_this), FRAME_DURATION);
      return _this;
    }
    Object.defineProperty(PopupWithoutContext2.prototype, "element", {
      /**
       * Represents the Popup DOM element.
       */
      get: function() {
        return this._popup;
      },
      enumerable: false,
      configurable: true
    });
    PopupWithoutContext2.getDerivedStateFromProps = function(props, state) {
      var show = props.show, anchor = props.anchor, anchorAlign = props.anchorAlign, appendTo = props.appendTo, collision = props.collision, popupAlign = props.popupAlign, className = props.className, popupClass = props.popupClass, style = props.style, offset3 = props.offset, contentKey = props.contentKey;
      var nextState = __assign(__assign({}, state), { props: {
        show,
        anchor,
        anchorAlign,
        appendTo,
        collision,
        popupAlign,
        className,
        popupClass,
        style,
        offset: offset3,
        contentKey
      } });
      if (props.show) {
        if (state.current === Status.hidden || state.current === Status.hiding) {
          return __assign(__assign({}, nextState), { current: Status.showing, previous: state.current });
        }
        if (state.current === Status.showing) {
          return __assign(__assign({}, nextState), { current: Status.shown, previous: state.current });
        }
        if (state.current === Status.shown && (!isEquivalent(offset3, state.props.offset) || !isEquivalent(anchorAlign, state.props.anchorAlign) || !isEquivalent(appendTo, state.props.appendTo) || !isEquivalent(collision, state.props.collision) || !isEquivalent(popupAlign, state.props.popupAlign) || !isEquivalent(style, state.props.style) || anchor !== state.props.anchor || popupClass !== state.props.popupClass || className !== state.props.className)) {
          return __assign(__assign({}, nextState), { current: Status.reposition, previous: state.current });
        }
        return nextState;
      }
      if (state.current === Status.hiding || state.current === Status.hidden) {
        return __assign(__assign({}, nextState), { current: Status.hidden, previous: state.current });
      }
      return __assign(__assign({}, nextState), { current: Status.hiding, previous: state.current });
    };
    PopupWithoutContext2.prototype.componentDidUpdate = function(prevProps) {
      if (this.state.current === Status.showing && this._popup) {
        this.show(this._popup);
      } else if (this.state.current === Status.hiding && this._popup) {
        this.onClosing(this._popup);
        this.animate(this._popup.firstChild, "exit", this.onClosed);
      } else if (this.state.current === Status.reposition && this.state.previous === Status.shown) {
        this.setState({ current: Status.shown, previous: this.state.current });
      } else if (this.state.current === Status.shown && prevProps.contentKey !== this.props.contentKey && this._popup) {
        this.setPosition(this._popup);
      }
    };
    PopupWithoutContext2.prototype.componentDidMount = function() {
      if (this.state.current === Status.showing && this._popup) {
        this.show(this._popup);
      }
    };
    PopupWithoutContext2.prototype.componentWillUnmount = function() {
      this.detachRepositionHandlers();
    };
    PopupWithoutContext2.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, className = _a.className, popupClass = _a.popupClass, show = _a.show, id = _a.id, positionMode = _a.positionMode;
      var calculatedAppendTo = this.props.appendTo ? this.props.appendTo : canUseDOM ? this.props.anchor && this.props.anchor.ownerDocument ? this.props.anchor.ownerDocument.body : document.body : void 0;
      if (this.state.current === Status.reposition && this.state.previous === Status.shown && this._popup) {
        this.setPosition(this._popup);
      }
      var style = Object.assign({}, { position: positionMode, top: 0, left: -1e4 }, this.props.style || {});
      var closing = this.state.current === Status.hiding;
      if ((show || closing) && calculatedAppendTo) {
        var currentZIndex = this.getCurrentZIndex();
        var popupElement = React.createElement(
          ZIndexContext.Provider,
          { value: currentZIndex },
          React.createElement(
            "div",
            { className: classNames(ANIMATION_CONTAINER, ANIMATION_CONTAINER_RELATIVE, className), id, ref: function(e) {
              return _this._popup = e;
            }, style: __assign({ zIndex: currentZIndex }, style) },
            React.createElement("div", { role: this.props.role, className: classNames(K_POPUP, popupClass, ANIMATION_CONTAINER_CHILD), style: { transitionDelay: "0ms" } }, children)
          )
        );
        return this.props.appendTo !== null ? ReactDOM.createPortal(popupElement, calculatedAppendTo) : popupElement;
      }
      return null;
    };
    Object.defineProperty(PopupWithoutContext2.prototype, "animationDuration", {
      get: function() {
        var animate = this.props.animate;
        var enter = 0;
        var exit = 0;
        if (animate) {
          if (animate === true) {
            enter = exit = 300;
          } else {
            enter = animate.openDuration || 0;
            exit = animate.closeDuration || 0;
          }
        }
        return { enter, exit };
      },
      enumerable: false,
      configurable: true
    });
    PopupWithoutContext2.prototype.attachRepositionHandlers = function(element2) {
      var _this = this;
      this.detachRepositionHandlers();
      this._scrollableParents = dom_utils_default.scrollableParents(this.props.anchor || element2);
      if (this._scrollableParents) {
        this._scrollableParents.map(function(p) {
          return p.addEventListener("scroll", _this.reposition);
        });
      }
      window.addEventListener("resize", this.reposition);
    };
    PopupWithoutContext2.prototype.detachRepositionHandlers = function() {
      var _this = this;
      if (this._scrollableParents) {
        this._scrollableParents.map(function(p) {
          return p.removeEventListener("scroll", _this.reposition);
        });
        this._scrollableParents = void 0;
      }
      window.removeEventListener("resize", this.reposition);
    };
    PopupWithoutContext2.prototype.reposition = function() {
      this.setState({ current: Status.reposition, previous: this.state.current });
    };
    PopupWithoutContext2.propTypes = {
      anchor: function(props) {
        var anchor = props.anchor;
        if (anchor && typeof anchor.nodeType !== "number") {
          return new Error("Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.");
        }
        return null;
      },
      appendTo: function(props) {
        var element2 = props.appendTo;
        if (element2 && typeof element2.nodeType !== "number") {
          return new Error("Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.");
        }
        return null;
      },
      className: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.object
      ]),
      id: PropTypes.string,
      popupClass: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.object
      ]),
      collision: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          collision_default.fit,
          collision_default.flip,
          collision_default.none
        ]),
        vertical: PropTypes.oneOf([
          collision_default.fit,
          collision_default.flip,
          collision_default.none
        ])
      }),
      anchorAlign: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          align_point_default.left,
          align_point_default.center,
          align_point_default.right
        ]),
        vertical: PropTypes.oneOf([
          align_point_default.top,
          align_point_default.center,
          align_point_default.bottom
        ])
      }),
      popupAlign: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          align_point_default.left,
          align_point_default.center,
          align_point_default.right
        ]),
        vertical: PropTypes.oneOf([
          align_point_default.top,
          align_point_default.center,
          align_point_default.bottom
        ])
      }),
      offset: PropTypes.shape({
        left: PropTypes.number,
        top: PropTypes.number
      }),
      children: PropTypes.oneOfType([
        PropTypes.element,
        PropTypes.node
      ]),
      show: PropTypes.bool,
      animate: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.shape({
          openDuration: PropTypes.number,
          closeDuration: PropTypes.number
        })
      ]),
      margin: PropTypes.shape({
        horizontal: PropTypes.number,
        vertical: PropTypes.number
      }),
      positionMode: PropTypes.oneOf([
        "fixed",
        "absolute"
      ]),
      scale: PropTypes.number,
      style: PropTypes.object,
      onClose: PropTypes.func,
      onPosition: PropTypes.func,
      onOpen: PropTypes.func
    };
    PopupWithoutContext2.defaultProps = {
      collision: {
        horizontal: collision_default.fit,
        vertical: collision_default.flip
      },
      anchorAlign: {
        horizontal: align_point_default.left,
        vertical: align_point_default.bottom
      },
      popupAlign: {
        horizontal: align_point_default.left,
        vertical: align_point_default.top
      },
      offset: DEFAULT_OFFSET,
      animate: true,
      show: false,
      margin: {
        horizontal: 0,
        vertical: 0
      },
      positionMode: "absolute"
    };
    PopupWithoutContext2.contextType = ZIndexContext;
    PopupWithoutContext2.displayName = "PopupComponent";
    return PopupWithoutContext2;
  }(React.Component)
);

// node_modules/@progress/kendo-react-popup/dist/es/Popup.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var PopupPropsContext = React2.createContext(function(props) {
  return props;
});
var Popup = React2.forwardRef(function(props, ref) {
  var contextPropsCallback = React2.useContext(PopupPropsContext);
  var popupProps = contextPropsCallback.call(void 0, props);
  return React2.createElement(PopupWithoutContext, __assign2({ ref }, popupProps));
});
Popup.displayName = "Popup";

export {
  PopupPropsContext,
  Popup
};
//# sourceMappingURL=chunk-XVBPUVJV.js.map
