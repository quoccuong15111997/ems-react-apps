import {
  classNames,
  kendoThemeMaps,
  useDir,
  validatePackage2 as validatePackage
} from "./chunk-KTMNFILY.js";
import {
  require_prop_types
} from "./chunk-O6GWARG4.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/@progress/kendo-react-indicators/dist/es/badge/Badge.js
var React = __toESM(require_react());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-indicators/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-react-indicators",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1680172477,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-indicators/dist/es/badge/Badge.js
var Badge = React.forwardRef(function(props, target) {
  validatePackage(packageMetadata);
  var children = props.children, className = props.className, style = props.style;
  var elementRef = React.useRef(null);
  var focusElement = React.useCallback(function() {
    if (elementRef.current) {
      elementRef.current.focus();
    }
  }, []);
  React.useImperativeHandle(target, function() {
    return {
      element: elementRef.current,
      focus: focusElement
    };
  });
  var dir = useDir(elementRef, props.dir);
  var size = React.useMemo(function() {
    if (props.size === null) {
      return null;
    } else {
      return props.size || defaultProps.size;
    }
  }, [props.size]);
  var fillMode = React.useMemo(function() {
    if (props.fillMode === null) {
      return null;
    } else if (props.fill === null) {
      return null;
    } else {
      return props.fill || props.fillMode || defaultProps.fillMode;
    }
  }, [props.fillMode, props.fill]);
  var themeColor = React.useMemo(function() {
    return props.themeColor || defaultProps.themeColor;
  }, [props.themeColor]);
  var rounded = React.useMemo(function() {
    if (props.rounded !== void 0) {
      return props.rounded || "medium";
    } else if (props.shape !== void 0) {
      switch (props.shape) {
        case "rounded":
          return "md";
        case "rectangle":
          return null;
        default:
          return "full";
      }
    }
    return "medium";
  }, [props.rounded, props.shape]);
  var _a = props.cutoutBorder, cutoutBorder = _a === void 0 ? defaultProps.cutoutBorder : _a, _b = props.position, position = _b === void 0 ? defaultProps.position : _b, _c = props.align, align = _c === void 0 ? defaultProps.align : _c;
  var badgeClasses = React.useMemo(function() {
    var _a2;
    return classNames("k-badge", (_a2 = {
      "k-badge-sm": size === "small",
      "k-badge-md": size === "medium",
      "k-badge-lg": size === "large"
    }, _a2["k-badge-".concat(fillMode)] = fillMode, _a2["k-badge-".concat(fillMode, "-").concat(themeColor)] = Boolean(fillMode && themeColor), _a2["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a2["k-badge-border-cutout"] = cutoutBorder, _a2["k-badge-".concat(position)] = position, _a2["k-top-start"] = align.vertical === "top" && align.horizontal === "start", _a2["k-top-end"] = align.vertical === "top" && align.horizontal === "end", _a2["k-bottom-start"] = align.vertical === "bottom" && align.horizontal === "start", _a2["k-bottom-end"] = align.vertical === "bottom" && align.horizontal === "end", _a2), className);
  }, [
    size,
    fillMode,
    themeColor,
    rounded,
    cutoutBorder,
    align,
    position,
    className
  ]);
  return React.createElement("span", { className: badgeClasses, style, dir }, children);
});
Badge.propTypes = {
  className: PropTypes.string,
  dir: PropTypes.string,
  style: PropTypes.object,
  align: PropTypes.shape({
    vertical: PropTypes.oneOf(["top", "bottom"]),
    horizontal: PropTypes.oneOf(["start", "end"])
  }),
  size: PropTypes.oneOf([null, "small", "medium", "large"]),
  fillMode: PropTypes.oneOf([null, "solid", "outline"]),
  fill: PropTypes.oneOf([null, "solid", "outline"]),
  themeColor: PropTypes.oneOf([
    null,
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "warning",
    "error",
    "dark",
    "light",
    "inverse",
    "inherit"
  ]),
  shape: PropTypes.oneOf(["circle", "rectangle", "rounded", "dot", "pill"]),
  rounded: PropTypes.oneOf([null, "small", "medium", "large", "full"]),
  position: PropTypes.oneOf(["edge", "outside", "inside"]),
  cutoutBorder: PropTypes.bool
};
var defaultProps = {
  size: "medium",
  fillMode: "solid",
  themeColor: "primary",
  position: "edge",
  align: { vertical: "top", horizontal: "end" },
  cutoutBorder: false
};
Badge.defaultProps = defaultProps;
Badge.displayName = "KendoBadge";

// node_modules/@progress/kendo-react-indicators/dist/es/badge/BadgeContainer.js
var React2 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var BadgeContainer = React2.forwardRef(function(props, target) {
  var children = props.children, className = props.className, style = props.style;
  var elementRef = React2.useRef(null);
  var focusElement = React2.useCallback(function() {
    if (elementRef.current) {
      elementRef.current.focus();
    }
  }, []);
  React2.useImperativeHandle(target, function() {
    return {
      element: elementRef.current,
      focus: focusElement
    };
  });
  var dir = useDir(elementRef, props.dir);
  var containerClasses = React2.useMemo(function() {
    return classNames("k-badge-container", className);
  }, [className]);
  var containerStyles = React2.useMemo(function() {
    return __assign({ display: "inline-block" }, style);
  }, [style]);
  return React2.createElement("span", { className: containerClasses, style: containerStyles, dir }, children);
});
BadgeContainer.propTypes = {
  className: PropTypes2.string,
  dir: PropTypes2.string,
  style: PropTypes2.object
};
BadgeContainer.displayName = "KendoBadgeContainer";

// node_modules/@progress/kendo-react-indicators/dist/es/loader/Loader.js
var React3 = __toESM(require_react());
var PropTypes3 = __toESM(require_prop_types());
var SEGMENT_COUNT = {
  "pulsing": 2,
  "infinite-spinner": 3,
  "converging-spinner": 4
};
var TYPE_CLASSES = {
  "pulsing": "k-loader-pulsing-2",
  "infinite-spinner": "k-loader-spinner-3",
  "converging-spinner": "k-loader-spinner-4"
};
var Loader = React3.forwardRef(function(props, target) {
  validatePackage(packageMetadata);
  var className = props.className, style = props.style;
  var elementRef = React3.useRef(null);
  var focusElement = React3.useCallback(function() {
    if (elementRef.current) {
      elementRef.current.focus();
    }
  }, []);
  React3.useImperativeHandle(target, function() {
    return {
      element: elementRef.current,
      focus: focusElement
    };
  });
  var size = React3.useMemo(function() {
    return props.size || defaultProps2.size;
  }, [props.size]);
  var themeColor = React3.useMemo(function() {
    return props.themeColor || defaultProps2.themeColor;
  }, [props.themeColor]);
  var type = React3.useMemo(function() {
    return props.type || defaultProps2.type;
  }, [props.type]);
  var LoaderClasses = React3.useMemo(function() {
    return classNames("k-loader", {
      "k-loader-sm": size === "small",
      "k-loader-md": size === "medium",
      "k-loader-lg": size === "large",
      "k-loader-primary": themeColor === "primary",
      "k-loader-secondary": themeColor === "secondary",
      "k-loader-tertiary": themeColor === "tertiary",
      "k-loader-info": themeColor === "info",
      "k-loader-success": themeColor === "success",
      "k-loader-warning": themeColor === "warning",
      "k-loader-error": themeColor === "error",
      "k-loader-dark": themeColor === "dark",
      "k-loader-light": themeColor === "light",
      "k-loader-inverse": themeColor === "inverse"
    }, className, TYPE_CLASSES[type]);
  }, [
    size,
    themeColor,
    className,
    type
  ]);
  var spans = new Array(SEGMENT_COUNT[type]);
  spans.fill(0, 0, SEGMENT_COUNT[type]);
  return React3.createElement(
    "div",
    { className: LoaderClasses, style },
    React3.createElement("div", { className: "k-loader-canvas" }, spans.map(function(_, i) {
      return React3.createElement("span", { key: i, className: "k-loader-segment" });
    }))
  );
});
Loader.propTypes = {
  className: PropTypes3.string,
  style: PropTypes3.object,
  type: PropTypes3.oneOf([
    "pulsing",
    "infinite-spinner",
    "converging-spinner"
  ]),
  size: PropTypes3.oneOf(["small", "medium", "large"]),
  themeColor: PropTypes3.oneOf([
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "warning",
    "error",
    "dark",
    "light",
    "inverse"
  ])
};
var defaultProps2 = {
  size: "medium",
  themeColor: "primary",
  type: "pulsing"
};
Loader.defaultProps = defaultProps2;
Loader.displayName = "KendoLoader";

// node_modules/@progress/kendo-react-indicators/dist/es/skeleton/Skeleton.js
var React4 = __toESM(require_react());
var PropTypes4 = __toESM(require_prop_types());
var Skeleton = React4.forwardRef(function(props, target) {
  validatePackage(packageMetadata);
  var className = props.className, style = props.style;
  var elementRef = React4.useRef(null);
  var focusElement = React4.useCallback(function() {
    if (elementRef.current) {
      elementRef.current.focus();
    }
  }, []);
  React4.useImperativeHandle(target, function() {
    return {
      element: elementRef.current,
      focus: focusElement
    };
  });
  var shape3 = React4.useMemo(function() {
    return props.shape || defaultProps3.shape;
  }, [props.shape]);
  var animation = React4.useMemo(function() {
    if (props.animation === false) {
      return false;
    } else {
      return props.animation || defaultProps3.animation;
    }
  }, [props.animation]);
  var skeletonClasses = React4.useMemo(function() {
    return classNames("k-skeleton", {
      "k-skeleton-circle": shape3 === "circle",
      "k-skeleton-rectangle": shape3 === "rectangle",
      "k-skeleton-text": shape3 === "text",
      "k-skeleton-pulse": typeof animation === "object" && animation.type === "pulse",
      "k-skeleton-wave": typeof animation === "object" && animation.type === "wave" || animation === true
    }, className);
  }, [shape3, animation, className]);
  return React4.createElement("span", { ref: elementRef, className: skeletonClasses, style });
});
Skeleton.propTypes = {
  className: PropTypes4.string,
  style: PropTypes4.object,
  animation: PropTypes4.shape({
    type: PropTypes4.oneOf(["wave", "pulse"])
  }),
  shape: PropTypes4.oneOf(["circle", "rectangle", "text"])
};
var defaultProps3 = {
  shape: "text",
  animation: { type: "pulse" }
};
Skeleton.defaultProps = defaultProps3;
Skeleton.displayName = "KendoSkeleton";
export {
  Badge,
  BadgeContainer,
  Loader,
  Skeleton
};
//# sourceMappingURL=@progress_kendo-react-indicators.js.map
