import {
  require_prop_types
} from "./chunk-O6GWARG4.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __export,
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/@progress/kendo-react-common/dist/es/contexts/ZIndexContext.js
var React = __toESM(require_react());
var ZIndexContext = React.createContext(0);
var useZIndexContext = function() {
  return React.useContext(ZIndexContext);
};
ZIndexContext.displayName = "KendoReactZIndexContext";

// node_modules/@progress/kendo-react-common/dist/es/browser-support.service.js
var getDocument = function() {
  return typeof document !== "undefined" ? document : {};
};
var BrowserSupportService = (
  /** @class */
  function() {
    function BrowserSupportService2() {
      this.scrollbar = 0;
    }
    Object.defineProperty(BrowserSupportService2.prototype, "scrollbarWidth", {
      get: function() {
        var document2 = getDocument();
        if (!this.scrollbar && document2 && document2.createElement) {
          var div = document2.createElement("div");
          div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
          div.innerHTML = "&nbsp;";
          document2.body.appendChild(div);
          this.scrollbar = div.offsetWidth - div.scrollWidth;
          document2.body.removeChild(div);
        }
        return this.scrollbar;
      },
      enumerable: false,
      configurable: true
    });
    return BrowserSupportService2;
  }()
);

// node_modules/@progress/kendo-react-common/dist/es/canUseDOM.js
var canUseDOM = Boolean(
  // from fbjs
  typeof window !== "undefined" && window.document && window.document.createElement
);

// node_modules/@progress/kendo-react-common/dist/es/canUseRef.js
var isClassComponent = function(Component) {
  return Boolean(typeof Component === "function" && !!Component.prototype.isReactComponent);
};
var isForwardRef = function(Component) {
  return Boolean(Component.$$typeof && typeof Component.render === "function");
};
var canUseRef = function(Component) {
  return typeof Comment !== "string" && (isClassComponent(Component) || isForwardRef(Component));
};

// node_modules/@progress/kendo-react-common/dist/es/classNames.js
var classNames = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = {};
  var addLeafKeys = function(arg) {
    return typeof arg === "object" ? Object.keys(arg).forEach(function(key) {
      result[key] = arg[key];
    }) : result[arg] = true;
  };
  ;
  var addKeys = function(list) {
    return list.filter(function(arg) {
      return arg !== true && !!arg;
    }).map(function(arg) {
      return Array.isArray(arg) ? addKeys(arg) : addLeafKeys(arg);
    });
  };
  ;
  addKeys(args);
  return Object.keys(result).map(function(key) {
    return result[key] && key || null;
  }).filter(function(el) {
    return el !== null;
  }).join(" ");
};

// node_modules/@progress/kendo-react-common/dist/es/clone.js
var React2 = __toESM(require_react());
var cloneDate = function(date) {
  return date ? new Date(date.getTime()) : null;
};
function clone(obj) {
  var result = {};
  cloneObject(obj, result);
  return result;
}
function cloneObject(obj, result) {
  for (var field in obj) {
    if (obj.hasOwnProperty(field)) {
      var value = obj[field];
      result[field] = cloneValue(value, result[field]);
    }
  }
}
function cloneValue(value, nextValue) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  } else if (value instanceof Date) {
    return cloneDate(value);
  } else if (React2.isValidElement(value)) {
    return React2.cloneElement(value, value.props);
  } else if (value && typeof value === "object") {
    var newNextValue = nextValue || {};
    cloneObject(value, newNextValue);
    return newNextValue;
  } else {
    return value;
  }
}
function cloneArray(array) {
  return array.map(function(value) {
    return cloneValue(value, void 0);
  });
}

// node_modules/@progress/kendo-react-common/dist/es/focus.js
var focusFirstFocusableChild = function(target) {
  if (target) {
    if ((target instanceof HTMLInputElement || target.tabIndex !== -1) && target.focus) {
      target.focus();
      return;
    }
    var element = target.querySelector('input, [tabindex]:not([tabindex="-1"])');
    if (element && element.focus) {
      element.focus();
    }
  }
};

// node_modules/@progress/kendo-react-common/dist/es/FormComponent.js
var FormComponent = (
  /** @class */
  function() {
    function FormComponent2() {
    }
    return FormComponent2;
  }()
);

// node_modules/@progress/kendo-react-common/dist/es/getTabIndex.js
var DISABLED_TABINDEX = -1;
var DEFAULT_TABINDEX = 0;
var getTabIndex = function(tabIndex, disabled, useDefaultTabIndexWhenDisabled) {
  var parsedTabIndex = typeof tabIndex === "string" ? parseInt(tabIndex, void 0) : tabIndex;
  if (parsedTabIndex === NaN) {
    return void 0;
  }
  return parsedTabIndex !== void 0 ? parsedTabIndex : disabled ? useDefaultTabIndexWhenDisabled ? void 0 : DISABLED_TABINDEX : DEFAULT_TABINDEX;
};

// node_modules/@progress/kendo-react-common/dist/es/constants/index.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;

// node_modules/@progress/kendo-react-common/dist/es/fieldList.js
function fieldList(field) {
  var fields = [];
  field.replace(FIELD_REGEX, function(_match, index, indexAccessor, fieldName) {
    fields.push(index !== void 0 ? index : indexAccessor || fieldName);
  });
  return fields;
}

// node_modules/@progress/kendo-react-common/dist/es/getter.js
var getterCache = {};
getterCache.undefined = function() {
  return void 0;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = fieldList(field);
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-react-common/dist/es/guid.js
var guid = function() {
  var id = "";
  var i;
  var random;
  for (i = 0; i < 32; i++) {
    random = Math.random() * 16 | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) {
      id += "-";
    }
    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id;
};

// node_modules/@progress/kendo-react-common/dist/es/keys.js
var Keys = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  esc: 27,
  space: 32,
  pageUp: 33,
  pageDown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  delete: 46
};

// node_modules/@progress/kendo-react-common/dist/es/noop.js
var noop = function() {
};

// node_modules/@progress/kendo-react-common/dist/es/scrollbarWidth.js
var getScrollbarWidth = function() {
  if (!canUseDOM || !document.body) {
    return false;
  }
  var scrollbarWidth = new BrowserSupportService().scrollbarWidth;
  return scrollbarWidth;
};
var setScrollbarWidth = function() {
  if (!canUseDOM || !document.body) {
    return false;
  }
  var scrollbarWidth = new BrowserSupportService().scrollbarWidth;
  document.body.style.setProperty("--kendo-scrollbar-width", "".concat(scrollbarWidth, "px"));
};

// node_modules/@progress/kendo-react-common/dist/es/setter.js
var setterCache = {};
setterCache.undefined = function(obj) {
  return obj;
};
var defaultValue = function(nextField, options) {
  return options && options.arrays && !isNaN(Number(nextField)) ? [] : {};
};
function setter(field) {
  if (setterCache[field]) {
    return setterCache[field];
  }
  var fields = fieldList(field);
  setterCache[field] = function(obj, value, options) {
    var root = obj;
    var depth = fields.length - 1;
    for (var idx = 0; idx < depth && root; idx++) {
      root = root[fields[idx]] = root[fields[idx]] || defaultValue(fields[idx + 1], options);
    }
    root[fields[depth]] = value;
  };
  return setterCache[field];
}

// node_modules/@progress/kendo-react-common/dist/es/treeDataOperations.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function children(item, subItemsField, subItems) {
  var _a;
  if (subItems) {
    return __assign(__assign({}, item), (_a = {}, _a[subItemsField] = subItems.length ? __spreadArray([], subItems, true) : void 0, _a));
  } else {
    return item && item[subItemsField] ? __spreadArray([], item[subItemsField], true) : [];
  }
}
function mapItem(dataItem, subItemsField, callbackfn) {
  if (dataItem[subItemsField]) {
    var subItems = children(dataItem, subItemsField).map(function(child) {
      return mapItem(child, subItemsField, callbackfn);
    });
    return callbackfn(children(dataItem, subItemsField, subItems));
  }
  return callbackfn(dataItem);
}
var mapTree = function(tree, subItemsField, callback) {
  return __spreadArray([], tree.map(function(item) {
    return mapItem(item, subItemsField, callback);
  }), true);
};
var mapTreeItem = function(tree, level, subItemsField, callback) {
  var curData = tree;
  var parentNodes = [];
  for (var i = 0; i < level.length; i++) {
    curData = curData[level[i]];
    curData = Array.isArray(curData) ? curData : curData[subItemsField];
    parentNodes.push(curData);
  }
  var parent = parentNodes.length > 1 ? parentNodes[parentNodes.length - 2] : tree;
  var newItemIndex = level[level.length - 1];
  var newItem = callback(parent[newItemIndex]);
  parent.splice(newItemIndex, 1, newItem);
};
var extendDataItem = function(item, subItemsField, propsToExtend) {
  var _a;
  return Object.assign({}, item, item[subItemsField] ? (_a = {}, _a[subItemsField] = item[subItemsField].slice(), _a) : {}, propsToExtend || {});
};
var getItemPath = function(tree, level, subItemsField) {
  var nodes = [];
  var itemLevel = __spreadArray([], level, true);
  if (itemLevel.length) {
    var element = tree[itemLevel.shift() || 0];
    nodes.push(element);
    while (itemLevel.length && subItemsField) {
      element = element[subItemsField][itemLevel.shift() || 0];
      nodes.push(element);
    }
  }
  return nodes;
};

// node_modules/@progress/kendo-licensing/dist/index-esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  setScriptKey: () => setScriptKey,
  validatePackage: () => validatePackage
});
var _0x3f5f = ["tMjXqw8=", "ALvUuLu=", "DMvYC2LVBG==", "B2jQzwn0", "zNvUy3rPB24=", "AgfZ", "CgfYC2u=", "se52y2S=", "CeTOB0C=", "Ag9dwha=", "ChjVzhvJDe5HBwu=", "y29Kzq==", "BgDyrK4=", "zgf0yq==", "DgLTzxn0yw1W", "vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=", "vevpChm=", "CgfJA2fNzu5HBwu=", "C2v0", "CNzVquK=", "DhLWzq==", "rK9ht3q=", "A29lt3C=", "C2nYAxb0s2v5", "D2fYBG==", "lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==", "tM8GBgLJzw5ZzsbMB3vUzc4k", "Dw5KzwzPBMvK", "zxHWAxj5rgf0zq==", "qxPWD00=", "DwD0D1a=", "ww91CIbSAwnLBNnLigv4CgLYzwqGB24G", "BgvUz3rO", "zeDetM8=", "rgTIvfi=", "zg9JC1vYBa==", "ChjVzhvJDenVzgvZ", "Dg9mB2nHBgvtDhjPBMC=", "q3jhuhy=", "D0f4tMu=", "q09jChO=", "z2v0", "BgLJzw5Zzuv4CgLYyxrPB25eyxrL", "BuTXu3e=", "ChjVzhvJDhm=", "DfrNreS=", "C29YDa==", "zMLUza==", "u2vLia==", "u2XdEfO=", "uhjVz3jLC3mG", "z3jVDxa=", "BMfTzq==", "CejABNy=", "BgLJzw5ZAw5Nrg9JC1vYBa==", "igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=", "y29Uy2f0", "ChvIBgLZAerHDgu=", "z3jVDxbfBMq=", "CK1fru8=", "uwzXvuK=", "tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG"];
(function(_0x3ffcd8, _0x3f5fc6) {
  var _0x4fe1c2 = function(_0x228463) {
    while (--_0x228463) {
      _0x3ffcd8["push"](_0x3ffcd8["shift"]());
    }
  };
  _0x4fe1c2(++_0x3f5fc6);
})(_0x3f5f, 369);
var _0x4fe1 = function(_0x3ffcd8, _0x3f5fc6) {
  _0x3ffcd8 = _0x3ffcd8 - 0;
  var _0x4fe1c2 = _0x3f5f[_0x3ffcd8];
  if (_0x4fe1["rlqmyH"] === void 0) {
    var _0x228463 = function(_0x31bd4d) {
      var _0x1ae84e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=", _0x18c0a1 = String(_0x31bd4d)["replace"](/=+$/, "");
      var _0x34f60f = "";
      for (var _0x2f90c2 = 0, _0x1e97d4, _0x3ffa722, _0x161b802 = 0; _0x3ffa722 = _0x18c0a1["charAt"](_0x161b802++); ~_0x3ffa722 && (_0x1e97d4 = _0x2f90c2 % 4 ? _0x1e97d4 * 64 + _0x3ffa722 : _0x3ffa722, _0x2f90c2++ % 4) ? _0x34f60f += String["fromCharCode"](255 & _0x1e97d4 >> (-2 * _0x2f90c2 & 6)) : 0) {
        _0x3ffa722 = _0x1ae84e["indexOf"](_0x3ffa722);
      }
      return _0x34f60f;
    };
    _0x4fe1["tDWcmv"] = function(_0x54b76b) {
      var _0x446133 = _0x228463(_0x54b76b);
      var _0x286684 = [];
      for (var _0x34c59d2 = 0, _0x3b51a62 = _0x446133["length"]; _0x34c59d2 < _0x3b51a62; _0x34c59d2++) {
        _0x286684 += "%" + ("00" + _0x446133["charCodeAt"](_0x34c59d2)["toString"](16))["slice"](-2);
      }
      return decodeURIComponent(_0x286684);
    }, _0x4fe1["GoSChA"] = {}, _0x4fe1["rlqmyH"] = !![];
  }
  var _0x2bf482 = _0x4fe1["GoSChA"][_0x3ffcd8];
  return _0x2bf482 === void 0 ? (_0x4fe1c2 = _0x4fe1["tDWcmv"](_0x4fe1c2), _0x4fe1["GoSChA"][_0x3ffcd8] = _0x4fe1c2) : _0x4fe1c2 = _0x2bf482, _0x4fe1c2;
};
var context = { data: "  {}  " };
var cache = /* @__PURE__ */ new Map();
function setScriptKey(_0x332c3f) {
}
function validatePackage(_0x288448) {
  if (cache[_0x4fe1("0x8")](_0x288448[_0x4fe1("0x37")])) {
    if (_0x4fe1("0x19") === _0x4fe1("0x19"))
      return cache[_0x4fe1("0x2c")](_0x288448[_0x4fe1("0x37")]);
    else {
      let _0x1d633f = function() {
        _0x47c5ba = { "type": 1, "packageName": _0x404fc4, "docsUrl": _0x35fad0[_0x4fe1("0x39")] };
      };
    }
  }
  var _0x1dbcb5 = _0x288448[_0x4fe1("0x5")] ? " v" + _0x288448[_0x4fe1("0x5")] : "", _0x36c009 = _0x288448[_0x4fe1("0x37")] + _0x1dbcb5, _0x41f400 = JSON[_0x4fe1("0x9")](context[_0x4fe1("0x10")]), _0x3fe82f = !_0x41f400[_0x4fe1("0x1a")] && !_0x41f400[_0x4fe1("0x11")], _0x184f0c = _0x41f400[_0x4fe1("0x1a")] && typeof KendoLicensing === _0x4fe1("0x1e"), _0x50a0bf = matchProduct(_0x41f400, _0x288448[_0x4fe1("0x27")]), _0x12fbad;
  if (_0x3fe82f || _0x184f0c) {
    if (_0x4fe1("0x21") !== _0x4fe1("0x13"))
      _0x12fbad = { "type": 0, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
    else {
      let _0x10e197 = function() {
        _0x26dcf1 = { "type": 2, "packageName": _0x4a8fb8, "publishDate": _0x394bc9(_0x20a329[_0x4fe1("0x3c")]), "expiryDate": _0x2076a8(_0x4c8acd[_0x4fe1("0x2d")]), "docsUrl": _0x2c90b5[_0x4fe1("0x39")] };
      };
    }
  } else {
    if (_0x4fe1("0x38") !== _0x4fe1("0x0")) {
      if (!_0x50a0bf) {
        if (_0x4fe1("0xf") !== _0x4fe1("0xf")) {
          let _0x40dac7 = function() {
            return _0x2b7e21[_0x4fe1("0x2d")] - _0x283ffd[_0x4fe1("0x2d")];
          };
        } else
          _0x12fbad = { "type": 1, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
      } else {
        if (_0x4fe1("0x34") !== _0x4fe1("0x34")) {
          let _0x335a37 = function() {
            _0x451252 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5b4393[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x427d68[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
          };
        } else {
          if (_0x50a0bf[_0x4fe1("0x2d")] < _0x288448[_0x4fe1("0x3c")]) {
            if (_0x4fe1("0x25") !== _0x4fe1("0xc"))
              _0x12fbad = { "type": 2, "packageName": _0x36c009, "publishDate": parseDate(_0x288448[_0x4fe1("0x3c")]), "expiryDate": parseDate(_0x50a0bf[_0x4fe1("0x2d")]), "docsUrl": _0x288448[_0x4fe1("0x39")] };
            else {
              let _0x5258b7 = function() {
                _0x1bdee6[_0x4fe1("0x36")](_0x1b76ca);
              };
            }
          }
        }
      }
    } else {
      let _0x280f77 = function() {
        _0x38b037[_0x4fe1("0x2d")] < _0x617673[_0x4fe1("0x3c")] && (_0x189610 = { "type": 2, "packageName": _0x44ed7b, "publishDate": _0x54a628(_0x577a38[_0x4fe1("0x3c")]), "expiryDate": _0x16dcb4(_0x23f6ce[_0x4fe1("0x2d")]), "docsUrl": _0x429372[_0x4fe1("0x39")] });
      };
    }
  }
  if (_0x12fbad && typeof console === _0x4fe1("0x6")) {
    if (_0x4fe1("0x20") !== _0x4fe1("0x20")) {
      let _0x5d228a = function() {
        var _0x4230b5 = _0x103455[_0x4fe1("0x2f")];
        if (!_0x4230b5 || !_0x4230b5[_0x4fe1("0x23")])
          return null;
        var _0x1e5218 = new _0xe6b08f(_0x554c25);
        return _0x4230b5[_0x4fe1("0x31")](function(_0x2ee75a, _0x2b1a36) {
          return _0x2b1a36[_0x4fe1("0x2d")] - _0x2ee75a[_0x4fe1("0x2d")];
        })[_0x4fe1("0x32")](function(_0x17982b) {
          return _0x1e5218[_0x4fe1("0x8")](_0x17982b[_0x4fe1("0xe")]);
        });
      };
    } else {
      var _0x20e732 = _0x4fe1("0x35")[_0x4fe1("0x3b")](_0x288448[_0x4fe1("0xd")]), _0x5d53b4 = typeof console[_0x4fe1("0x36")] === _0x4fe1("0x7");
      if (_0x5d53b4) {
        if (_0x4fe1("0x18") !== _0x4fe1("0x24"))
          console[_0x4fe1("0x36")](_0x20e732);
        else {
          let _0x8fc6c0 = function() {
            var _0x333192 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x532507[_0x4fe1("0x14")], "\n");
            if (_0x2d53ef[_0x4fe1("0x17")] === 2)
              _0x333192 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x4ebbe6[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x4c2c15[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
            else {
              if (_0x6a6452[_0x4fe1("0x17")] === 0)
                _0x333192 += _0x4fe1("0x1d");
              else
                _0x1b6fe2[_0x4fe1("0x17")] === 1 && (_0x333192 += _0x4fe1("0x12"));
            }
            return _0x333192 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x585a35[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x333192;
          };
        }
      } else {
        if (_0x4fe1("0x4") === _0x4fe1("0x4"))
          console[_0x4fe1("0x1b")](_0x20e732);
        else {
          let _0x32c891 = function() {
            return new _0x5c247c(_0x332fe8 * 1e3);
          };
        }
      }
      console[_0x4fe1("0x1b")](formatError(_0x12fbad));
      if (_0x5d53b4) {
        if (_0x4fe1("0x2b") === _0x4fe1("0x2b"))
          console[_0x4fe1("0x3d")]();
        else {
          let _0x145e8c = function() {
            return _0x2a692e[_0x4fe1("0x8")](_0x32480f[_0x4fe1("0xe")]);
          };
        }
      }
    }
  }
  var _0x3f9e87 = !_0x12fbad;
  return cache[_0x4fe1("0x15")](_0x288448[_0x4fe1("0x37")], _0x3f9e87), _0x3f9e87;
}
function formatError(_0x5996d0) {
  var _0x369fe1 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x14")], "\n");
  if (_0x5996d0[_0x4fe1("0x17")] === 2) {
    if (_0x4fe1("0xb") !== _0x4fe1("0xb")) {
      let _0x42b4e8 = function() {
        _0x57e852 += _0x4fe1("0x12");
      };
    } else
      _0x369fe1 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
  } else {
    if (_0x5996d0[_0x4fe1("0x17")] === 0) {
      if (_0x4fe1("0x2e") !== _0x4fe1("0x2e")) {
        let _0x170217 = function() {
          return null;
        };
      } else
        _0x369fe1 += _0x4fe1("0x1d");
    } else {
      if (_0x5996d0[_0x4fe1("0x17")] === 1) {
        if (_0x4fe1("0x2a") === _0x4fe1("0x2a"))
          _0x369fe1 += _0x4fe1("0x12");
        else {
          let _0x589fb9 = function() {
            return _0x3ffa72[_0x4fe1("0x2c")](_0x161b80[_0x4fe1("0x37")]);
          };
        }
      }
    }
  }
  return _0x369fe1 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x369fe1;
}
function matchProduct(_0x2fe56c, _0x1db63e) {
  var _0x48173a = _0x2fe56c[_0x4fe1("0x2f")];
  if (!_0x48173a || !_0x48173a[_0x4fe1("0x23")]) {
    if (_0x4fe1("0x29") !== _0x4fe1("0x16"))
      return null;
    else {
      let _0x5d3cfe = function() {
        _0x3e8f7b += _0x4fe1("0x1d");
      };
    }
  }
  var _0x1dd0f6 = new Set(_0x1db63e);
  return _0x48173a[_0x4fe1("0x31")](function(_0xd163b7, _0x23878c) {
    if (_0x4fe1("0x30") === _0x4fe1("0x3")) {
      let _0x134c08 = function() {
        !_0xbcc2ed ? _0xb3f5b6 = { "type": 1, "packageName": _0x495d13, "docsUrl": _0x4dead0[_0x4fe1("0x39")] } : _0xa8b7ca[_0x4fe1("0x2d")] < _0x177345[_0x4fe1("0x3c")] && (_0x2625da = { "type": 2, "packageName": _0x5e46dc, "publishDate": _0x10f6c5(_0x357f8a[_0x4fe1("0x3c")]), "expiryDate": _0x70483f(_0x32abbc[_0x4fe1("0x2d")]), "docsUrl": _0x4a4999[_0x4fe1("0x39")] });
      };
    } else
      return _0x23878c[_0x4fe1("0x2d")] - _0xd163b7[_0x4fe1("0x2d")];
  })[_0x4fe1("0x32")](function(_0x1d8f83) {
    if (_0x4fe1("0xa") === _0x4fe1("0x1")) {
      let _0x428ed6 = function() {
        _0x34c59d = { "type": 0, "packageName": _0x3b51a6, "docsUrl": _0x3d18c6[_0x4fe1("0x39")] };
      };
    } else
      return _0x1dd0f6[_0x4fe1("0x8")](_0x1d8f83[_0x4fe1("0xe")]);
  });
}
function parseDate(_0x9d6621) {
  return new Date(_0x9d6621 * 1e3);
}

// node_modules/@progress/kendo-react-common/dist/es/validate-package.js
function validatePackage2(packageMetadata) {
  if (typeof index_esm_exports !== "undefined") {
    validatePackage(packageMetadata);
  } else {
    var message = "License activation failed for ".concat(packageMetadata.name, "\n");
    message += "The @progress/kendo-licensing script is not loaded.\n";
    message += "See ".concat(packageMetadata.licensingDocsUrl, " for more information.\n");
    console.warn(message);
  }
}

// node_modules/@progress/kendo-react-common/dist/es/hasRelativeStackingContext.js
var hasRelativeStackingContext = function(elementSource) {
  if (!canUseDOM) {
    return false;
  }
  var currentDocument = elementSource ? elementSource.ownerDocument : document;
  if (!currentDocument || !currentDocument.body) {
    return false;
  }
  var top = 10;
  var parent = currentDocument.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  var child = currentDocument.createElement("div");
  child.appendChild(currentDocument.createTextNode("child"));
  child.style.position = "fixed";
  child.style.top = top + "px";
  parent.appendChild(child);
  currentDocument.body.appendChild(parent);
  var isDifferent = child.getBoundingClientRect().top !== top;
  currentDocument.body.removeChild(parent);
  return isDifferent;
};

// node_modules/@progress/kendo-react-common/dist/es/events/dispatchEvent.js
function dispatchEvent(eventHandler, dispatchedEvent, target, eventData) {
  if (eventHandler) {
    var eventBaseData = {
      syntheticEvent: dispatchedEvent,
      nativeEvent: dispatchedEvent.nativeEvent,
      target
    };
    eventHandler.call(void 0, Object.assign(eventBaseData, eventData));
  }
}

// node_modules/@progress/kendo-react-common/dist/es/hocs/AsyncFocusBlur.js
var React4 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useAsyncFocusBlur.js
var React3 = __toESM(require_react());
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function useAsyncFocusBlur(_a) {
  var onFocus = _a.onFocus, onBlur = _a.onBlur, onSyncFocus = _a.onSyncFocus, onSyncBlur = _a.onSyncBlur;
  var focused = React3.useRef(false);
  var tick = React3.useRef(0);
  var nextTick = React3.useCallback(function(f) {
    clearTimeout(tick.current);
    tick.current = window.setTimeout(function() {
      return f();
    });
  }, [tick]);
  var handleFocus = React3.useCallback(function() {
    var event = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      event[_i] = arguments[_i];
    }
    clearTimeout(tick.current);
    if (onSyncFocus) {
      onSyncFocus.call(void 0, event[0]);
    }
    if (focused.current) {
      return;
    }
    ;
    focused.current = true;
    if (onFocus) {
      onFocus.call.apply(onFocus, __spreadArray2([void 0], event, false));
    }
  }, [focused, onFocus, onSyncFocus]);
  var handleBlur = React3.useCallback(function() {
    var event = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      event[_i] = arguments[_i];
    }
    if (onSyncBlur) {
      onSyncBlur.call(void 0, event[0]);
    }
    nextTick(function() {
      if (!focused.current) {
        return;
      }
      if (onBlur) {
        focused.current = false;
        onBlur.call.apply(onBlur, __spreadArray2([void 0], event, false));
      }
    });
  }, [focused, nextTick, onBlur, onSyncBlur]);
  React3.useEffect(function() {
    return function() {
      clearTimeout(tick.current);
    };
  }, []);
  return {
    onFocus: handleFocus,
    onBlur: handleBlur
  };
}

// node_modules/@progress/kendo-react-common/dist/es/hocs/AsyncFocusBlur.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var AsyncFocusBlur = function(_a) {
  var children2 = _a.children, onFocus = _a.onFocus, onBlur = _a.onBlur, onSyncFocus = _a.onSyncFocus, onSyncBlur = _a.onSyncBlur;
  var args = useAsyncFocusBlur({ onFocus, onBlur, onSyncFocus, onSyncBlur });
  return React4.createElement(React4.Fragment, null, children2.call(void 0, __assign2({}, args)));
};

// node_modules/@progress/kendo-react-common/dist/es/hocs/withPropsContext.js
var React6 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/usePropsContext.js
var React5 = __toESM(require_react());
var usePropsContext = function(context2, props) {
  var contextPropsCallback = React5.useContext(context2);
  var contextProps = contextPropsCallback(props);
  return contextProps;
};

// node_modules/@progress/kendo-react-common/dist/es/hocs/withPropsContext.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var createPropsContext = function() {
  return React6.createContext(function(props) {
    return props;
  });
};
var withPropsContext = function(context2, Component) {
  return React6.forwardRef(function(props, ref) {
    var contextProps = usePropsContext(context2, props);
    return React6.createElement(Component, __assign3({}, contextProps, { ref }));
  });
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDir.js
var React7 = __toESM(require_react());
function useDir(elementRef, initialDir, args) {
  var _a = React7.useState(initialDir), dir = _a[0], setDir = _a[1];
  React7.useEffect(function() {
    if (!dir && window && elementRef.current) {
      var rtlCandidate = window.getComputedStyle(elementRef.current).direction;
      if (rtlCandidate) {
        setDir(rtlCandidate);
      }
    }
  }, args);
  return dir;
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useRtl.js
var React8 = __toESM(require_react());
function useRtl(elementRef, initialDir, args) {
  var _a = React8.useState(initialDir), dir = _a[0], setDir = _a[1];
  React8.useEffect(function() {
    if (!dir && window && elementRef.current) {
      var rtlCandidate = window.getComputedStyle(elementRef.current).direction;
      if (rtlCandidate) {
        setDir(rtlCandidate);
      }
    }
  }, args);
  return dir;
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useMouse.js
var React9 = __toESM(require_react());
var useMouse = function(props, target, extend) {
  if (extend === void 0) {
    extend = {};
  }
  var handleMouseDown = React9.useCallback(function(event) {
    if (extend.onMouseDown) {
      extend.onMouseDown.call(void 0, event);
    }
    if (props.onMouseDown) {
      props.onMouseDown.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseDown, props.onMouseDown, target]);
  var handleMouseUp = React9.useCallback(function(event) {
    if (extend.onMouseUp) {
      extend.onMouseUp.call(void 0, event);
    }
    if (props.onMouseUp) {
      props.onMouseUp.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseUp, props.onMouseUp, target]);
  var handleClick = React9.useCallback(function(event) {
    if (extend.onClick) {
      extend.onClick.call(void 0, event);
    }
    if (props.onClick) {
      props.onClick.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onClick, props.onClick, target]);
  var handleDoubleClick = React9.useCallback(function(event) {
    if (extend.onDoubleClick) {
      extend.onDoubleClick.call(void 0, event);
    }
    if (props.onDoubleClick) {
      props.onDoubleClick.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onDoubleClick, props.onDoubleClick, target]);
  var handleMouseEnter = React9.useCallback(function(event) {
    if (extend.onMouseEnter) {
      extend.onMouseEnter.call(void 0, event);
    }
    if (props.onMouseEnter) {
      props.onMouseEnter.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseEnter, props.onMouseEnter, target]);
  var handleMouseLeave = React9.useCallback(function(event) {
    if (extend.onMouseLeave) {
      extend.onMouseLeave.call(void 0, event);
    }
    if (props.onMouseLeave) {
      props.onMouseLeave.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseLeave, props.onMouseLeave, target]);
  var handelMouseMove = React9.useCallback(function(event) {
    if (extend.onMouseMove) {
      extend.onMouseMove.call(void 0, event);
    }
    if (props.onMouseMove) {
      props.onMouseMove.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseMove, props.onMouseMove, target]);
  var handleMouseOut = React9.useCallback(function(event) {
    if (extend.onMouseOut) {
      extend.onMouseOut.call(void 0, event);
    }
    if (props.onMouseOut) {
      props.onMouseOut.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseOut, props.onMouseOut, target]);
  var handleMouseOver = React9.useCallback(function(event) {
    if (extend.onMouseOver) {
      extend.onMouseOver.call(void 0, event);
    }
    if (props.onMouseOver) {
      props.onMouseOver.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend.onMouseOver, props.onMouseOver, target]);
  return {
    onClick: handleClick,
    onMouseUp: handleMouseUp,
    onMouseDown: handleMouseDown,
    onDoubleClick: handleDoubleClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onMouseMove: handelMouseMove,
    onMouseOut: handleMouseOut,
    onMouseOver: handleMouseOver
  };
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useCustomComponent.js
var useCustomComponent = function(comp) {
  return [comp, {}];
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useCollection.js
var React10 = __toESM(require_react());
var COLLECTION_ACTION;
(function(COLLECTION_ACTION2) {
  COLLECTION_ACTION2[COLLECTION_ACTION2["add"] = 0] = "add";
  COLLECTION_ACTION2[COLLECTION_ACTION2["remove"] = 1] = "remove";
})(COLLECTION_ACTION || (COLLECTION_ACTION = {}));
var useCollection = function(initial) {
  if (initial === void 0) {
    initial = [];
  }
  var collection = React10.useRef(initial);
  var handleCollectionAction = React10.useCallback(function(action) {
    switch (action.type) {
      case COLLECTION_ACTION.add:
        collection.current.push(action.item);
        break;
      case COLLECTION_ACTION.remove:
        var index = collection.current.indexOf(action.item);
        collection.current.splice(index, 1);
        break;
      default:
        break;
    }
  }, []);
  return [collection.current, handleCollectionAction];
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDocument.js
var React11 = __toESM(require_react());
var useDocument = function(ref) {
  var getElement = React11.useCallback(function() {
    return ref.current && ref.current.element ? ref.current.element : ref.current;
  }, [ref]);
  var getDocument3 = React11.useCallback(function() {
    var element = getElement();
    return element ? element.ownerDocument || document : document;
  }, [getElement]);
  return getDocument3;
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useWindow.js
var React12 = __toESM(require_react());
var useWindow = function(ref) {
  var getDocument3 = useDocument(ref);
  var getWindow2 = React12.useCallback(function() {
    var document2 = getDocument3();
    return document2 ? document2.defaultView || window : window;
  }, [getDocument3]);
  return getWindow2;
};

// node_modules/@progress/kendo-react-common/dist/es/icons/Icon.js
var React13 = __toESM(require_react());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-common/dist/es/icons/constants.js
var SIZE_CLASSES = {
  "default": "",
  "xsmall": "k-icon-xs",
  "small": "k-icon-sm",
  "medium": "k-icon-md",
  "large": "k-icon-lg",
  "xlarge": "k-icon-xl"
};

// node_modules/@progress/kendo-react-common/dist/es/icons/Icon.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var Icon = React13.forwardRef(function(props, ref) {
  var className = props.className, name = props.name, themeColor = props.themeColor, size = props.size, flip = props.flip, style = props.style, id = props.id, tabIndex = props.tabIndex, others = __rest(props, ["className", "name", "themeColor", "size", "flip", "style", "id", "tabIndex"]);
  var target = React13.useRef(null);
  var elementRef = React13.useRef(null);
  React13.useImperativeHandle(target, function() {
    return {
      element: elementRef.current
    };
  });
  React13.useImperativeHandle(ref, function() {
    return target.current;
  });
  var sizeProp = React13.useMemo(function() {
    return size || defaultProps.size;
  }, [size]);
  var flipProp = React13.useMemo(function() {
    return flip || defaultProps.flip;
  }, [flip]);
  var fontClassNames = React13.useMemo(function() {
    var _a;
    return classNames("k-icon", name && toIconClass(name), (_a = {}, _a["k-color-".concat(themeColor)] = themeColor, _a["k-flip-h"] = flipProp === "horizontal" || flipProp === "both", _a["k-flip-v"] = flipProp === "vertical" || flipProp === "both", _a), SIZE_CLASSES[sizeProp], className);
  }, [name, themeColor, sizeProp, flipProp, className]);
  var mouseProps = useMouse(props, target);
  return React13.createElement("span", __assign4({ ref: elementRef }, others, mouseProps, { className: fontClassNames, id, tabIndex, style, role: "presentation" }));
});
Icon.propTypes = {
  style: PropTypes.object,
  classNames: PropTypes.string,
  name: PropTypes.string,
  themeColor: PropTypes.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: PropTypes.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge"]),
  flip: PropTypes.oneOf(["default", "horizontal", "vertical", "both"])
};
var defaultProps = {
  size: "default",
  flip: "default"
};
Icon.displayName = "KendoIcon";

// node_modules/@progress/kendo-react-common/dist/es/icons/SvgIcon.js
var React14 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var SvgIcon = React14.forwardRef(function(props, ref) {
  var children2 = props.children, className = props.className, svgClassName = props.svgClassName, icon = props.icon, flip = props.flip, id = props.id, tabIndex = props.tabIndex, size = props.size, style = props.style, svgStyle = props.svgStyle, themeColor = props.themeColor, viewBox = props.viewBox, name = props.name, others = __rest2(props, ["children", "className", "svgClassName", "icon", "flip", "id", "tabIndex", "size", "style", "svgStyle", "themeColor", "viewBox", "name"]);
  var elementRef = React14.useRef(null);
  React14.useImperativeHandle(ref, function() {
    return {
      element: elementRef.current
    };
  });
  var iconNameProp = React14.useMemo(function() {
    return icon ? icon.name : defaultProps2.icon;
  }, [icon]);
  var sizeProp = React14.useMemo(function() {
    return size || defaultProps2.size;
  }, [size]);
  var flipProp = React14.useMemo(function() {
    return flip || defaultProps2.flip;
  }, [flip]);
  var viewBoxProp = React14.useMemo(function() {
    return viewBox || defaultProps2.viewBox;
  }, [viewBox]);
  var elementClassNames = React14.useMemo(function() {
    var _a;
    return classNames("k-svg-icon", "k-svg-i-" + iconNameProp, (_a = {}, _a["k-color-".concat(themeColor)] = themeColor, _a["k-flip-h"] = flipProp === "horizontal" || flipProp === "both", _a["k-flip-v"] = flipProp === "vertical" || flipProp === "both", _a), SIZE_CLASSES[sizeProp], className);
  }, [iconNameProp, themeColor, sizeProp, flipProp, className]);
  var elementStyle = React14.useMemo(function() {
    if (props.width && props.height) {
      return __assign5({ width: props.width, height: props.height }, style);
    } else if (props.width) {
      return __assign5({ width: props.width, height: props.width }, style);
    } else if (props.height) {
      return __assign5({ width: props.height, height: props.height }, style);
    } else {
      return __assign5({}, style);
    }
  }, [props.width, props.height, style]);
  return React14.createElement(
    "span",
    { className: elementClassNames, style: elementStyle, ref: elementRef },
    React14.createElement("svg", __assign5({ id, className: svgClassName, style: svgStyle, "aria-hidden": true, tabIndex, focusable: false, xmlns: "http://www.w3.org/2000/svg", viewBox: icon ? icon.viewBox : viewBoxProp, dangerouslySetInnerHTML: icon ? { __html: icon.content } : void 0 }, others), icon ? void 0 : children2)
  );
});
SvgIcon.propTypes = {
  style: PropTypes2.object,
  classNames: PropTypes2.string,
  children: PropTypes2.any,
  icon: PropTypes2.object,
  themeColor: PropTypes2.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: PropTypes2.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge"]),
  flip: PropTypes2.oneOf(["default", "horizontal", "vertical", "both"])
};
var defaultProps2 = {
  size: "default",
  flip: "default",
  icon: "",
  viewBox: "0 0 24 24"
};
SvgIcon.displayName = "KendoSvgIcon";

// node_modules/@progress/kendo-react-common/dist/es/icons/IconWrap.js
var React16 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/icons/IconsContext.js
var React15 = __toESM(require_react());
var IconsContext = React15.createContext({ type: "font" });
IconsContext.displayName = "KendoReactIconsContext";

// node_modules/@progress/kendo-react-common/dist/es/icons/IconWrap.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest3 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var IconWrap = React16.forwardRef(function(props, ref) {
  var _a;
  var _b = React16.useContext(IconsContext), type = _b.type, icons = _b.icons;
  var icon = props.icon, fontIconProps = __rest3(props, ["icon"]);
  var name = ((_a = props.icon) === null || _a === void 0 ? void 0 : _a.name) || props.name;
  var svg = name && icons && icons[name] && typeof icons[name] !== "string" ? icons[name] : icon;
  name = name && icons && icons[name] && typeof icons[name] === "string" ? icons[name] : name;
  return type === "svg" && svg ? React16.createElement(SvgIcon, __assign6({}, props, { icon: svg, ref })) : React16.createElement(Icon, __assign6({}, fontIconProps, { name, ref }));
});
IconWrap.displayName = "KendoIconWrap";

// node_modules/@progress/kendo-react-common/dist/es/icons/utils.js
var PropTypes3 = __toESM(require_prop_types());
var toIconName = function(iconClass) {
  return iconClass.replace(/^k-i-/, "");
};
var toIconClass = function(name) {
  return "k-i-" + name;
};
var svgIconPropType = PropTypes3.shape({
  name: PropTypes3.string.isRequired,
  content: PropTypes3.string.isRequired,
  viewBox: PropTypes3.string.isRequired
});

// node_modules/@progress/kendo-react-common/dist/es/typography/Typography.js
var React17 = __toESM(require_react());
var PropTypes4 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-common/dist/es/typography/constants.js
var FONT_SIZE_CLASSES = {
  "xsmall": "k-fs-xs",
  "small": "k-fs-sm",
  "medium": "k-fs-md",
  "large": "k-fs-lg",
  "xlarge": "k-fs-xl"
};
var FONT_WEIGHT_CLASSES = {
  "light": "k-font-weight-light",
  "normal": "k-font-weight-normal",
  "bold": "k-font-weight-bold"
};
var MARGIN_ENUM_CLASSES = {
  "xsmall": "k-m-xs",
  "small": "k-m-sm",
  "medium": "k-m-md",
  "large": "k-m-lg",
  "xlarge": "k-m-xl",
  "thin": "k-m-thin",
  "hair": "k-m-hair"
};
var MARGIN_ENUM_VALUES = {
  "xsmall": "xs",
  "small": "sm",
  "medium": "md",
  "large": "lg",
  "xlarge": "xl",
  "thin": "thin",
  "hair": "hair"
};
var MARGIN_SIDES_CLASSES = {
  "top": "k-mt-",
  "right": "k-mr-",
  "bottom": "k-mb-",
  "left": "k-ml-"
};
var TEXT_ALIGN_CLASSES = {
  "left": "k-text-left",
  "right": "k-text-right",
  "center": "k-text-center",
  "justify": "k-text-justify"
};
var TEXT_TRANSFORM_CLASSES = {
  "lowercase": "k-text-lowercase",
  "uppercase": "k-text-uppercase",
  "capitalize": "k-text-capitalize"
};
var THEME_COLOR_CLASSES = {
  "inherit": "k-color-inherit",
  "primary": "k-color-primary",
  "secondary": "k-color-secondary",
  "tertiary": "k-color-tertiary",
  "info": "k-color-info",
  "success": "k-color-success",
  "warning": "k-color-warning",
  "error": "k-color-error",
  "dark": "k-color-dark",
  "light": "k-color-light",
  "inverse": "k-color-inverse"
};

// node_modules/@progress/kendo-react-common/dist/es/typography/Typography.js
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest4 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var generateTypography = function(element) {
  var component = React17.forwardRef(function(props, ref) {
    var id = props.id, style = props.style, className = props.className, fontSize = props.fontSize, fontWeight = props.fontWeight, textAlign = props.textAlign, textTransform = props.textTransform, themeColor = props.themeColor, margin = props.margin, others = __rest4(props, ["id", "style", "className", "fontSize", "fontWeight", "textAlign", "textTransform", "themeColor", "margin"]);
    var target = React17.useRef(null);
    var elementRef = React17.useRef(null);
    React17.useImperativeHandle(target, function() {
      return {
        element: elementRef.current,
        props
      };
    });
    React17.useImperativeHandle(ref, function() {
      return target.current;
    });
    var defaultClass = function() {
      var classMap = element === "p" ? "paragraph" : element;
      return "k-".concat(classMap);
    };
    var Component = element;
    var setMarginClassPerSide = function(marginSide, value) {
      var val = typeof value === "string" ? MARGIN_ENUM_VALUES[value] : value;
      return "".concat(MARGIN_SIDES_CLASSES[marginSide]).concat(val);
    };
    var setMarginClasses = function() {
      if (margin === void 0) {
        return;
      }
      if (typeof margin === "string") {
        return [MARGIN_ENUM_CLASSES[margin]];
      }
      if (typeof margin === "number" && margin >= 0 && margin <= 24) {
        return ["k-m-".concat(margin)];
      }
      if (typeof margin === "object") {
        var marginClassesList_1 = [];
        Object.keys(margin).forEach(function(key) {
          if (margin[key] !== null && margin[key] !== void 0) {
            marginClassesList_1.push(setMarginClassPerSide(key, margin[key]));
          }
        });
        var classes = marginClassesList_1.join(" ");
        return classes;
      }
    };
    var setTypographyClasses = function() {
      var typographyArray = [
        defaultClass(),
        FONT_SIZE_CLASSES[fontSize],
        FONT_WEIGHT_CLASSES[fontWeight],
        TEXT_ALIGN_CLASSES[textAlign],
        TEXT_TRANSFORM_CLASSES[textTransform],
        THEME_COLOR_CLASSES[themeColor],
        setMarginClasses(),
        className
      ];
      var typographyClasses = typographyArray.filter(function(n) {
        return n !== void 0;
      }).join(" ");
      return typographyClasses;
    };
    return React17.createElement(Component, __assign7({ id, ref: elementRef, className: setTypographyClasses(), style }, others), props.children);
  });
  component.propTypes = {
    style: PropTypes4.object,
    className: PropTypes4.string,
    fontSize: PropTypes4.oneOf(["xsmall", "small", "medium", "large", "xlarge"]),
    fontWeight: PropTypes4.oneOf(["light", "normal", "bold"]),
    margin: PropTypes4.oneOfType([
      PropTypes4.number,
      PropTypes4.object,
      PropTypes4.oneOf(["xsmall", "small", "medium", "large", "xlarge", "thin", "hair"])
    ]),
    textAlign: PropTypes4.oneOf(["left", "right", "center", "justify"]),
    textTransform: PropTypes4.oneOf(["lowercase", "uppercase", "capitalize"]),
    themeColor: PropTypes4.oneOf([
      "inherit",
      "primary",
      "secondary",
      "tertiary",
      "info",
      "success",
      "error",
      "warning",
      "dark",
      "light",
      "inverse"
    ])
  };
  component.displayName = "KendoReactTypography".concat(element.toUpperCase());
  return component;
};
var h1 = generateTypography("h1");
var h2 = generateTypography("h2");
var h3 = generateTypography("h3");
var h4 = generateTypography("h4");
var h5 = generateTypography("h5");
var h6 = generateTypography("h6");
var p = generateTypography("p");
var code = generateTypography("code");
var pre = generateTypography("pre");
var Typography = {
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  p,
  code,
  pre
};

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/index.js
var React23 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDraggable.js
var React20 = __toESM(require_react());

// node_modules/@progress/kendo-draggable-common/dist/es/algorithms/intersect.js
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect = function(element, candidates) {
  var max = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};

// node_modules/@progress/kendo-draggable-common/dist/es/utils/index.js
var detectBrowser = function() {
  var ua = window && window.navigator.userAgent;
  if (!ua) {
    return false;
  }
  var browser = false;
  var match = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match = ua.match(browserRxs[agent]);
      if (match) {
        browser = {};
        browser[agent] = true;
        browser[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser.version = parseInt(document.DOCUMENT_NODE || match[2], 10);
        break;
      }
    }
  }
  return browser;
};
var getDocument2 = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow = function(element) {
  var document2 = getDocument2(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support = { browser: detectBrowser() };
  var document2 = getDocument2(element);
  return support.browser.edge || support.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el) {
  if (el && el.className && typeof el.className === "string" && el.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el) {
  var root = scrollableRoot(el);
  if (!el || el === document.body || el === document.documentElement) {
    return root;
  }
  var parent = el;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = { x: 0, y: 0 };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el, window2) {
  var root = scrollableRoot(el);
  if (el === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x, y, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y && rect.left <= x && y <= rect.bottom && x <= rect.right;
};

// node_modules/@progress/kendo-draggable-common/dist/es/drag-n-drop.js
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event) {
  return /^touch/.test(event.type);
};
var isScrollEvent = function(event) {
  return /^(scroll)/.test(event.type);
};
var normalizeEvent = function(event, state) {
  return isTouchEvent(event) ? {
    pageX: event.changedTouches[0].pageX,
    pageY: event.changedTouches[0].pageY,
    clientX: event.changedTouches[0].clientX,
    clientY: event.changedTouches[0].clientY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event) ? {
    pageX: state.pageOffset.x,
    pageY: state.pageOffset.y,
    clientX: state.clientOffset.x,
    clientY: state.clientOffset.y,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event.pageX,
    pageY: event.pageY,
    clientX: event.clientX,
    clientY: event.clientY,
    offsetX: event.offsetX,
    offsetY: event.offsetY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    type: event.type,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    originalEvent: event
  };
};
var noop2 = function() {
};
var dispatchDragAndDrop = function(state, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a = callbacks.onIsPressedChange, onIsPressedChange = _a === void 0 ? noop2 : _a, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop2 : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop2 : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop2 : _d, _e = callbacks.onPageOffsetChange, onPageOffsetChange = _e === void 0 ? noop2 : _e, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop2 : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop2 : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop2 : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state.autoScrollDirection;
  var overrideScrollableParent = state.scrollableParent;
  var event = normalizeEvent(action.event, state);
  switch (event.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && (event.originalEvent.which && event.originalEvent.which > 1) || state.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? { x: scrollableParent_1.scrollX, y: scrollableParent_1.scrollY } : { x: scrollableParent_1.scrollLeft, y: scrollableParent_1.scrollTop });
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      onOffsetChange({
        x: event.offsetX,
        y: event.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? { x: scrollableParent.scrollX, y: scrollableParent.scrollY } : { x: scrollableParent.scrollLeft, y: scrollableParent.scrollTop };
      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;
      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event.scrollX,
        y: event.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state.pressed) {
        if (state.autoScroll && event.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument2(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));
            var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state.drag && drag.onDragStart) {
          drag.onDragStart(event);
        }
        if (drag.onDrag) {
          drag.onDrag(event);
        }
        var dropElement_1 = intersect(hint || element, state.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d) {
          return d !== (hint || element);
        }));
        var drop = state.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state.drop && state.drop.element) !== dropElement_1) {
            if (state.drop && state.drop.onDragLeave) {
              state.drop.onDragLeave(event);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event);
            }
          }
        } else if (state.drop && state.drop.onDragLeave) {
          state.drop.onDragLeave(event);
        }
      }
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onRelease) {
        drag.onRelease(event);
      }
      if (state.drop && state.drop.onDrop) {
        state.drop.onDrop(event);
      }
      if (state.drag && drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      if (state.drop && state.drop.onDragLeave) {
        state.drop.onDragLeave(event);
      }
      break;
    }
    default:
      break;
  }
};

// node_modules/@progress/kendo-draggable-common/dist/es/auto-scroll.js
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useInheritedState.js
var React18 = __toESM(require_react());
var useInheritedState = function(context2, defaultValue2) {
  var _a = React18.useContext(context2), contextValue = _a[0], contextSetter = _a[1];
  var _b = React18.useState(defaultValue2), localValue = _b[0], localSetter = _b[1];
  var value = contextValue !== void 0 ? contextValue : localValue;
  var handleValueChange = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    contextValue !== void 0 ? contextSetter.apply(void 0, args) : localSetter(args[0]);
  };
  return [
    value,
    handleValueChange
  ];
};

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/context/index.js
var React19 = __toESM(require_react());
var DragContext = React19.createContext([
  void 0,
  noop
]);
var DropContext = React19.createContext([
  void 0,
  noop
]);
var DragsContext = React19.createContext([[], noop, noop]);
var DropsContext = React19.createContext([[], noop, noop]);

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDraggable.js
var IGNORE_MOUSE_TIMEOUT = 2e3;
function useDraggable(ref, callbacks, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = callbacks.onPress, onPress = _a === void 0 ? noop : _a, _b = callbacks.onRelease, onRelease = _b === void 0 ? noop : _b, _c = callbacks.onDragStart, onDragStart = _c === void 0 ? noop : _c, _d = callbacks.onDrag, onDrag = _d === void 0 ? noop : _d, _e = callbacks.onDragEnd, onDragEnd = _e === void 0 ? noop : _e;
  var _f = options.hint, hint = _f === void 0 ? null : _f, _g = options.mouseOnly, mouseOnly = _g === void 0 ? false : _g, _h = options.autoScroll, autoScroll2 = _h === void 0 ? true : _h, _j = options.scrollContainer, scrollContainer = _j === void 0 ? null : _j;
  var _k = React20.useState(false), pressed = _k[0], setPressed = _k[1];
  var _l = React20.useState(false), scrolling = _l[0], setScrolling = _l[1];
  var drop = useInheritedState(DropContext)[0];
  var _m = useInheritedState(DragContext), drag = _m[0], setDrag = _m[1];
  var drops = React20.useContext(DropsContext)[0];
  var _o = React20.useContext(DragsContext), drags = _o[0], registerDrag = _o[1], deregisterDrag = _o[2];
  var velocity = React20.useRef({ x: 0, y: 0 });
  var scrollInterval = React20.useRef();
  var ignoreMouse = React20.useRef(false);
  var restoreMouseTimeout = React20.useRef();
  var scrollable = React20.useRef(null);
  var unmount = React20.useRef(false);
  var offset = React20.useRef({ x: 0, y: 0 });
  var pageOffset = React20.useRef({ x: 0, y: 0 });
  var clientOffset = React20.useRef({ x: 0, y: 0 });
  var initialClientOffset = React20.useRef({ x: 0, y: 0 });
  var scrollOffset = React20.useRef({ x: 0, y: 0 });
  var initialScrollOffset = React20.useRef({ x: 0, y: 0 });
  var supportPointerEvent = Boolean(typeof window !== "undefined" && window.PointerEvent);
  var pointers = !mouseOnly && supportPointerEvent;
  var getElement = React20.useCallback(function() {
    return ref.current && ref.current.element ? ref.current.element : ref.current;
  }, [ref]);
  var getHintElement = React20.useCallback(function() {
    return hint && hint.current && hint.current.element ? hint.current.element : hint ? hint.current : null;
  }, [hint]);
  var getScrollContainer = React20.useCallback(function() {
    return scrollContainer && scrollContainer.current && scrollContainer.current.element ? scrollContainer.current.element : scrollContainer ? scrollContainer.current : null;
  }, [scrollContainer]);
  var getAutoScrollContainer = React20.useCallback(function() {
    return typeof autoScroll2 === "object" && autoScroll2.boundaryElementRef && autoScroll2.boundaryElementRef.current && autoScroll2.boundaryElementRef.current.element ? autoScroll2.boundaryElementRef.current.element : typeof autoScroll2 === "object" && autoScroll2.boundaryElementRef && autoScroll2.boundaryElementRef.current ? autoScroll2.boundaryElementRef.current : null;
  }, [autoScroll2]);
  var target = React20.useRef(null);
  React20.useImperativeHandle(target, function() {
    return {
      element: getElement(),
      hint: getHintElement(),
      onPress: handlePress,
      onDragStart: handleDragStart,
      onDrag: handleDrag,
      onDragEnd: handleDragEnd,
      onRelease: handleRelease,
      data: ref.current
    };
  });
  var getDocument3 = React20.useCallback(function() {
    var element = getElement();
    return element ? element.ownerDocument || document : document;
  }, [getElement]);
  var getWindow2 = React20.useCallback(function() {
    var document2 = getDocument3();
    return document2 ? document2.defaultView || window : window;
  }, [getDocument3]);
  var getState = React20.useCallback(function() {
    return {
      drag: drag ? drag.current : null,
      drop: drop ? drop.current : null,
      drags: drags.map(function(d) {
        return d.current;
      }),
      drops: drops.map(function(d) {
        return d.current;
      }),
      pressed,
      ignoreMouse: ignoreMouse.current,
      scrollOffset: scrollOffset.current,
      offset: offset.current,
      pageOffset: pageOffset.current,
      initialScrollOffset: initialScrollOffset.current,
      clientOffset: clientOffset.current,
      initialClientOffset: initialClientOffset.current,
      velocity: velocity.current,
      autoScroll: Boolean(typeof autoScroll2 === "object" ? autoScroll2.enabled !== false : autoScroll2),
      scrollableParent: getAutoScrollContainer(),
      autoScrollDirection: typeof autoScroll2 === "object" ? autoScroll2.direction : { horizontal: true, vertical: true },
      isScrolling: scrolling
    };
  }, [drag, drop, drags, drops, pressed, autoScroll2, getAutoScrollContainer, scrolling]);
  var handlePressedChange = React20.useCallback(function(value) {
    setPressed(value);
  }, []);
  var handleScrollingChange = React20.useCallback(function(value) {
    setScrolling(value);
  }, []);
  var handleVelocityChange = React20.useCallback(function(value) {
    velocity.current = value;
  }, []);
  var handleOffsetChange = React20.useCallback(function(value) {
    offset.current = value;
  }, []);
  var handleClientOffsetChange = React20.useCallback(function(value) {
    clientOffset.current = value;
  }, []);
  var handlePageOffsetChange = React20.useCallback(function(value) {
    pageOffset.current = value;
  }, []);
  var handleInitialClientOffsetChange = React20.useCallback(function(value) {
    initialClientOffset.current = value;
  }, []);
  var handleScrollOffsetChange = React20.useCallback(function(value) {
    scrollOffset.current = value;
  }, []);
  var handleInitialScrollOffsetChange = React20.useCallback(function(value) {
    initialScrollOffset.current = value;
  }, []);
  var handlePress = React20.useCallback(function(event) {
    onPress(event);
  }, [onPress]);
  var handleRelease = React20.useCallback(function(event) {
    onRelease(event);
  }, [onRelease]);
  var handleDragStart = React20.useCallback(function(event) {
    setDrag(target, { target: ref.current, event });
    onDragStart(event);
  }, [setDrag, ref, onDragStart]);
  var handleDrag = React20.useCallback(function(event) {
    onDrag(event);
  }, [onDrag]);
  var handleDragEnd = React20.useCallback(function(event) {
    if (unmount.current) {
      return;
    }
    setDrag(null, { target: ref.current, event });
    onDragEnd(event);
  }, [onDragEnd, setDrag, ref]);
  var dispatchDragEvent = React20.useCallback(function(event) {
    dispatchDragAndDrop(getState(), { event, payload: target.current }, {
      onVelocityChange: handleVelocityChange,
      onOffsetChange: handleOffsetChange,
      onClientOffsetChange: handleClientOffsetChange,
      onPageOffsetChange: handlePageOffsetChange,
      onInitialClientOffsetChange: handleInitialClientOffsetChange,
      onScrollOffsetChange: handleScrollOffsetChange,
      onInitialScrollOffsetChange: handleInitialScrollOffsetChange,
      onIsPressedChange: handlePressedChange,
      onIsScrollingChange: handleScrollingChange
    });
  }, [
    getState,
    handleVelocityChange,
    handleOffsetChange,
    handlePageOffsetChange,
    handleClientOffsetChange,
    handleInitialClientOffsetChange,
    handleInitialScrollOffsetChange,
    handlePressedChange,
    handleScrollOffsetChange,
    handleScrollingChange
  ]);
  var handlePointerDown = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerMove = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerCancel = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerUp = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseDown = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseMove = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseUp = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleContextMenu = React20.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchStart = React20.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchMove = React20.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchEnd = React20.useCallback(function(event) {
    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var currentWindow = getWindow2();
      ignoreMouse.current = true;
      restoreMouseTimeout.current = currentWindow.setTimeout(function() {
        ignoreMouse.current = false;
      }, IGNORE_MOUSE_TIMEOUT);
    }
    dispatchDragEvent(event);
  }, [dispatchDragEvent, getWindow2]);
  var handleScroll = React20.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var prerequisites = React20.useCallback(function() {
    var element = getElement();
    if (element) {
      var initialTouchAction_1 = element.style.touchAction;
      element.style.touchAction = "none";
      return function() {
        element.style.touchAction = initialTouchAction_1;
      };
    }
  }, [getElement]);
  var register = React20.useCallback(function() {
    registerDrag(target);
    return function() {
      deregisterDrag(target);
    };
  }, [deregisterDrag, registerDrag]);
  var init = function() {
    var window2 = getWindow2();
    var element = getElement();
    var document2 = getDocument3();
    if (pointers) {
      if (element) {
        scrollable.current = getScrollableParent(element);
        if (scrollable.current) {
          scrollable.current.addEventListener("scroll", handleScroll, { passive: true });
        }
        element.addEventListener("pointerdown", handlePointerDown, { passive: true });
      }
      if (pressed) {
        document2.addEventListener("pointermove", handlePointerMove);
        document2.addEventListener("pointerup", handlePointerUp, true);
        document2.addEventListener("contextmenu", handleContextMenu);
        document2.addEventListener("pointercancel", handlePointerCancel, { passive: true });
      }
    } else {
      window2.addEventListener("touchmove", noop, { capture: false, passive: false });
      if (element) {
        element.addEventListener("mousedown", handleMouseDown, { passive: true });
        if (!mouseOnly) {
          element.addEventListener("touchstart", handleTouchStart, { passive: true });
          if (pressed) {
            element.addEventListener("touchmove", handleTouchMove, { passive: true });
            element.addEventListener("touchend", handleTouchEnd, { passive: true });
          }
        }
      }
      if (pressed) {
        document2.addEventListener("mousemove", handleMouseMove, { passive: true });
        document2.addEventListener("mouseup", handleMouseUp, { passive: true });
      }
    }
    return function() {
      if (scrollable.current) {
        scrollable.current.removeEventListener("scroll", handleScroll);
      }
      if (element) {
        element.removeEventListener("pointerdown", handlePointerDown);
        element.removeEventListener("mousedown", handleMouseDown);
        element.removeEventListener("touchstart", handleTouchStart);
        element.removeEventListener("touchmove", handleTouchMove);
        element.removeEventListener("touchend", handleTouchEnd);
      }
      document2.removeEventListener("pointermove", handlePointerMove);
      document2.removeEventListener("pointerup", handlePointerUp, true);
      document2.removeEventListener("contextmenu", handleContextMenu);
      document2.removeEventListener("pointercancel", handlePointerCancel);
      document2.removeEventListener("mousemove", handleMouseMove);
      document2.removeEventListener("mouseup", handleMouseUp);
      window2.removeEventListener("touchmove", noop);
      window2.clearTimeout(restoreMouseTimeout.current);
    };
  };
  React20.useEffect(function() {
    var window2 = getWindow2();
    if (scrolling) {
      var scrollableParent_1 = getScrollContainer() || getScrollableParent(document.elementFromPoint(clientOffset.current.x, clientOffset.current.y));
      window2.clearInterval(scrollInterval.current);
      scrollInterval.current = window2.setInterval(function() {
        autoScroll(scrollableParent_1, { x: velocity.current.x, y: velocity.current.y });
      }, 50);
    }
    return function() {
      window2.clearInterval(scrollInterval.current);
    };
  }, [getElement, getScrollContainer, getWindow2, scrolling]);
  React20.useEffect(prerequisites, [prerequisites]);
  React20.useEffect(init, [
    pressed,
    getWindow2,
    getElement,
    getDocument3,
    mouseOnly,
    pointers,
    handleContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handlePointerCancel,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handleTouchEnd,
    handleTouchMove,
    handleTouchStart,
    handleScroll
  ]);
  React20.useEffect(function() {
    return function() {
      unmount.current = true;
    };
  }, []);
  React20.useLayoutEffect(register, [register]);
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDroppable.js
var React21 = __toESM(require_react());
function useDroppable(ref, callbacks) {
  if (callbacks === void 0) {
    callbacks = {
      onDragEnter: noop,
      onDragOver: noop,
      onDragLeave: noop,
      onDrop: noop
    };
  }
  var _a = callbacks.onDragEnter, onDragEnter = _a === void 0 ? noop : _a, _b = callbacks.onDragOver, onDragOver = _b === void 0 ? noop : _b, _c = callbacks.onDragLeave, onDragLeave = _c === void 0 ? noop : _c, _d = callbacks.onDrop, onDrop = _d === void 0 ? noop : _d;
  var _e = useInheritedState(DropContext), setDrop = _e[1];
  var _f = React21.useContext(DropsContext), registerDrop = _f[1], deregisterDrop = _f[2];
  var getElement = React21.useCallback(function() {
    return ref.current && ref.current.element ? ref.current.element : ref.current;
  }, [ref]);
  var target = React21.useRef(null);
  React21.useImperativeHandle(target, function() {
    return {
      element: getElement(),
      onDragEnter: handleDragEnter,
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDrop: handleDrop,
      data: ref.current
    };
  });
  var handleDragEnter = React21.useCallback(function(event) {
    setDrop(target, { target: ref.current, event });
    onDragEnter(event);
  }, [setDrop, ref, onDragEnter]);
  var handleDragOver = React21.useCallback(function(event) {
    onDragOver(event);
  }, [onDragOver]);
  var handleDragLeave = React21.useCallback(function(event) {
    setDrop(null, { target: ref.current, event });
    onDragLeave(event);
  }, [setDrop, ref, onDragLeave]);
  var handleDrop = React21.useCallback(function(event) {
    setDrop(null, { target: ref.current, event });
    onDrop(event);
  }, [setDrop, ref, onDrop]);
  var register = React21.useCallback(function() {
    registerDrop(target);
    return function() {
      deregisterDrop(target);
    };
  }, [deregisterDrop, registerDrop]);
  React21.useLayoutEffect(register, [register]);
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useControlledState.js
var React22 = __toESM(require_react());
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var useControlledState = function(defaultProp, prop, callback) {
  var _a = React22.useState(prop || defaultProp), state = _a[0], setState = _a[1];
  var handleSetEdit = React22.useCallback(function(value, args) {
    setState(value);
    if (callback) {
      callback.call(void 0, __assign8(__assign8({}, args), { value }));
    }
  }, [callback, setState]);
  return [prop !== void 0 ? prop : state, handleSetEdit];
};

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/index.js
var DragAndDrop = function(props) {
  var _a = useControlledState(null, void 0), drag = _a[0], setDrag = _a[1];
  var _b = useControlledState(null, void 0), drop = _b[0], setDrop = _b[1];
  var _c = useCollection([]), drags = _c[0], dispatchDrags = _c[1];
  var _d = useCollection([]), drops = _d[0], dispatchDrops = _d[1];
  var registerDrag = function(item) {
    dispatchDrags({
      type: COLLECTION_ACTION.add,
      item
    });
  };
  var deregisterDrag = function(item) {
    dispatchDrags({
      type: COLLECTION_ACTION.remove,
      item
    });
  };
  var registerDrop = function(item) {
    dispatchDrops({
      type: COLLECTION_ACTION.add,
      item
    });
  };
  var deregisterDrop = function(item) {
    dispatchDrops({
      type: COLLECTION_ACTION.remove,
      item
    });
  };
  return React23.createElement(
    DragContext.Provider,
    { value: [drag, setDrag] },
    React23.createElement(
      DropContext.Provider,
      { value: [drop, setDrop] },
      React23.createElement(
        DragsContext.Provider,
        { value: [drags, registerDrag, deregisterDrag] },
        React23.createElement(DropsContext.Provider, { value: [drops, registerDrop, deregisterDrop] }, props.children)
      )
    )
  );
};
DragAndDrop.displayName = "KendoReactDragAndDrop";

// node_modules/@progress/kendo-react-common/dist/es/Draggable.js
var React24 = __toESM(require_react());
var Draggable = React24.forwardRef(function(props, ref) {
  var childRef = React24.useRef(null);
  var target = React24.useRef(null);
  var getElement = React24.useCallback(function() {
    return childRef.current && childRef.current.element ? childRef.current.element : childRef.current;
  }, [childRef]);
  React24.useImperativeHandle(target, function() {
    return { element: getElement() || null };
  });
  React24.useImperativeHandle(ref, function() {
    return target.current;
  });
  React24.useImperativeHandle(props.childRef, function() {
    return childRef.current;
  });
  var handlePress = React24.useCallback(function(event) {
    if (!props.onPress) {
      return;
    }
    props.onPress({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onPress]);
  var handleRelease = React24.useCallback(function(event) {
    if (!props.onRelease) {
      return;
    }
    props.onRelease({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onRelease]);
  var handleDragStart = React24.useCallback(function(event) {
    if (!props.onDragStart) {
      return;
    }
    props.onDragStart({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props, getElement]);
  var handleDrag = React24.useCallback(function(event) {
    if (!props.onDrag) {
      return;
    }
    props.onDrag({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDrag]);
  var handleDragEnd = React24.useCallback(function(event) {
    if (!props.onDragEnd) {
      return;
    }
    props.onDragEnd({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDragEnd]);
  useDraggable(childRef, {
    onPress: handlePress,
    onRelease: handleRelease,
    onDragStart: handleDragStart,
    onDrag: handleDrag,
    onDragEnd: handleDragEnd
  }, {
    mouseOnly: props.mouseOnly,
    autoScroll: props.autoScroll,
    hint: props.hint,
    scrollContainer: props.scrollContainer
  });
  return props.children ? React24.cloneElement(React24.Children.only(props.children), { ref: childRef }) : null;
});
Draggable.displayName = "KendoReactDraggable";

// node_modules/@progress/kendo-react-common/dist/es/Droppable.js
var React25 = __toESM(require_react());
var Droppable = React25.forwardRef(function(props, ref) {
  var childRef = React25.useRef(null);
  var target = React25.useRef(null);
  var getElement = React25.useCallback(function() {
    return childRef.current && childRef.current.element ? childRef.current.element : childRef.current;
  }, [childRef]);
  React25.useImperativeHandle(target, function() {
    return { element: getElement() || void 0 };
  });
  React25.useImperativeHandle(ref, function() {
    return target.current;
  });
  React25.useImperativeHandle(props.childRef, function() {
    return childRef.current;
  });
  var handleDragEnter = React25.useCallback(function(event) {
    if (!props.onDragEnter) {
      return;
    }
    props.onDragEnter({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDragEnter, getElement]);
  var handleDragOver = React25.useCallback(function(event) {
    if (!props.onDragOver) {
      return;
    }
    props.onDragOver({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDragOver]);
  var handleDragLeave = React25.useCallback(function(event) {
    if (!props.onDragLeave) {
      return;
    }
    props.onDragLeave({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDragLeave, getElement]);
  var handleDrop = React25.useCallback(function(event) {
    if (!props.onDrop) {
      return;
    }
    props.onDrop({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDrop, getElement]);
  useDroppable(childRef, {
    onDragEnter: handleDragEnter,
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDrop: handleDrop
  });
  return props.children ? React25.cloneElement(React25.Children.only(props.children), { ref: childRef }) : null;
});
Droppable.displayName = "KendoReactDroppable";

// node_modules/@progress/kendo-react-common/dist/es/theme.js
var kendoThemeMaps = {
  sizeMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  },
  roundedMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  }
};

// node_modules/@progress/kendo-react-common/dist/es/memoize.js
function isEqual(first, second) {
  return first === second || Number.isNaN(first) && Number.isNaN(second);
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqualFn) {
  if (isEqualFn === void 0) {
    isEqualFn = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqualFn(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}

// node_modules/@progress/kendo-react-common/dist/es/navigation.js
var FOCUSABLE_ELEMENTS = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
];
var Navigation = (
  /** @class */
  function() {
    function Navigation2(options) {
      var _this = this;
      this.rovingTabIndex = true;
      this.update = function() {
      };
      this.focusNextIndex = function(target, indexDiff) {
        var all = _this.elements;
        var index = all.indexOf(target) + indexDiff;
        index = index < 0 ? all.length - 1 : index;
        _this.focusElement(all[index % all.length], target);
      };
      this.tabIndex = options.tabIndex || 0;
      this.root = options.root;
      this.selectors = options.selectors;
      this.rovingTabIndex = options.rovingTabIndex !== void 0 ? options.rovingTabIndex : true;
      this.mouseEvents = options.mouseEvents || {};
      this.keyboardEvents = options.keyboardEvents || {};
    }
    Object.defineProperty(Navigation2.prototype, "elements", {
      get: function() {
        return this.root.current ? Array.from(this.root.current.querySelectorAll(this.selectors.join(","))) : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigation2.prototype, "first", {
      get: function() {
        return this.root.current && this.root.current.querySelector(this.selectors.join(",")) || null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigation2.prototype, "last", {
      get: function() {
        var all = this.elements;
        return all[all.length - 1] || null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigation2.prototype, "current", {
      get: function() {
        return this.elements.find(function(el) {
          return el.matches(":focus");
        }) || null;
      },
      enumerable: false,
      configurable: true
    });
    Navigation2.prototype.focusNext = function(target) {
      this.focusNextIndex(target, 1);
    };
    Navigation2.prototype.focusPrevious = function(target) {
      this.focusNextIndex(target, -1);
    };
    Navigation2.prototype.triggerKeyboardEvent = function(ev) {
      var target = ev.target instanceof Element && ev.target.closest(this.selectors.join(","));
      var key = ev.key === " " ? "Space" : ev.key;
      var eventType = ev.nativeEvent.type;
      if (target && this.keyboardEvents[eventType][key]) {
        this.keyboardEvents[eventType][key].call(void 0, target, this, ev);
      }
    };
    Navigation2.prototype.triggerMouseEvent = function(ev) {
      var target = ev.target instanceof Element && ev.target.closest(this.selectors.join(","));
      var eventType = ev.nativeEvent.type;
      if (target) {
        this.mouseEvents[eventType].call(void 0, target, this, ev);
      }
    };
    Navigation2.prototype.focusElement = function(element, previous) {
      if (element) {
        if (previous) {
          if (this.rovingTabIndex) {
            previous.removeAttribute("tabindex");
          }
          previous.classList.remove("k-focus");
        }
        if (this.rovingTabIndex) {
          element.setAttribute("tabindex", String(this.tabIndex));
        }
        element.focus({ preventScroll: true });
      }
    };
    return Navigation2;
  }()
);

export {
  ZIndexContext,
  useZIndexContext,
  BrowserSupportService,
  canUseDOM,
  canUseRef,
  classNames,
  cloneDate,
  clone,
  cloneObject,
  cloneValue,
  cloneArray,
  focusFirstFocusableChild,
  FormComponent,
  getTabIndex,
  getter,
  guid,
  Keys,
  noop,
  getScrollbarWidth,
  setScrollbarWidth,
  setter,
  mapTree,
  mapTreeItem,
  extendDataItem,
  getItemPath,
  validatePackage,
  index_esm_exports,
  validatePackage2,
  hasRelativeStackingContext,
  dispatchEvent,
  useAsyncFocusBlur,
  AsyncFocusBlur,
  usePropsContext,
  createPropsContext,
  withPropsContext,
  useDir,
  useRtl,
  useMouse,
  useCustomComponent,
  COLLECTION_ACTION,
  useCollection,
  useDocument,
  useWindow,
  Icon,
  SvgIcon,
  IconsContext,
  IconWrap,
  toIconName,
  toIconClass,
  svgIconPropType,
  Typography,
  useDraggable,
  useDroppable,
  DragAndDrop,
  Draggable,
  Droppable,
  kendoThemeMaps,
  memoizeOne,
  FOCUSABLE_ELEMENTS,
  Navigation
};
//# sourceMappingURL=chunk-KTMNFILY.js.map
