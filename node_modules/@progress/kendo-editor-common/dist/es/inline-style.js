import { __assign, __spreadArray } from "tslib";
import { AddMarkStep, RemoveMarkStep } from 'prosemirror-transform';
import { changeStylesString, shallowEqual } from './utils';
import { markApplies, hasMark, removeMarks, toggleMark, styleValue, selectionMarks } from './mark';
var changeStyleFromMark = function (marks, toChange) {
    var styleMark = marks.find(function (m) { return m.type.name === 'style'; });
    var elementStyle = styleMark && styleMark.attrs.style;
    return changeStylesString(elementStyle, toChange);
};
var changeStyleMark = function (tr, from, to, attrs, markType) {
    var mark = markType.create({ style: attrs.style });
    var removed = [], added = [], removing = null, adding = null;
    tr.doc.nodesBetween(from, to, function (node, pos, parent) {
        if (!node.isInline) {
            return;
        }
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
            var newStyle = changeStyleFromMark(marks, attrs);
            if (newStyle.changed || attrs.newValue) {
                var style = newStyle.changed ?
                    { style: newStyle.style || null } : { style: [attrs.style] + ": " + attrs.newValue + ";" };
                var currentMark = markType.isInSet(marks) ? marks.find(function (m) { return m.type.name === 'style'; }) : null;
                var newMarkAttrs_1 = currentMark ? __assign(__assign({}, currentMark.attrs), style) : style;
                var newStyleMark = markType.create(newMarkAttrs_1);
                var newSet = newStyleMark.addToSet(marks);
                for (var i = 0; i < marks.length; i++) {
                    if (!marks[i].isInSet(newSet)) {
                        if (removing && removing.to === start && removing.mark.eq(marks[i])) {
                            removing.to = end;
                        }
                        else {
                            removing = new RemoveMarkStep(start, end, marks[i]);
                            removed.push(removing);
                        }
                    }
                }
                var previousAdded = adding && adding.to === start;
                var sameAdding = previousAdded && newStyleMark.attrs.style === adding.mark.attrs.style;
                if (previousAdded && sameAdding) {
                    adding.to = end;
                }
                else if (Object.keys(newMarkAttrs_1).some(function (attrName) { return newMarkAttrs_1[attrName] !== null; })) {
                    adding = new AddMarkStep(start, end, newStyleMark);
                    added.push(adding);
                }
            }
        }
    });
    removed.forEach(function (s) { return tr.step(s); });
    added.forEach(function (s) { return tr.step(s); });
    return removed.length + added.length > 0;
};
/**
 * Used by FontSize and FontName tools for getting their state.
 */
export var getInlineStyles = function (state, style) {
    var styleMark = state.schema.marks.style;
    var marks = styleMark ? selectionMarks(state, styleMark) : [];
    return marks.map(function (mark) { return styleValue(mark, style); }).filter(function (m) { return m !== null; });
};
var changeStyle = function (markType, attrs) {
    return function (state, dispatch, tr) {
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor, ranges = _a.ranges;
        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) {
            return false;
        }
        var result = false;
        if (dispatch) {
            var transaction = tr || state.tr;
            if ($cursor) {
                var currentMarks = state.storedMarks || $cursor.marks();
                if (markType.isInSet(currentMarks)) {
                    var newStyle = changeStyleFromMark(currentMarks, attrs);
                    var styleMark = currentMarks.find(function (m) { return m.type.name === 'style'; });
                    var newAttrs_1 = __assign(__assign({}, (styleMark ? styleMark.attrs : {})), { style: newStyle.style || null });
                    if (shallowEqual(styleMark.attrs, newAttrs_1)) {
                        return false;
                    }
                    dispatch(transaction.removeStoredMark(markType));
                    if (Object.keys(newAttrs_1).some(function (attrName) { return newAttrs_1[attrName] !== null; })) {
                        dispatch(transaction.addStoredMark(markType.create(newAttrs_1)));
                    }
                    result = true;
                }
            }
            else {
                for (var i = 0; i < ranges.length; i++) {
                    var _b = ranges[i], $from = _b.$from, $to = _b.$to;
                    result = changeStyleMark(transaction, $from.pos, $to.pos, attrs, markType);
                }
                if (result) {
                    transaction.scrollIntoView();
                    dispatch(transaction);
                }
            }
        }
        return result;
    };
};
/**
 * Used by bold, italic, ... and link commands.
 */
export var toggleInlineFormat = function (options, tr, markAttrs) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var altStyle = options.altStyle, _a = options.altMarks, altMarks = _a === void 0 ? [] : _a, mark = options.mark;
    var transaction = tr || state.tr;
    var styleRemoved = false;
    var dispatched = false;
    var markDispatched = function () { return dispatched = true; };
    if (altStyle && marks.style) {
        var cmd = changeStyle(marks.style, { style: altStyle.name, value: altStyle.value });
        styleRemoved = cmd(state, markDispatched, transaction);
    }
    var allMarks = __spreadArray([mark], altMarks).filter(function (m) { return marks[m]; });
    var toRemove = allMarks.map(function (m) { return hasMark(state, { mark: m }) && marks[m]; }).filter(function (m) { return m; });
    if (toRemove.length) {
        removeMarks(toRemove, state, markDispatched, transaction);
    }
    else {
        if (!styleRemoved) {
            toggleMark(marks[mark], markAttrs, transaction)(state, markDispatched);
        }
    }
    if (dispatched) {
        dispatch(transaction);
    }
    return dispatched;
}; };
/**
 * Used by FontSize, FontName, Color and BackColor commands.
 */
export var applyInlineStyle = function (options, command) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var markType = marks.style;
    var attrs = {
        style: options.style, value: /^.+$/, newValue: options.value
    };
    var tr = state.tr;
    if (command) {
        tr.setMeta('commandName', command);
    }
    tr.setMeta('args', options);
    var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor, ranges = _a.ranges;
    if ((empty && !$cursor) || !markType || !markApplies(state.doc, ranges, markType)) {
        return false;
    }
    // Empty selection
    if ($cursor) {
        var marksFromSelection = state.storedMarks || $cursor.marks();
        var currentMark = markType.isInSet(marksFromSelection) ? marksFromSelection.find(function (m) { return m.type.name === 'style'; }) : null;
        var newStyles = { style: null };
        if (currentMark && currentMark.attrs.style) {
            var resultStyles = changeStylesString(currentMark.attrs.style, attrs);
            if (resultStyles.changed && resultStyles.style) {
                newStyles.style = resultStyles.style;
            }
        }
        else if (attrs.newValue) {
            newStyles.style = [attrs.style] + ": " + attrs.newValue + ";";
        }
        var newMarkAttrs_2 = currentMark ? __assign(__assign({}, currentMark.attrs), newStyles) : newStyles;
        if (Object.keys(newMarkAttrs_2).some(function (attrName) { return newMarkAttrs_2[attrName] !== null; })) {
            dispatch(tr.addStoredMark(markType.create(newMarkAttrs_2)));
        }
        else {
            dispatch(tr.removeStoredMark(markType));
        }
        return true;
    }
    return changeStyle(markType, attrs)(state, dispatch, tr);
}; };
