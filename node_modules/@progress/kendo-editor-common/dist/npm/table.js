"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pmDeleteColumn = exports.pmAddColumnAfter = exports.pmAddColumnBefore = exports.pmAddRowAfter = exports.pmAddRowBefore = exports.deleteColumn = exports.addColumnAfter = exports.addColumnBefore = exports.addRowAfter = exports.addRowBefore = exports.createTable = void 0;
var tslib_1 = require("tslib");
var prosemirror_tables_1 = require("prosemirror-tables");
Object.defineProperty(exports, "pmAddRowAfter", { enumerable: true, get: function () { return prosemirror_tables_1.addRowAfter; } });
Object.defineProperty(exports, "pmAddRowBefore", { enumerable: true, get: function () { return prosemirror_tables_1.addRowBefore; } });
Object.defineProperty(exports, "pmAddColumnBefore", { enumerable: true, get: function () { return prosemirror_tables_1.addColumnBefore; } });
Object.defineProperty(exports, "pmAddColumnAfter", { enumerable: true, get: function () { return prosemirror_tables_1.addColumnAfter; } });
Object.defineProperty(exports, "pmDeleteColumn", { enumerable: true, get: function () { return prosemirror_tables_1.deleteColumn; } });
var constants_1 = require("./config/constants");
var schema_1 = require("./config/schema");
/**
 * Creates a table.
 * @returns Node
 */
var createTable = function (nodes, rows, columns) {
    var table = nodes.table, table_row = nodes.table_row, table_cell = nodes.table_cell;
    var tableRows = [];
    var cells;
    for (var r = 0; r < rows + 1; r++) {
        cells = [];
        for (var c = 0; c < columns + 1; c++) {
            cells.push(table_cell.createAndFill());
        }
        tableRows.push(table_row.createAndFill(undefined, cells));
    }
    return table.createAndFill(undefined, tableRows);
};
exports.createTable = createTable;
var reTable = /^table$/;
var reRow = /^table_row$/;
var reCell = /^table_cell|table_header$/;
var closest = function (selection, name) {
    var pos = selection.$head;
    for (var i = pos.depth; i > 0; i--) {
        var node = pos.node(i);
        if (name.test(node.type.name)) {
            return {
                pos: pos.before(i),
                node: node
            };
        }
    }
    return null;
};
var addRowBefore = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var _a;
        var row = closest(tr.selection, reRow);
        var table = closest(tr.selection, reTable);
        if (row && table && row.node.attrs[constants_1.rowTypeAttr]) {
            var index = 0;
            for (var i = 0; i < table.node.nodeSize; i++) {
                if (table.node.child(i).eq(row.node)) {
                    index = i;
                    break;
                }
            }
            var next = table.node.child(index - 1);
            var from = row.pos - next.nodeSize;
            tr.setNodeMarkup(from, undefined, (_a = {}, _a[constants_1.rowTypeAttr] = row.node.attrs[constants_1.rowTypeAttr], _a));
        }
        return dispatch(tr);
    });
    return prosemirror_tables_1.addRowBefore(state, cmdDispatch);
};
exports.addRowBefore = addRowBefore;
var addRowAfter = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var _a;
        var row = closest(tr.selection, reRow);
        if (row && row.node.attrs[constants_1.rowTypeAttr]) {
            var from = row.pos + row.node.nodeSize;
            tr.setNodeMarkup(from, undefined, (_a = {}, _a[constants_1.rowTypeAttr] = row.node.attrs[constants_1.rowTypeAttr], _a));
        }
        return dispatch(tr);
    });
    return prosemirror_tables_1.addRowAfter(state, cmdDispatch);
};
exports.addRowAfter = addRowAfter;
var columnIndex = function (table, selection) {
    if (!table) {
        return -1;
    }
    var map = prosemirror_tables_1.TableMap.get(table.node);
    var tableCell = closest(selection, reCell);
    var idx = map.map.indexOf(tableCell.pos - table.pos - 1);
    var colIndex = -1;
    if (idx !== -1) {
        colIndex = idx % map.width;
    }
    return colIndex;
};
var addCol = function (tr, table, to) {
    var _a;
    var colIndex = columnIndex(table, tr.selection);
    var colgroup = schema_1.parseStrColgroup(table.node.attrs[constants_1.colgroupAttr]);
    colgroup.insertBefore(colgroup.ownerDocument.createElement('col'), colgroup.children[colIndex + to]);
    tr.setNodeMarkup(table.pos, null, tslib_1.__assign(tslib_1.__assign({}, table.node.attrs), (_a = {}, _a[constants_1.colgroupAttr] = colgroup.outerHTML, _a)));
};
var deleteCol = function (tr, table, colIndex) {
    var _a;
    var colgroup = schema_1.parseStrColgroup(table.node.attrs[constants_1.colgroupAttr]);
    colgroup.removeChild(colgroup.children[colIndex]);
    tr.setNodeMarkup(table.pos, null, tslib_1.__assign(tslib_1.__assign({}, table.node.attrs), (_a = {}, _a[constants_1.colgroupAttr] = colgroup.outerHTML, _a)));
};
var addColumnBefore = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var table = closest(tr.selection, reTable);
        if (!table.node.attrs[constants_1.colgroupAttr]) {
            return dispatch(tr);
        }
        addCol(tr, table, -1);
        return dispatch(tr);
    });
    return prosemirror_tables_1.addColumnBefore(state, cmdDispatch);
};
exports.addColumnBefore = addColumnBefore;
var addColumnAfter = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var table = closest(tr.selection, reTable);
        if (!table.node.attrs[constants_1.colgroupAttr]) {
            return dispatch(tr);
        }
        addCol(tr, table, 1);
        return dispatch(tr);
    });
    return prosemirror_tables_1.addColumnAfter(state, cmdDispatch);
};
exports.addColumnAfter = addColumnAfter;
var deleteColumn = function (state, dispatch) {
    var colIndex = columnIndex(closest(state.selection, reTable), state.selection);
    var cmdDispatch = dispatch && (function (tr) {
        var table = closest(tr.selection, reTable);
        if (!table.node.attrs[constants_1.colgroupAttr]) {
            return dispatch(tr);
        }
        deleteCol(tr, table, colIndex);
        return dispatch(tr);
    });
    return prosemirror_tables_1.deleteColumn(state, cmdDispatch);
};
exports.deleteColumn = deleteColumn;
