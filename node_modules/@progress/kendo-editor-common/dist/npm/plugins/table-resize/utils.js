"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.edgeCell = exports.parentNode = exports.cellIndexes = exports.domCellAround = exports.getTable = exports.otherResizeHandle = exports.otherResizing = exports.tableRowResizeKey = exports.tableColumnResizeKey = exports.tableResizeKey = exports.setNodeStyle = exports.parseStyle = exports.reAnyValue = void 0;
var tslib_1 = require("tslib");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_tables_1 = require("prosemirror-tables");
var utils_1 = require("../../utils");
exports.reAnyValue = /^.+$/;
var parseStyle = function (styleText) {
    var styles = (styleText || '').split(/\s*;\s*/).filter(Boolean).map(function (s) {
        var _a;
        var nameValue = s.split(/\s*:\s*/);
        return _a = {}, _a[nameValue[0]] = nameValue[1], _a;
    }).reduce(function (acc, val) { return (tslib_1.__assign(tslib_1.__assign({}, acc), val)); }, {});
    return styles;
};
exports.parseStyle = parseStyle;
function setNodeStyle(nodeAttrs, styleType, value) {
    var attrs;
    if (new RegExp('[^-]?' + styleType + ':').test(nodeAttrs.style || '')) {
        var style = utils_1.changeStylesString(nodeAttrs.style || '', { style: styleType, value: exports.reAnyValue, newValue: value }).style;
        attrs = tslib_1.__assign(tslib_1.__assign({}, nodeAttrs), { style: style });
    }
    else if (nodeAttrs.style) {
        attrs = tslib_1.__assign(tslib_1.__assign({}, nodeAttrs), { style: nodeAttrs.style.replace(/;$/, '') + '; ' + styleType + ': ' + value + ';' });
    }
    else {
        attrs = tslib_1.__assign(tslib_1.__assign({}, nodeAttrs), { style: styleType + ': ' + value + ';' });
    }
    return attrs;
}
exports.setNodeStyle = setNodeStyle;
exports.tableResizeKey = new prosemirror_state_1.PluginKey('table-resize');
exports.tableColumnResizeKey = new prosemirror_state_1.PluginKey('table-column-resizing');
exports.tableRowResizeKey = new prosemirror_state_1.PluginKey('table-row-resizing');
function otherResizing(current, state) {
    var activeResize = false;
    activeResize = activeResize ||
        (current !== exports.tableResizeKey && Boolean(exports.tableResizeKey.get(state)) && exports.tableResizeKey.getState(state).dragging);
    activeResize = activeResize ||
        (current !== exports.tableColumnResizeKey && Boolean(exports.tableColumnResizeKey.get(state)) && exports.tableColumnResizeKey.getState(state).dragging);
    activeResize = activeResize ||
        (current !== exports.tableRowResizeKey && Boolean(exports.tableRowResizeKey.get(state)) && exports.tableRowResizeKey.getState(state).dragging);
    return activeResize;
}
exports.otherResizing = otherResizing;
function otherResizeHandle(current, state) {
    var activeResize = false;
    activeResize = activeResize ||
        (current !== exports.tableColumnResizeKey &&
            Boolean(exports.tableColumnResizeKey.get(state)) &&
            exports.tableColumnResizeKey.getState(state).activeHandle > -1);
    activeResize = activeResize ||
        (current !== exports.tableRowResizeKey && Boolean(exports.tableRowResizeKey.get(state)) && exports.tableRowResizeKey.getState(state).activeHandle > -1);
    return activeResize;
}
exports.otherResizeHandle = otherResizeHandle;
function getTable(dom) {
    if (dom && dom.firstChild && dom.firstChild.nodeName === 'TABLE') {
        return dom.firstChild;
    }
    return dom;
}
exports.getTable = getTable;
function domCellAround(target) {
    while (target && target.nodeName !== 'TD' && target.nodeName !== 'TH') {
        target = target.classList.contains('ProseMirror') ? null : target.parentNode;
    }
    return target;
}
exports.domCellAround = domCellAround;
function tableSpansMap(table) {
    var rows = Array.from((table && table.rows) || []);
    var colsCount = Array.from((rows && rows[0] && rows[0].cells) || [])
        .map(function (c) { return c.colSpan; })
        .reduce(function (prev, cur) { return prev + cur; }, 0);
    var map = rows.map(function () { return new Array(colsCount); });
    rows.forEach(function (row, r) {
        var curColSpan = 0;
        Array.from(row.cells).forEach(function (c) {
            for (var colSp = 0; colSp < c.colSpan; colSp++) {
                for (var rowSp = 0; rowSp < c.rowSpan; rowSp++) {
                    var ind = map[r + rowSp].findIndex(function (val, curInd) { return curInd >= curColSpan && !val; });
                    map[r + rowSp][ind] = c;
                }
                curColSpan++;
            }
        });
    });
    return map;
}
function cellIndexes(dataCell) {
    var map = tableSpansMap(dataCell.closest('table'));
    var result = null;
    var _loop_1 = function (r) {
        var row = map[r];
        row.forEach(function (cell, c) {
            if (dataCell === cell) {
                result = { rowIndex: r, cellIndex: c };
            }
        });
        if (result) {
            return "break";
        }
    };
    for (var r = 0; r < map.length; r++) {
        var state_1 = _loop_1(r);
        if (state_1 === "break")
            break;
    }
    return result || { rowIndex: -1, cellIndex: -1 };
}
exports.cellIndexes = cellIndexes;
function parentNode(pos, predicate) {
    for (var depth = pos.depth; depth > 0; depth--) {
        var node = pos.node(depth);
        if (predicate(node)) {
            return { node: node, depth: depth };
        }
    }
    return null;
}
exports.parentNode = parentNode;
function edgeCell(view, event, indexes) {
    var found = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found) {
        return -1;
    }
    var $pos = view.state.doc.resolve(found.pos);
    var parentTable = parentNode($pos, function (n) { return n.type.spec.tableRole === 'table'; });
    if (parentTable === null) {
        return -1;
    }
    var tablePos = $pos.start(parentTable.depth);
    var tableNode = parentTable.node;
    var map = prosemirror_tables_1.TableMap.get(tableNode);
    var cell = tablePos + map.map[(map.width * indexes.rowIndex) + indexes.cellIndex];
    return cell;
}
exports.edgeCell = edgeCell;
