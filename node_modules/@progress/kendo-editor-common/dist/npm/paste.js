"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceImageSourcesFromRtf = exports.pasteCleanup = exports.sanitizeStyleAttr = exports.sanitizeClassAttr = exports.removeAttribute = exports.removeTag = exports.removeComments = exports.sanitize = void 0;
var listConvert_1 = require("./listConvert");
/**
 * Removes the invalid HTML. Use it as a first step for cleaning the HTML.
 */
var sanitize = function (html) {
    html = html.replace(/^[\s\S]+?<!--StartFragment-->\s*([\s\S]*?)\s*<!--EndFragment-->[\s\S]+$/, '$1');
    html = html.replace(/<\/?[ovw]:[^>]*?>/gi, ''); // MS elements, e.g. <o:p>, <w:sdtPr>, <v:
    html = html.replace(/<\\?\??xml[^>]*>/gi, ''); // XML namespaces
    html = html.replace(/<(?:link|meta) [^>]+?>/ig, '');
    html = html.replace(/<style[^>]*?>\s*<\/style>/ig, '');
    html = html.replace(/<\/?st1:.*?>/gi, '');
    html = html.replace(/<a name="[a-zA-Z0-9_]+">/gmi, '');
    html = html.replace(/v:shapes?="[^"]+"/ig, '');
    html = html.replace(/<!\[if !supportLists\]>/ig, '');
    html = html.replace(/<!\[endif\]>/ig, '');
    return html;
};
exports.sanitize = sanitize;
/**
 * Removes comments in HTML.
 */
var removeComments = function (html) {
    return html.replace(/<!--[\s\S]+?-->/g, '');
};
exports.removeComments = removeComments;
/**
 * Removes the specified tag(s).
 */
var removeTag = function (html, tagPattern) {
    return html.replace(new RegExp('<\\/?(' + tagPattern + ')(?:\\s[^>]*?)?>', 'gi'), '');
};
exports.removeTag = removeTag;
/**
 * Removes the passed attribute.
 */
var removeAttribute = function (attr) {
    if (attr.ownerElement) {
        attr.ownerElement.removeAttribute(attr.name);
    }
};
exports.removeAttribute = removeAttribute;
/**
 * Remove the attribute if its value matches /^Mso/ regex.
 */
var sanitizeClassAttr = function (attr) {
    if (/^Mso/.test(attr.value)) {
        exports.removeAttribute(attr);
    }
};
exports.sanitizeClassAttr = sanitizeClassAttr;
var stylesSplit = /\s*;\s*/;
var styleValueSplit = /\s*:\s*/;
/**
 * Removes invalid HTML styles.
 */
var sanitizeStyleAttr = function (attr) {
    var styles = attr.value.split(stylesSplit).filter(function (st) { return Boolean(st); });
    var element = attr.ownerElement;
    var supportedStyles = element.style;
    var result = '', name, value;
    styles.forEach(function (style) {
        var _a;
        _a = style.split(styleValueSplit), name = _a[0], value = _a[1];
        if (supportedStyles[name] !== undefined) {
            result += name + ": " + value + "; ";
        }
    });
    result = result.trim();
    if (result) {
        attr.value = result;
    }
    else {
        exports.removeAttribute(attr);
    }
};
exports.sanitizeStyleAttr = sanitizeStyleAttr;
var removeNode = function (node) {
    var parentNode = node.parentNode;
    if (parentNode) {
        while (node.firstChild) {
            parentNode.insertBefore(node.firstChild, node);
        }
        parentNode.removeChild(node);
    }
};
var sanitizeNode = function (node, attributes) {
    if (node.nodeType === Node.ELEMENT_NODE) {
        for (var i = node.attributes.length - 1; i >= 0; i--) {
            var attr = node.attributes[i];
            if (attributes[attr.name]) {
                attributes[attr.name](attr);
            }
            else if (attributes['*']) {
                attributes['*'](attr);
            }
        }
        if (node.nodeName === 'SPAN' && node.attributes.length === 0) {
            removeNode(node);
        }
    }
};
/**
 * Cleans the HTML based on passed settings.
 * Before using it, clean the HTML with the `sanitize` function.
 */
var pasteCleanup = function (html, settings) {
    var result = html;
    if (settings.convertMsLists) {
        result = listConvert_1.convertMsLists(result);
    }
    if (settings.stripTags) {
        result = exports.removeTag(result, settings.stripTags);
    }
    if (settings.attributes) {
        var div = document.createElement('div');
        div.innerHTML = result;
        Array.from(div.querySelectorAll('*')).forEach(function (node) { return sanitizeNode(node, settings.attributes); });
        result = div.innerHTML;
    }
    return result;
};
exports.pasteCleanup = pasteCleanup;
function convertHexToBase64(hex) {
    var length = hex.length;
    var data = new Array(length / 2);
    for (var i = 0; i < length; i += 2) {
        data[i] = String.fromCharCode(parseInt(hex.substring(i, i + 2), 16));
    }
    return btoa(data.join(''));
}
var reHtmlImg = /<img\s[^>]*?src=(?:'|")file:\/[^'"]+(?:'|")[^>]*>/gi;
var reRtfImgHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
var reRtfImg = new RegExp('(?:(' + reRtfImgHeader.source + '))([\\da-fA-F\\s]+)\\}', 'g');
var reNonHex = /[^\da-fA-F]/g;
var reLocalFile = /file:\/[^'"]+\.(jpg|png|gif)/i;
var reExtension = /\\(png|jpeg)blip\\/;
var textRtfType = 'text/rtf';
/**
 * If the input HTML contains images with 'src' pointing to local file system (it happens when pasting images and text from MS Word),
 * the function will extract the image sources form the RTF and replace the image 'src' with extracted base64 format data in `html` string.
 *
 * @param html - The input HTML (pasted HTML).
 * @param clipboardData - The paste event clipboardData object (event.clipboardData).
 * @returns - The html with the replaced images sources.
 */
var replaceImageSourcesFromRtf = function (html, clipboardData) {
    var htmlImages = html.match(reHtmlImg);
    if (!htmlImages || clipboardData.types.indexOf(textRtfType) === -1) {
        return html;
    }
    var rtf = clipboardData.getData(textRtfType);
    var base64Sources = [];
    var rtfImages = rtf.match(reRtfImg);
    if (!rtf || !rtfImages) {
        return html;
    }
    for (var _i = 0, rtfImages_1 = rtfImages; _i < rtfImages_1.length; _i++) {
        var image = rtfImages_1[_i];
        var extension = reExtension.exec(image);
        if (extension) {
            var hex = image.replace(reRtfImgHeader, '').replace(reNonHex, '');
            base64Sources.push("data:image/" + extension[1] + ";base64," + convertHexToBase64(hex));
        }
    }
    if (htmlImages.length !== base64Sources.length) {
        return html;
    }
    return html.replace(reHtmlImg, function (img) {
        var src = base64Sources.shift() || '';
        return img.replace(reLocalFile, src);
    });
};
exports.replaceImageSourcesFromRtf = replaceImageSourcesFromRtf;
