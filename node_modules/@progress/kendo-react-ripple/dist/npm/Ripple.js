"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ripple = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var kendo_ripple_1 = require("@progress/kendo-ripple");
var licensing = require("@progress/kendo-licensing");
var package_metadata_1 = require("./package-metadata");
var Ripple = /** @class */ (function (_super) {
    __extends(Ripple, _super);
    function Ripple(props) {
        var _this = _super.call(this, props) || this;
        _this._element = null;
        _this.removeListeners = (function () { });
        _this.registerListeners = function () {
            var root = _this._element;
            _this.removeListeners();
            var callback = (0, kendo_ripple_1.register)(root, [
                { selector: '.k-button:not(li)' },
                { selector: '.k-list>.k-item,.k-list>.k-list-item', options: { global: true } },
                { selector: '.k-checkbox-label,.k-radio-label' },
                {
                    selector: '.k-checkbox,.k-radio',
                    options: {
                        events: ['focusin', 'animationend', 'click']
                    }
                }
            ]);
            _this.removeListeners = callback;
        };
        if (typeof licensing !== 'undefined') {
            licensing.validatePackage(package_metadata_1.packageMetadata);
        }
        else {
            var message = "License activation failed for ".concat(package_metadata_1.packageMetadata.name, "\n");
            message += 'The @progress/kendo-licensing script is not loaded.\n';
            message += "See ".concat(package_metadata_1.packageMetadata.licensingDocsUrl, " for more information.\n");
            console.warn(message);
        }
        return _this;
    }
    /**
     * @hidden
     */
    Ripple.prototype.componentDidMount = function () {
        this.registerListeners();
    };
    /**
     * @hidden
     */
    Ripple.prototype.componentDidUpdate = function () {
        var disabled = this.props.disabled;
        if (disabled) {
            this.removeListeners();
        }
        else {
            this.registerListeners();
        }
    };
    /**
     * @hidden
     */
    Ripple.prototype.componentWillUnmount = function () {
        this.removeListeners();
    };
    /**
     * @hidden
     */
    Ripple.prototype.render = function () {
        var _this = this;
        var classNames = this.props.className
            ? 'k-ripple-container' + ' ' + this.props.className
            : 'k-ripple-container';
        return (React.createElement("span", { className: classNames, ref: function (el) { _this._element = el; } }, this.props.children));
    };
    /**
     * @hidden
     */
    Ripple.propTypes = {
        disabled: PropTypes.bool
    };
    return Ripple;
}(React.PureComponent));
exports.Ripple = Ripple;
