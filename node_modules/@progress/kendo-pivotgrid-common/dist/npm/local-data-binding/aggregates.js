"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:object-literal-sort-keys
/**
 * Represents the aggregate object which calculates the total value. Applicable for local data binding.
 */
exports.sumAggregate = {
    init: function (data) {
        if (('sum' in data) === false) {
            data.sum = 0;
        }
    },
    merge: function (src, dest) {
        dest.sum += src.sum;
    },
    accumulate: function (acc, value) {
        acc.sum += value;
    },
    result: function (data) { return data.sum; },
    format: function (value) { return value.toFixed(2); }
};
/**
 * Represents the aggregate object which calculates the minimum value. Applicable for local data binding.
 */
exports.minAggregate = {
    init: function (data) {
        if (('min' in data) === false) {
            data.min = Number.POSITIVE_INFINITY;
        }
    },
    merge: function (src, dest) {
        dest.min = Math.min(src.min, dest.min);
    },
    accumulate: function (acc, value) {
        acc.min = Math.min(value, acc.min);
    },
    result: function (data) { return Number.isFinite(data.min) ? data.min : NaN; },
    format: function (value) { return value.toFixed(2); }
};
/**
 * Represents the aggregate object which calculates the maximum value. Applicable for local data binding.
 */
exports.maxAggregate = {
    init: function (data) {
        if (('max' in data) === false) {
            data.max = Number.NEGATIVE_INFINITY;
        }
    },
    merge: function (src, dest) {
        dest.max = Math.max(src.max, dest.max);
    },
    accumulate: function (acc, value) {
        acc.max = Math.max(value, acc.max);
    },
    result: function (data) { return Number.isFinite(data.max) ? data.max : NaN; },
    format: function (value) { return value.toFixed(2); }
};
/**
 * Represents the aggregate object which calculates the average value. Applicable for local data binding.
 */
exports.averageAggregate = {
    init: function (data) {
        if (('count' in data) === false) {
            data.sumA = 0;
            data.count = 0;
        }
    },
    merge: function (src, dest) {
        dest.sumA += src.sumA;
        dest.count += src.count;
    },
    accumulate: function (acc, value) {
        acc.sumA += value;
        acc.count += 1;
    },
    result: function (data) { return data.sumA / data.count; },
    format: function (value) { return value.toFixed(2); }
};
