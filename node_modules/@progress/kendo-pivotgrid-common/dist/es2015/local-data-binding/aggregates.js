// tslint:disable:object-literal-sort-keys
/**
 * Represents the aggregate object which calculates the total value. Applicable for local data binding.
 */
export const sumAggregate = {
    init: (data) => {
        if (('sum' in data) === false) {
            data.sum = 0;
        }
    },
    merge: (src, dest) => {
        dest.sum += src.sum;
    },
    accumulate: (acc, value) => {
        acc.sum += value;
    },
    result: data => data.sum,
    format: (value) => value.toFixed(2)
};
/**
 * Represents the aggregate object which calculates the minimum value. Applicable for local data binding.
 */
export const minAggregate = {
    init: (data) => {
        if (('min' in data) === false) {
            data.min = Number.POSITIVE_INFINITY;
        }
    },
    merge: (src, dest) => {
        dest.min = Math.min(src.min, dest.min);
    },
    accumulate: (acc, value) => {
        acc.min = Math.min(value, acc.min);
    },
    result: data => Number.isFinite(data.min) ? data.min : NaN,
    format: (value) => value.toFixed(2)
};
/**
 * Represents the aggregate object which calculates the maximum value. Applicable for local data binding.
 */
export const maxAggregate = {
    init: (data) => {
        if (('max' in data) === false) {
            data.max = Number.NEGATIVE_INFINITY;
        }
    },
    merge: (src, dest) => {
        dest.max = Math.max(src.max, dest.max);
    },
    accumulate: (acc, value) => {
        acc.max = Math.max(value, acc.max);
    },
    result: data => Number.isFinite(data.max) ? data.max : NaN,
    format: (value) => value.toFixed(2)
};
/**
 * Represents the aggregate object which calculates the average value. Applicable for local data binding.
 */
export const averageAggregate = {
    init: (data) => {
        if (('count' in data) === false) {
            data.sumA = 0;
            data.count = 0;
        }
    },
    merge: (src, dest) => {
        dest.sumA += src.sumA;
        dest.count += src.count;
    },
    accumulate: (acc, value) => {
        acc.sumA += value;
        acc.count += 1;
    },
    result: data => data.sumA / data.count,
    format: (value) => value.toFixed(2)
};
