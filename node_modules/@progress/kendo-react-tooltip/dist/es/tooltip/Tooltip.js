var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { dispatchEvent, classNames, ZIndexContext } from '@progress/kendo-react-common';
import { getLeftPosition, getTopPosition, getDomRect, isTooltipElement } from './utils';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from './../package-metadata';
var DEFAULT_TOOLTIP_ZINDEX = 100;
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip(props) {
        var _this = _super.call(this, props) || this;
        /**
         * @hidden
         */
        _this.context = 0;
        /**
         * @hidden
         */
        _this.state = {
            targetElement: null,
            open: false,
            title: ''
        };
        _this.top = 0;
        _this.left = 0;
        _this.willOpen = false;
        /**
         * The method is used on the MouseOut event to hide the Tooltip.
         */
        _this.handleMouseOut = function (event) {
            var targetElement = _this.state.targetElement;
            var currentDocument = targetElement ? targetElement.ownerDocument : document;
            var element = currentDocument && currentDocument.elementFromPoint(event.clientX, event.clientY);
            if (isTooltipElement(element)) {
                return;
            }
            if (_this.props.open) {
                return;
            }
            clearInterval(_this.updateIntervalId);
            _this.willOpen = false;
            _this.onClose(event);
        };
        /**
         * Used on the `MouseOver` event to show the Tooltip.
         */
        _this.handleMouseOver = function (event) {
            var target = event.target;
            if (!_this.isVisible(target) || isTooltipElement(target) || target === _this.state.targetElement) {
                return;
            }
            _this.showToolTip(event);
        };
        _this.handleBodyMousemove = function (event) {
            _this.top = event.clientY;
            _this.left = event.clientX;
        };
        _this.onClose = function (event) {
            dispatchEvent(_this.props.onClose, event, _this, undefined);
            _this.setState({ targetElement: null, open: false, title: '' });
        };
        _this.setUpdateInterval = function () {
            if (_this.props.updateInterval) {
                _this.updateIntervalId = setInterval(_this.onIntervalUpdate, _this.props.updateInterval);
            }
        };
        _this.onIntervalUpdate = function () {
            var target = _this.state.targetElement;
            if (!target) {
                return;
            }
            if (target.parentElement === null) {
                // Getting element from previous target coordinates will cause reflow which is performance hit.
                // Also remount case can be avoided easily
                _this.onClose({ target: target });
            }
            else {
                _this.showToolTip({ target: target });
            }
        };
        _this.position = function (element) {
            var domRect = getDomRect(_this.state.targetElement);
            var left = getLeftPosition(_this.left, element.offsetWidth, domRect, _this.props.anchorElement, _this.props.position);
            var top = getTopPosition(_this.top, domRect, element.offsetHeight, _this.props.anchorElement, _this.props.position);
            return { left: left, top: top };
        };
        _this.getTitle = function (element) {
            while (element) {
                if (element.getAttribute('title') !== null || element.titleExpando) {
                    var title = element.getAttribute('title') || element.titleExpando;
                    return { title: title, element: element };
                }
                element = _this.props.parentTitle && element.parentElement || null;
            }
            return { title: '', element: element };
        };
        _this.calloutClassName = function () {
            switch (_this.props.position) {
                case 'bottom':
                    return 'k-callout k-callout-n';
                case 'left':
                    return 'k-callout k-callout-e';
                case 'right':
                    return 'k-callout k-callout-w';
                case 'top':
                    return 'k-callout k-callout-s';
                default:
                    return _this.top < (window.innerHeight / 2) ? 'k-callout k-callout-n' : 'k-callout k-callout-s';
            }
        };
        _this.getCurrentZIndex = function () {
            return _this.context ? _this.context : DEFAULT_TOOLTIP_ZINDEX;
        };
        validatePackage(packageMetadata);
        return _this;
    }
    /**
     * @hidden
     */
    Tooltip.prototype.componentDidMount = function () {
        if (document) {
            document.body.addEventListener('mousemove', this.handleBodyMousemove);
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.componentWillUnmount = function () {
        clearTimeout(this.openTimeoutId);
        clearInterval(this.updateIntervalId);
        if (document) {
            document.body.removeEventListener('mousemove', this.handleBodyMousemove);
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.componentDidUpdate = function () {
        if (this.props.open && this.props.targetElement) {
            this.showToolTip({ target: this.props.targetElement });
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.render = function () {
        var _this = this;
        if (this.props.children) {
            var _a = this.props, children = _a.children, options = __rest(_a, ["children"]);
            var tooltip_1 = null;
            return (React.createElement("div", { onMouseOver: function (event) { if (tooltip_1) {
                    tooltip_1.handleMouseOver(event);
                } }, onMouseOut: function (event) { if (tooltip_1) {
                    tooltip_1.handleMouseOut(event);
                } } },
                React.createElement(Tooltip, __assign({ ref: function (el) { return tooltip_1 = el; } }, options)),
                children));
        }
        if (this.props.open === false) {
            return null;
        }
        var targetElement = this.state.targetElement;
        var currentZIndex = this.getCurrentZIndex();
        return targetElement &&
            this.state.title &&
            targetElement.ownerDocument &&
            ReactDOM.createPortal((React.createElement("div", { ref: function (el) {
                    if (!el) {
                        return;
                    }
                    var position;
                    if (_this.props.onPosition) {
                        var ev = {
                            element: el,
                            targetElement: _this.state.targetElement,
                            mouseTop: _this.top,
                            mouseLeft: _this.left,
                            anchorElement: _this.props.anchorElement,
                            position: _this.props.position,
                            target: _this,
                            syntheticEvent: null,
                            nativeEvent: null
                        };
                        position = _this.props.onPosition.call(undefined, ev);
                    }
                    else {
                        position = _this.position(el);
                    }
                    el.style.left = position.left + 'px';
                    el.style.top = position.top + 'px';
                }, className: classNames('k-animation-container', 'k-animation-container-fixed', 'k-animation-container-shown', this.props.className), style: __assign({ zIndex: currentZIndex }, this.props.style), tabIndex: 0 },
                React.createElement("div", { className: 'k-child-animation-container' },
                    React.createElement("div", { id: this.props.id, role: 'tooltip', className: classNames('k-tooltip', this.props.tooltipClassName), style: __assign({ position: 'relative' }, this.props.tooltipStyle) },
                        React.createElement("div", { className: "k-tooltip-content" }, this.props.content &&
                            React.createElement(this.props.content, { title: this.state.title, target: this.state.targetElement })
                            || this.state.title),
                        this.props.showCallout && React.createElement("div", { ref: function (el) {
                                if (!el) {
                                    return;
                                }
                                el.className = _this.calloutClassName();
                                if (_this.props.position === 'auto') {
                                    _this.left < (window.screen.availWidth / 2)
                                        ? el.style.left = _this.props.setCalloutOnPositionAuto || '25%'
                                        : el.style.left = _this.props.setCalloutOnPositionAuto || '75%';
                                }
                            } }))))), this.props.appendTo ? this.props.appendTo : targetElement.ownerDocument.body);
    };
    Tooltip.prototype.showToolTip = function (event) {
        var _this = this;
        clearTimeout(this.openTimeoutId);
        clearInterval(this.updateIntervalId);
        if (event.target.hasChildNodes()) {
            event.target.childNodes.forEach(function (childElement) {
                if (childElement.nodeName === 'title') {
                    event.target.titleExpando = childElement.innerHTML;
                    childElement.remove();
                }
            });
        }
        var target = this.props.targetElement || event.target;
        var titleResult = this.getTitle(target);
        if (!titleResult.title) {
            if (this.state.open) {
                this.onClose(event);
            }
            return;
        }
        if (titleResult.element) {
            titleResult.element.titleExpando = titleResult.title;
            titleResult.element.title = '';
        }
        this.willOpen = true;
        if (!this.props.openDelay) {
            this.setState({ targetElement: target, open: true, title: titleResult.title }, this.setUpdateInterval);
        }
        else {
            this.openTimeoutId = window.setTimeout(function () {
                if (_this.willOpen) {
                    _this.setState({ targetElement: target, open: true, title: titleResult.title }, _this.setUpdateInterval);
                }
            }, this.props.openDelay);
        }
        if (this.state.title !== titleResult.title) {
            dispatchEvent(this.props.onOpen, event, this, undefined);
        }
    };
    Tooltip.prototype.isVisible = function (element) {
        return !this.props.filter || this.props.filter(element);
    };
    /**
     * @hidden
     */
    Tooltip.propTypes = {
        anchorElement: PropTypes.oneOf(['pointer', 'target']),
        content: PropTypes.func,
        filter: PropTypes.func,
        openDelay: PropTypes.number,
        position: PropTypes.oneOf(['right', 'left', 'top', 'bottom', 'auto']),
        updateInterval: PropTypes.number
    };
    Tooltip.defaultProps = {
        anchorElement: 'pointer',
        openDelay: 400,
        position: 'auto',
        showCallout: true,
        parentTitle: false
    };
    /**
     * @hidden
     */
    Tooltip.contextType = ZIndexContext;
    return Tooltip;
}(React.PureComponent));
export { Tooltip };
