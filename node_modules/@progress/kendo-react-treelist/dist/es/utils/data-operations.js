var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { getNestedValue } from './index';
import { filterBy as filterByCommon, orderBy as orderByCommon } from '@progress/kendo-react-data-tools';
import { mapTree as mapTreeCommon, mapTreeItem as mapTreeItemCommon, extendDataItem as extendDataItemCommon, getItemPath as getItemPathCommon } from '@progress/kendo-react-common';
/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
export function orderBy(data, descriptors, subItemsField) {
    return orderByCommon(data, descriptors, subItemsField);
}
/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
export function filterBy(data, descriptors, subItemsField) {
    return filterByCommon(data, descriptors, subItemsField);
}
/**
 * Creates a new array with the results of calling the provided callback function
 * on every element in the provided data tree.
 *
 * @param {any[]} tree - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(value: any) => any} callback - The callback function.
 * @returns {any[]} - The new data tree.
 */
export var mapTree = function (tree, subItemsField, callback) {
    return mapTreeCommon(tree, subItemsField, callback);
};
/**
 * Creates a new array with the results of calling the provided callback function
 * on the element which match the `level` in the provided data tree.
 *
 * @param {any[]} tree - The data tree.
 * @param {number[]} level - An array of indexes of each parent and current item in the data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(value: any) => any} callback - The callback function.
 * @returns {any[]} - The new data tree.
 */
export var mapTreeItem = function (tree, level, subItemsField, callback) {
    return mapTreeItemCommon(tree, level, subItemsField, callback);
};
/**
 * @hidden
 */
export function flatData(data, getChildren, itemMap) {
    var stack = [];
    var flatted = [];
    // we start from end as push() improves performance by up to 50%
    for (var i = data.length - 1; i >= 0; i--) {
        var root = data[i];
        stack.push({
            root: root,
            data: getChildren(root),
            level: [i],
            levelCount: data.length
        });
    }
    while (stack.length > 0) {
        var stackItem = stack.pop();
        flatted.push(__assign(__assign({ dataItem: stackItem.root, level: __spreadArray([], stackItem.level, true) }, itemMap(stackItem.root)), { levelCount: stackItem.levelCount }));
        if (stackItem.data.length) {
            for (var i = stackItem.data.length - 1; i >= 0; i--) {
                var root = stackItem.data[i];
                stack.push({
                    root: root,
                    data: getChildren(root),
                    level: __spreadArray(__spreadArray([], stackItem.level, true), [i], false),
                    levelCount: stackItem.data.length
                });
            }
        }
    }
    return flatted;
}
/**
 * Creates a flat data array from the passed tree dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {string} expandField - The field which points to the expanded value of each data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are in a flat structure.
 */
export var treeToFlat = function (data, expandField, subItemsField) {
    var expanded = function (dataItem) { return Boolean(getNestedValue(expandField, dataItem)); };
    var hasChildren = function (dataItem) { return Boolean(getNestedValue(subItemsField, dataItem)); };
    var getChildren = function (dataItem) {
        var items = [];
        if (expanded(dataItem) && hasChildren(dataItem)) {
            items.push.apply(items, getNestedValue(subItemsField, dataItem));
        }
        return items;
    };
    var flatItems = function (dataItem, flatted, level) {
        flatted.push(__assign(__assign({}, dataItem), { level: level }));
        getChildren(dataItem).forEach(function (root) { return flatItems(root, flatted, level + 1); });
    };
    var flattedData = [];
    data.forEach(function (root) { return flatItems(root, flattedData, 0); });
    return flattedData;
};
/**
 * Creates a tree from the passed dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {(item: object) => any} getId - A function which will return the id of the data item.
 * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are structured in a tree.
 */
export var createDataTree = function (dataset, getId, getParentId, subItemsField) {
    var hashTable = {}, dataTree = [], parentItem;
    dataset.forEach(function (dataItem) { return hashTable[getId(dataItem)] = __assign({}, dataItem); });
    dataset.forEach(function (dataItem) {
        parentItem = hashTable[getParentId(dataItem)];
        if (parentItem) {
            parentItem[subItemsField] = parentItem[subItemsField] || [];
            parentItem[subItemsField].push(hashTable[getId(dataItem)]);
        }
        else {
            dataTree.push(hashTable[getId(dataItem)]);
        }
    });
    return dataTree;
};
/**
 * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.
 *
 * @param {object} item - The source data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {object} propsToExtend - The props with which the source data item will be extended.
 * @returns {object} - The target data item.
 */
export var extendDataItem = function (item, subItemsField, propsToExtend) {
    return extendDataItemCommon(item, subItemsField, propsToExtend);
};
/**
 * Removes the items from the passed `data` which match the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item
 * in the tree data and the items for which returns true will be removed.
 * @returns {any[]} - The new data tree.
 */
export var removeItems = function (data, subItemsField, condition) {
    var _a;
    var newData = mapTree([(_a = {}, _a[subItemsField] = __spreadArray([], data, true), _a)], subItemsField, function (item) { return removeChild(item, condition, subItemsField); });
    return __spreadArray([], newData[0][subItemsField], true);
};
/**
 * @hidden
 */
var removeChild = function (item, condition, subItemsField) {
    var _a;
    var subItems = item[subItemsField] || [];
    var childIndex = subItems.findIndex(condition);
    if (childIndex !== -1) {
        var newChildren = __spreadArray([], subItems, true);
        newChildren.splice(childIndex, 1);
        return __assign(__assign({}, item), (_a = {}, _a[subItemsField] = newChildren, _a));
    }
    return item;
};
/**
 * Changes the `subItems` collection of each data item which matches the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item and
 * will return `true` for items that have to change the subitems collection.
 * @param {(subItems: object[]) => object[]} change - A function which
 * has as a parameter the subitems collection of the matched items and which will return the new subitems collection.
 * @returns {any[]} - The new data tree.
 */
export var modifySubItems = function (data, subItemsField, condition, change) {
    return mapTree(data, subItemsField, function (item) {
        var _a;
        return condition(item) ? __assign(__assign({}, item), (_a = {}, _a[subItemsField] = change(item[subItemsField] || []), _a)) :
            item;
    });
};
/**
 * Returns the data item path in the tree based on the level parameter.
 *
 * @param {any[]} tree - The data tree.
 * @param {number[]} level - The level of the target tree item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The path of the data item.
 */
export var getItemPath = function (tree, level, subItemsField) {
    return getItemPathCommon(tree, level, subItemsField);
};
/**
 * Moves the targeted item in the tree to another position.
 *
 * @param {any[]} data - The data tree.
 * @param {number[]} target - The level of the target tree item which will be moved.
 * @param {number[] | null} destination - The level of the destination tree item where the target item will be moved in.
 * If it is null, the target item will be added at the root level.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The new data tree.
 */
export var moveTreeItem = function (data, target, destination, subItemsField) {
    var tree = __spreadArray([], data, true);
    var targetItemPath = getItemPath(tree, target, subItemsField);
    var targetItem = targetItemPath.pop();
    var targetParent = targetItemPath.pop();
    var targetItemIndex = target[target.length - 1];
    if (destination) {
        var destinationItemPath = getItemPath(tree, destination, subItemsField);
        var destinationItem = destinationItemPath.pop();
        (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);
        destinationItem[subItemsField] = destinationItem[subItemsField] || [];
        destinationItem[subItemsField].push(targetItem);
    }
    else {
        (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);
        tree.push(targetItem);
    }
    return tree;
};
