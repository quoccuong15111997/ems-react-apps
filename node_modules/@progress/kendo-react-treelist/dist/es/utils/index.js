/**
 * @hidden
 */
export function getNestedValue(fieldName, dataItem) {
    var path = (fieldName || '').split('.');
    var data = dataItem;
    path.forEach(function (p) {
        data = data ? data[p] : undefined;
    });
    return data;
}
function inPX(value) {
    return value !== undefined && (typeof value === 'number' || /px$/i.test(String(value)));
}
/**
 * @hidden
 */
export function setHeaderRowsTop(table, toolbarHeight, rowHeight) {
    var rows = Array.from(table.tHead && table.tHead.rows || []);
    var heights = [toolbarHeight];
    var height;
    var calculateRowHeight = rowHeight ||
        (function (row) { return window.getComputedStyle(row).height || undefined; });
    rows.forEach(function (row) {
        var computedHeight = calculateRowHeight(row);
        heights.push(inPX(computedHeight) ? parseFloat(String(computedHeight)) : row.offsetHeight);
    });
    for (var i = 0; i < rows.length; i++) {
        height = heights.slice(0, i + 1).reduce(function (acc, curr) { return acc + curr; });
        Array.from(rows[i].cells).forEach(function (c) { return c.style.top = height + 'px'; });
    }
}
var MAX_LEVEL = 1000000;
/**
 * @hidden
 */
export function tableRowsVirtualization(args) {
    var rows = args.rows, tableViewPortHeight = args.tableViewPortHeight, scrollTop = args.scrollTop;
    if (rows.length === 0) {
        return [];
    }
    var itemHeight = rows[0].height;
    var scrollItemIndex = Math.min(Math.round(scrollTop / itemHeight), rows.length);
    var itemsOnOneScreen = Math.round(tableViewPortHeight / itemHeight);
    var start = Math.max(0, scrollItemIndex - itemsOnOneScreen);
    var end = Math.min(rows.length, scrollItemIndex + (2 * itemsOnOneScreen));
    var items = rows.slice(start, end);
    var lastItem = items[items.length - 1];
    if (start > 0) {
        items.unshift({
            dataItem: {},
            level: [MAX_LEVEL],
            offsetTop: 0,
            height: items[0].offsetTop,
            levelCount: 0
        });
    }
    if (end < rows.length - 1) {
        items.push({
            dataItem: {},
            level: [MAX_LEVEL, MAX_LEVEL],
            offsetTop: lastItem.offsetTop + lastItem.height,
            height: (rows.length - end) * itemHeight,
            levelCount: 0
        });
    }
    return items;
}
