var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { Draggable, canUseDOM } from '@progress/kendo-react-common';
import { TreeListRow } from './TreeListRow';
var RowDragClue = function (props) {
    return props.visible && canUseDOM ?
        ReactDOM.createPortal((React.createElement("div", { className: "k-header k-drag-clue", style: {
                display: 'block',
                position: 'absolute',
                zIndex: 20000,
                padding: '8px 12px',
                top: props.top + 'px',
                left: props.left + 'px'
            } },
            React.createElement("span", { className: 'k-icon k-drag-status ' + (props.allowDrop ? 'k-i-plus' : 'k-i-cancel') + ' k-icon-with-modifier' },
                React.createElement("span", { className: "k-icon k-icon-modifier" })),
            props.text)), document.body) : null;
};
function targetRowIndex(event, parent, currentDocument) {
    if (!event.originalEvent) {
        return -1;
    }
    var row = targetElement(event, 'tr', currentDocument);
    if (row) {
        var rows = parent ? parent.childNodes : [];
        for (var i = 0; i < rows.length; i++) {
            if (rows[i] === row) {
                return i;
            }
        }
    }
    return -1;
}
function targetElement(event, closest, currentDocument) {
    var target = currentDocument ? currentDocument.elementFromPoint(event.clientX, event.clientY) : null;
    return ((closest && target) ? target.closest(closest) : null);
}
var treelist = 'k-grid k-grid-md';
var defaultClueState = {
    visible: false,
    top: 0,
    left: 0,
    text: '',
    allowDrop: false
};
/**
 * The TreeList draggable row component.
 */
var TreeListDraggableRow = /** @class */ (function (_super) {
    __extends(TreeListDraggableRow, _super);
    function TreeListDraggableRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @hidden
         */
        _this.state = {
            clueProps: __assign({}, defaultClueState)
        };
        _this.draggable = React.createRef();
        _this.dragged = null;
        _this.draggedOver = null;
        _this.onPress = function () { return _this.dragged = _this.props.level; };
        _this.onDrag = function (args) {
            if (!canUseDOM) {
                return;
            }
            var element = _this.draggable.current && _this.draggable.current.element;
            var ownerDocument = element ? element.ownerDocument : document;
            if (!ownerDocument) {
                return;
            }
            var event = args.event;
            var dragged = _this.dragged;
            if (element && dragged) {
                if (!event.isTouch && event.type !== 'scroll') {
                    event.originalEvent.preventDefault();
                }
                var hovered_1 = _this.props.levels[targetRowIndex(event, element.parentNode, ownerDocument)];
                _this.draggedOver = hovered_1;
                var allowDrop = hovered_1 ?
                    !dragged.every(function (num, i) { return num === hovered_1[i]; }) :
                    Boolean(targetElement(event, treelist, ownerDocument));
                _this.setState({
                    clueProps: {
                        visible: true,
                        top: (event.pageY + 10),
                        left: event.pageX,
                        text: element.innerText,
                        allowDrop: allowDrop
                    }
                });
                if (_this.props.onDrag) {
                    _this.props.onDrag.call(undefined, {
                        nativeEvent: event.originalEvent,
                        dragged: dragged,
                        draggedOver: hovered_1,
                        draggedItem: _this.props.dataItem
                    });
                }
            }
        };
        _this.onRelease = function (args) {
            var event = args.event;
            if (_this.dragged) {
                var dragged = __spreadArray([], _this.dragged, true);
                var draggedOver = _this.draggedOver && __spreadArray([], _this.draggedOver, true);
                var allowDrop = _this.state.clueProps.allowDrop;
                _this.dragged = null;
                _this.draggedOver = null;
                _this.setState({ clueProps: __assign({}, defaultClueState) });
                var draggedItem = _this.props.dataItem;
                if (allowDrop && _this.props.onDrop) {
                    _this.props.onDrop.call(undefined, {
                        nativeEvent: event.originalEvent,
                        dragged: dragged,
                        draggedOver: draggedOver,
                        draggedItem: draggedItem
                    });
                }
            }
        };
        return _this;
    }
    /**
     * @hidden
     */
    TreeListDraggableRow.prototype.render = function () {
        var clueProps = this.state.clueProps;
        return (React.createElement(React.Fragment, null,
            React.createElement(Draggable, { ref: this.draggable, onPress: this.onPress, onDrag: this.onDrag, onRelease: this.onRelease },
                React.createElement(TreeListRow, __assign({}, this.props))),
            React.createElement(RowDragClue, __assign({}, clueProps))));
    };
    return TreeListDraggableRow;
}(React.Component));
export { TreeListDraggableRow };
