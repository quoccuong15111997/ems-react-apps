var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { classNames, noop, getter, guid, canUseDOM, memoizeOne } from '@progress/kendo-react-common';
import { Header, HeaderRow, FilterRow as TreeListFilterRow, ColumnResize, CommonDragLogic, DragClue, DropClue, tableColumnsVirtualization, readColumns, mapColumns, tableKeyboardNavigation, TableKeyboardNavigationContext, tableKeyboardNavigationScopeAttributes, tableKeyboardNavigationTools as navigationTools, tableKeyboardNavigationBodyAttributes, getSelectionOptions, TableSelection } from '@progress/kendo-react-data-tools';
import { getNestedValue, setHeaderRowsTop, tableRowsVirtualization } from './utils/index';
import { flatData } from './utils/data-operations';
import { TreeListCell } from './cells/TreeListCell';
import { TreeListNoRecords } from './TreeListNoRecords';
import { TreeListRow } from './rows/TreeListRow';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from './package-metadata';
/**
 * Represents the [KendoReact TreeList component]({% slug getstarted_treelist %}).
 */
var TreeList = /** @class */ (function (_super) {
    __extends(TreeList, _super);
    function TreeList(props) {
        var _this = _super.call(this, props) || this;
        _this.wrapperScrollLeft = 0;
        _this.wrapperScrollTop = 0;
        _this.updateOnScroll = false;
        _this.tbodyOffsetTop = 0;
        _this.prevData = [];
        _this.flattedData = [];
        _this.extendedColumn = [];
        _this.columnsMap = [];
        _this.element = null;
        _this._treeListId = guid();
        _this.contextStateRef = { current: undefined };
        _this.navigationStateRef = { current: undefined };
        /**
         * Method to allow the scroll to be set to a specific row index.
         *
         * @param options - Object, containing the rowIndex to which is going to be scrolled.
         */
        _this.scrollIntoView = function (options) {
            if (!_this.element) {
                return;
            }
            var _a = options.rowIndex, rowIndex = _a === void 0 ? 0 : _a;
            var _b = _this.props, scrollable = _b.scrollable, _c = _b.rowHeight, rowHeight = _c === void 0 ? 0 : _c;
            if (scrollable === 'virtual' || rowHeight) {
                _this.element.scroll(0, (rowIndex - 1) * rowHeight);
            }
            else {
                var selectedRow = _this.element.querySelector("tbody > tr:nth-child(".concat(rowIndex, ")"));
                if (selectedRow) {
                    var offsetTop = selectedRow.offsetTop - _this.tbodyOffsetTop;
                    _this.element.scroll(0, offsetTop);
                }
            }
        };
        _this.getExtendedColumn = memoizeOne(function (columns, idPrefix) {
            return readColumns(columns, { prevId: 0, idPrefix: idPrefix });
        });
        _this.getColumnsMap = memoizeOne(function (extendedColumn) {
            return mapColumns(extendedColumn);
        });
        _this.onKeyDown = function (event) {
            tableKeyboardNavigation.onKeyDown(event, {
                contextStateRef: _this.contextStateRef,
                navigationStateRef: _this.navigationStateRef
            });
            if (_this.props.onKeyDown) {
                var _a = getSelectionOptions(_this.props.selectable), mode = _a.mode, cell = _a.cell;
                var ev = __assign({ dataItems: _this.getLeafDataItems(), mode: mode, cell: cell, componentId: _this._treeListId, selectedField: _this.props.selectedField }, _this.getArguments(event));
                _this.props.onKeyDown.call(undefined, ev);
            }
        };
        _this.onFocus = function (event) {
            tableKeyboardNavigation.onFocus(event, {
                contextStateRef: _this.contextStateRef
            });
        };
        _this.onRowDrag = function (event) {
            if (_this.props.onRowDrag) {
                _this.props.onRowDrag.call(undefined, __assign(__assign({}, event), { target: _this }));
            }
        };
        _this.onRowDrop = function (event) {
            if (_this.props.onRowDrop) {
                _this.props.onRowDrop.call(undefined, __assign(__assign({}, event), { target: _this }));
            }
        };
        _this.columnReorder = function (prev, next, nativeEvent) {
            var _a;
            var depth = _this.extendedColumn[prev].depth;
            var end = function (index) {
                do {
                    index++;
                } while (index < _this.extendedColumn.length && _this.extendedColumn[index].depth > depth);
                return index;
            };
            var spliced = _this.extendedColumn.splice(prev, end(prev) - prev);
            (_a = _this.extendedColumn).splice.apply(_a, __spreadArray([prev < next ? end(next - spliced.length) : next, 0], spliced, false));
            _this.extendedColumn.filter(function (q) { return q.declarationIndex >= 0; }).forEach(function (c, i) { return c.orderIndex = i; });
            if (_this.props.onColumnReorder) {
                var event_1 = {
                    target: _this,
                    columns: _this.columns,
                    nativeEvent: nativeEvent
                };
                _this.props.onColumnReorder.call(undefined, event_1);
            }
        };
        _this.onResize = function (index, newWidth, oldWidth, nativeEvent, end) {
            if (_this.props.onColumnResize) {
                var sumWidth = _this.extendedColumn.filter(function (c) { return c.children.length === 0; }).
                    reduce(function (acc, column) { return acc += parseFloat(String(column.width)); }, 0);
                var event_2 = {
                    columns: _this.columns,
                    totalWidth: sumWidth,
                    index: index,
                    nativeEvent: nativeEvent,
                    newWidth: newWidth,
                    oldWidth: oldWidth,
                    end: end,
                    target: _this
                };
                _this.props.onColumnResize.call(undefined, event_2);
            }
        };
        _this.handleOnScroll = function (event) {
            var scrollLeft = event.currentTarget.scrollLeft;
            var scrollTop = event.currentTarget.scrollTop;
            var _a = _this.props, columnVirtualization = _a.columnVirtualization, scrollable = _a.scrollable, _b = _a.rowHeight, rowHeight = _b === void 0 ? 0 : _b;
            var minTopChange = rowHeight;
            var minLeftChange = 0;
            var shouldForceUpdate = false;
            if (columnVirtualization && Math.abs(_this.wrapperScrollLeft - scrollLeft) > minLeftChange) {
                _this.wrapperScrollLeft = scrollLeft;
                shouldForceUpdate = true;
            }
            if (scrollable === 'virtual' && Math.abs(_this.wrapperScrollTop - scrollTop) > minTopChange) {
                _this.wrapperScrollTop = scrollTop;
                shouldForceUpdate = true;
            }
            if (shouldForceUpdate) {
                _this.updateOnScroll = true;
                _this.forceUpdate();
            }
        };
        _this.calculateSizes = function (div) {
            if (!div || _this.props.scrollable === 'none') {
                return;
            }
            var children = Array.from(div.childNodes);
            var table = children.find(function (n) { return n.nodeName === 'TABLE'; });
            var toolbar = _this.props.toolbar &&
                children.find(function (n) {
                    return n.nodeType === 1 && n.classList.contains('k-grid-toolbar');
                });
            var toolbarHeight = 0;
            if (toolbar) {
                var boxSizing = toolbar.style.boxSizing;
                toolbar.style.boxSizing = 'border-box';
                toolbarHeight = parseFloat(String(window.getComputedStyle(toolbar).height)) ||
                    toolbar.offsetHeight;
                toolbar.style.boxSizing = boxSizing;
                if (!toolbar.getAttribute('style')) {
                    toolbar.removeAttribute('style');
                }
            }
            _this.tbodyOffsetTop = table.tBodies[0].offsetTop;
            setHeaderRowsTop(table, toolbarHeight);
        };
        _this.itemChange = function (event) {
            var itemChange = _this.props.onItemChange;
            if (event.field === _this.props.expandField) {
                var expandChange = _this.props.onExpandChange;
                if (expandChange) {
                    var expandEvent = __assign(__assign({}, _this.getArguments(event.syntheticEvent)), { dataItem: event.dataItem, level: event.level, value: event.value });
                    expandChange.call(undefined, expandEvent);
                }
                return;
            }
            if (itemChange) {
                var itemChangeEvent = __assign(__assign({}, _this.getArguments(event.syntheticEvent)), { dataItem: event.dataItem, level: event.level, field: event.field, value: event.value });
                itemChange.call(undefined, itemChangeEvent);
            }
        };
        _this.onHeaderSelectionChange = function (event) {
            if (_this.props.onHeaderSelectionChange) {
                var selectionEvent = {
                    field: event.field,
                    nativeEvent: event.syntheticEvent && event.syntheticEvent.nativeEvent,
                    syntheticEvent: event.syntheticEvent,
                    target: _this,
                    dataItems: _this.getLeafDataItems()
                };
                _this.props.onHeaderSelectionChange.call(undefined, selectionEvent);
            }
        };
        _this.selectionRelease = function (event) {
            if (_this.props.onSelectionChange) {
                var selectionEvent = __assign({ syntheticEvent: undefined, target: _this, selectedField: _this.props.selectedField || '', componentId: _this._treeListId, dataItems: _this.getLeafDataItems(), dataItem: null, level: [] }, event);
                _this.props.onSelectionChange.call(undefined, selectionEvent);
            }
        };
        _this.sortChange = function (syntheticEvent, sort, field) {
            _this.raiseDataEvent(_this.props.onSortChange, { sort: sort, field: field }, syntheticEvent);
        };
        _this.filterChange = function (event) {
            var filter = event.filter, field = event.field;
            _this.raiseDataEvent(_this.props.onFilterChange, { filter: filter, field: field }, event.syntheticEvent);
        };
        _this.columnMenuFilterChange = function (syntheticEvent, filter, field) {
            var onColumnMenuFilterChange = _this.props.onColumnMenuFilterChange;
            if (!onColumnMenuFilterChange) {
                return;
            }
            var event = {
                syntheticEvent: syntheticEvent,
                filter: filter,
                field: field,
                target: _this,
                nativeEvent: syntheticEvent.nativeEvent
            };
            onColumnMenuFilterChange.call(undefined, event);
        };
        _this.expandChange = function (event, dataItem, level) {
            var _a = _this.props, expandField = _a.expandField, onExpandChange = _a.onExpandChange;
            if (expandField && onExpandChange) {
                var expandEvent = __assign(__assign({}, _this.getArguments(event)), { dataItem: dataItem, level: level, value: _this.expanded(dataItem) });
                onExpandChange.call(undefined, expandEvent);
            }
        };
        _this.rowClick = function (e, item) {
            if (_this.props.onRowClick && e.target.nodeName === 'TD') {
                var rowClickEvent = __assign({ dataItem: item.dataItem, level: item.level }, _this.getArguments(e));
                _this.props.onRowClick.call(undefined, rowClickEvent);
            }
        };
        _this.rowDoubleClick = function (e, item) {
            if (_this.props.onRowDoubleClick && e.target.nodeName === 'TD') {
                var rowDoubleClickEvent = __assign({ dataItem: item.dataItem, level: item.level }, _this.getArguments(e));
                _this.props.onRowDoubleClick.call(undefined, rowDoubleClickEvent);
            }
        };
        _this.rowContextMenu = function (e, item) {
            if (_this.props.onRowContextMenu && e.target.nodeName === 'TD') {
                var rowContextMenuEvent = __assign({ dataItem: item.dataItem, level: item.level }, _this.getArguments(e));
                _this.props.onRowContextMenu.call(undefined, rowContextMenuEvent);
            }
        };
        _this.onPageChange = function (e) {
            if (_this.props.onPageChange) {
                var event_3 = __assign(__assign({}, _this.getArguments(e.syntheticEvent)), { skip: e.skip, take: e.take });
                _this.props.onPageChange.call(undefined, event_3);
            }
        };
        _this.expandedSubItems = function (dataItem) {
            var items = [];
            if (_this.expanded(dataItem) && _this.hasChildren(dataItem)) {
                items.push.apply(items, getNestedValue(_this.props.subItemsField, dataItem));
            }
            return items;
        };
        _this.getLeafDataItems = function () {
            return _this.flatData.map(function (item) { return item.dataItem; });
        };
        _this.expanded = function (dataItem) { return Boolean(getNestedValue(_this.props.expandField, dataItem)); };
        _this.hasChildren = function (dataItem) { return Boolean(getNestedValue(_this.props.subItemsField, dataItem)); };
        validatePackage(packageMetadata);
        _this.dragLogic = new CommonDragLogic(_this.columnReorder, noop, noop);
        _this.columnResize = new ColumnResize(_this.onResize.bind(_this));
        tableKeyboardNavigation.onConstructor({
            navigatable: Boolean(props.navigatable),
            contextStateRef: _this.contextStateRef,
            navigationStateRef: _this.navigationStateRef
        });
        return _this;
    }
    Object.defineProperty(TreeList.prototype, "document", {
        get: function () {
            if (!canUseDOM) {
                return;
            }
            // useful only for user actions
            return (this.element && this.element.ownerDocument) || document;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    TreeList.prototype.componentDidMount = function () {
        this.calculateSizes(this.element);
        tableKeyboardNavigation.onComponentDidMount({
            scope: this.element || undefined,
            contextStateRef: this.contextStateRef,
            navigationStateRef: this.navigationStateRef
        });
    };
    /**
     * @hidden
     */
    TreeList.prototype.getSnapshotBeforeUpdate = function () {
        tableKeyboardNavigation.onGetSnapshotBeforeUpdate({
            document: this.document,
            contextStateRef: this.contextStateRef,
            navigationStateRef: this.navigationStateRef
        });
        return null;
    };
    /**
     * @hidden
     */
    TreeList.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.columns !== this.props.columns) {
            this.calculateSizes(this.element);
        }
        tableKeyboardNavigation.onComponentDidUpdate({
            scope: this.element || undefined,
            contextStateRef: this.contextStateRef,
            navigationStateRef: this.navigationStateRef
        });
    };
    /**
     * @hidden
     */
    TreeList.prototype.componentWillUnmount = function () {
        this.columnResize.columns = [];
        this.dragLogic.columns = [];
        this.extendedColumn = [];
        this.columnsMap = [];
        this.prevData = [];
        this.flattedData = [];
        this.updateOnScroll = false;
        this.getExtendedColumn.clear();
        this.getColumnsMap.clear();
    };
    /**
     * @hidden
     */
    TreeList.prototype.render = function () {
        var _this = this;
        var _a = this.props, _b = _a.columns, columns = _b === void 0 ? [] : _b, filterRow = _a.filterRow, _c = _a.scrollable, scrollable = _c === void 0 ? 'scrollable' : _c, _d = _a.resizable, resizable = _d === void 0 ? false : _d, _e = _a.reorderable, reorderable = _e === void 0 ? false : _e, skip = _a.skip, take = _a.take;
        var filterable = columns.some(function (c) { return Boolean(c.filter) || Boolean(c.filterCell); }) || filterRow !== undefined;
        var FilterRow = filterRow || TreeListFilterRow;
        var idPrefix = navigationTools.getIdPrefix(this.navigationStateRef);
        this.extendedColumn = this.getExtendedColumn(columns, idPrefix);
        this.columnsMap = this.getColumnsMap(this.extendedColumn);
        var leafColumns = this.extendedColumn.filter(function (c) { return c.children.length === 0; });
        this.columnResize.columns = this.extendedColumn;
        this.columnResize.resizable = resizable;
        this.dragLogic.columns = this.extendedColumn;
        this.dragLogic.reorderable = reorderable;
        this.dragLogic.groupable = false;
        var header = (React.createElement(Header, { headerRow: React.createElement(HeaderRow, { sort: this.props.sort, sortable: this.props.sortable, sortChange: this.sortChange, selectionChange: this.onHeaderSelectionChange, columns: this.extendedColumn, columnsMap: this.columnsMap, cellRender: this.props.headerCellRender, columnResize: this.columnResize, columnMenu: this.props.columnMenu, columnMenuFilter: this.props.columnMenuFilter, columnMenuFilterChange: this.columnMenuFilterChange, pressHandler: this.dragLogic.pressHandler, dragHandler: this.dragLogic.dragHandler, releaseHandler: this.dragLogic.releaseHandler }), filterRow: filterable && React.createElement(FilterRow, { columns: leafColumns, filter: this.props.filter, filterChange: this.filterChange, sort: this.props.sort, ariaRowIndex: this.columnsMap.length + 1 }) || undefined, columnResize: this.columnResize }));
        var wrapperStyles = this.props.style || {};
        var _f = tableColumnsVirtualization({
            enabled: this.props.columnVirtualization,
            columns: leafColumns,
            scrollLeft: this.wrapperScrollLeft,
            tableViewPortWidth: parseFloat((wrapperStyles.width || '').toString())
        }), colSpans = _f.colSpans, hiddenColumns = _f.hiddenColumns;
        var dataRow = function (item, inEdit, rowId, isRowExpanded, rowDataIndex, selectedValue) { return leafColumns.map(function (column, columnIndex) {
            if (hiddenColumns[columnIndex]) {
                return null;
            }
            var columnKey = column.id ? column.id : columnIndex;
            var className = "".concat(column.className ? column.className + ' ' : '')
                + "".concat(column.locked ? 'k-grid-content-sticky' : '');
            var cellProps = {
                id: navigationTools.generateNavigatableId("".concat(rowId, "-").concat(String(columnIndex)), idPrefix),
                colSpan: colSpans[columnIndex],
                dataItem: item.dataItem,
                field: column.field,
                format: column.format,
                className: className || undefined,
                render: _this.props.cellRender,
                onChange: _this.itemChange,
                selectionChange: (_this.props.onSelectionChange) ? (function (e) {
                    _this.selectionChange({ event: e, item: item, columnIndex: columnIndex, dataIndex: rowDataIndex });
                }) : undefined,
                level: item.level,
                expandable: column.expandable,
                expanded: isRowExpanded,
                hasChildren: _this.hasChildren(item.dataItem),
                onExpandChange: _this.expandChange,
                colIndex: columnIndex,
                ariaColumnIndex: column.ariaColumnIndex,
                style: (column.left !== undefined) && {
                    left: column.left,
                    right: column.right,
                    borderRightWidth: column.rightBorder ? '1px' : ''
                } || {},
                isSelected: Array.isArray(selectedValue) && selectedValue.indexOf(columnIndex) > -1
            };
            if (inEdit && column.editCell) {
                return (React.createElement(column.editCell, __assign({ key: columnKey }, cellProps, { onChange: _this.itemChange })));
            }
            if (column.cell) {
                return React.createElement(column.cell, __assign({ key: columnKey }, cellProps));
            }
            return React.createElement(TreeListCell, __assign({ key: columnKey }, cellProps));
        }); };
        var flattedData = this.flatData;
        var total = flattedData.length;
        if (skip !== undefined && take !== undefined) {
            flattedData = flattedData.slice(skip, skip + take);
        }
        if (scrollable === 'virtual') {
            flattedData = tableRowsVirtualization({
                rows: flattedData,
                tableViewPortHeight: parseFloat((wrapperStyles.height || wrapperStyles.maxHeight || '').toString()),
                scrollTop: this.wrapperScrollTop
            });
            this.updateOnScroll = false;
        }
        var levels = flattedData.map(function (i) { return i.level; });
        var rowIndexStart = this.columnsMap.length + (filterable ? 1 : 0) + 1;
        var body = flattedData.length > 0 && flattedData.map(function (item, rowIndex) {
            var inEdit = getNestedValue(_this.props.editField, item.dataItem);
            var dataItemKeyValue = _this.props.dataItemKey && getter(_this.props.dataItemKey)(item.dataItem);
            var rowId = String(dataItemKeyValue ? dataItemKeyValue : item.level.join('.'));
            var isRowExpanded = _this.expanded(item.dataItem);
            var selectedValue = _this.props.selectedField ? getNestedValue(_this.props.selectedField, item.dataItem) : undefined;
            var rowProps = {
                key: rowId,
                level: item.level,
                levels: levels,
                dataItem: item.dataItem,
                selectedField: _this.props.selectedField,
                rowHeight: scrollable === 'virtual' ? item.height : _this.props.rowHeight,
                render: _this.props.rowRender,
                onDrop: _this.onRowDrop,
                onDrag: _this.onRowDrag,
                onClick: function (e) { return _this.rowClick(e, item); },
                onDoubleClick: function (e) { return _this.rowDoubleClick(e, item); },
                onContextMenu: function (e) { return _this.rowContextMenu(e, item); },
                isAltRow: rowIndex % 2 !== 0,
                expanded: isRowExpanded,
                rowIndex: rowIndex,
                ariaRowIndex: rowIndexStart + rowIndex,
                ariaSetSize: item.levelCount,
                ariaPosInSet: item.level[item.level.length - 1] + 1,
                isSelected: typeof selectedValue === 'boolean' && selectedValue
            };
            var EditRow = _this.props.editRow;
            var Row = _this.props.row || TreeListRow;
            var cells = dataRow(item, inEdit, rowId, isRowExpanded, rowIndex, selectedValue);
            return inEdit && EditRow ?
                React.createElement(EditRow, __assign({}, rowProps), cells) :
                React.createElement(Row, __assign({}, rowProps), cells);
        }) || (React.createElement("tr", { className: "k-table-row k-grid-norecords" },
            React.createElement("td", { colSpan: leafColumns.length }, this.props.noRecords || React.createElement(TreeListNoRecords, null))));
        var sorted = function (field) {
            return _this.props.sort && _this.props.sort.some(function (descriptor) { return descriptor.field === field; });
        };
        var colGroups = (React.createElement("colgroup", { ref: function (c) { _this.columnResize.colGroupMain = c; } }, leafColumns.map(function (column, index) { return (React.createElement("col", { key: index.toString(), className: sorted(column.field) ? 'k-sorted' : undefined, style: column.width !== undefined ? { width: column.width } : undefined })); })));
        var virtualScroll = this.props.columnVirtualization || this.props.scrollable === 'virtual';
        var tableUserSelect = this.props.selectable && this.props.selectable.drag ? 'none' : undefined;
        var tableProps = (this.props.tableProps || {});
        return (React.createElement(TableKeyboardNavigationContext.Provider, { value: this.contextStateRef.current },
            React.createElement("div", __assign({ style: this.props.style, className: classNames('k-grid k-grid-md', this.props.className, { 'k-treelist-scrollable': scrollable !== 'none' }), ref: function (e) { return _this.element = e; }, onScroll: virtualScroll ? this.handleOnScroll : undefined, onKeyDown: this.onKeyDown, onFocus: this.onFocus, "aria-rowcount": total, "aria-colcount": leafColumns.length, role: 'treegrid' }, tableKeyboardNavigationScopeAttributes),
                this.props.toolbar,
                React.createElement(TableSelection, { selectable: this.props.selectable, onRelease: this.selectionRelease },
                    React.createElement("table", __assign({ className: 'k-table k-table-md k-grid-table' }, tableProps, { style: __assign(__assign({}, (tableProps.style || {})), { userSelect: tableUserSelect }), role: 'presentation' }),
                        colGroups,
                        header,
                        React.createElement("tbody", __assign({ className: 'k-table-tbody' }, tableKeyboardNavigationBodyAttributes, { role: 'presentation' }), body))),
                this.props.pager && (React.createElement(this.props.pager, { className: "k-grid-pager", total: total, skip: skip, take: take, onPageChange: this.onPageChange })),
                reorderable && (React.createElement(React.Fragment, null,
                    React.createElement(DropClue, { ref: this.dragLogic.refDropElementClue }),
                    React.createElement(DragClue, { ref: this.dragLogic.refDragElementClue }))))));
    };
    Object.defineProperty(TreeList.prototype, "columns", {
        get: function () {
            var shuffledColumns = this.extendedColumn.filter(function (q) { return q.declarationIndex >= 0 && q.parentIndex === -1; });
            var sanitize = function (columns) {
                columns.sort(function (a, b) { return a.declarationIndex - b.declarationIndex; });
                return columns.map(function (column) {
                    var declarationIndex = column.declarationIndex, parentIndex = column.parentIndex, depth = column.depth, colSpan = column.colSpan, rowSpan = column.rowSpan, index = column.index, kFirst = column.kFirst, groupable = column.groupable, children = column.children, props = __rest(column, ["declarationIndex", "parentIndex", "depth", "colSpan", "rowSpan", "index", "kFirst", "groupable", "children"]);
                    return children.length ? __assign({ children: sanitize(children) }, props) : props;
                });
            };
            return sanitize(shuffledColumns);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeList.prototype, "flatData", {
        get: function () {
            var _a = this.props, _b = _a.data, data = _b === void 0 ? [] : _b, _c = _a.rowHeight, rowHeight = _c === void 0 ? 0 : _c;
            var offsetTop = 0;
            var itemDataMap = function (_item) {
                var result = { height: rowHeight, offsetTop: offsetTop };
                offsetTop += result.height;
                return result;
            };
            var flattedData = (this.updateOnScroll &&
                this.prevData === data &&
                this.tbodyOffsetTop > 0 &&
                this.flattedData.length) ?
                this.flattedData :
                flatData(data, this.expandedSubItems, itemDataMap);
            this.prevData = data;
            this.flattedData = flattedData;
            return flattedData;
        },
        enumerable: false,
        configurable: true
    });
    TreeList.prototype.selectionChange = function (options) {
        if (this.props.onSelectionChange) {
            var event_4 = options.event, item = options.item, dataIndex = options.dataIndex, columnIndex = options.columnIndex;
            var _a = getSelectionOptions(this.props.selectable), mode = _a.mode, cell = _a.cell;
            var selectionEvent = __assign(__assign({}, this.getArguments(event_4.syntheticEvent)), { dataItem: item.dataItem, level: item.level, startColIndex: columnIndex, endColIndex: columnIndex, startRowIndex: dataIndex, endRowIndex: dataIndex, dataItems: this.getLeafDataItems(), altKey: false, ctrlKey: false, shiftKey: false, metaKey: false, mode: mode, cell: cell, isDrag: false, componentId: this._treeListId, selectedField: this.props.selectedField || '' });
            this.props.onSelectionChange.call(undefined, selectionEvent);
        }
    };
    TreeList.prototype.raiseDataEvent = function (handler, data, syntheticEvent) {
        var dataStateChange = this.props.onDataStateChange;
        if (handler) {
            handler.call(undefined, __assign(__assign({}, this.getArguments(syntheticEvent)), data));
        }
        else if (dataStateChange) {
            var dataStateEvent = __assign(__assign({}, this.getArguments(syntheticEvent)), { dataState: __assign(__assign({}, this.getDataState()), data) });
            dataStateChange.call(undefined, dataStateEvent);
        }
    };
    TreeList.prototype.getDataState = function () {
        return {
            filter: this.props.filter,
            sort: this.props.sort
        };
    };
    TreeList.prototype.getArguments = function (syntheticEvent) {
        return {
            nativeEvent: syntheticEvent && syntheticEvent.nativeEvent,
            syntheticEvent: syntheticEvent,
            target: this
        };
    };
    /**
     * @hidden
     */
    TreeList.propTypes = {
        data: PropTypes.array,
        resizable: PropTypes.bool,
        reorderable: PropTypes.bool,
        sortable: PropTypes.oneOfType([
            PropTypes.bool,
            PropTypes.shape({
                mode: PropTypes.oneOf(['single', 'multiple']),
                allowUnsort: PropTypes.bool
            })
        ]),
        onSortChange: PropTypes.func,
        sort: PropTypes.array,
        columns: PropTypes.arrayOf(PropTypes.object),
        columnVirtualization: PropTypes.bool,
        filter: PropTypes.array,
        onFilterChange: PropTypes.func,
        filterRow: PropTypes.any,
        toolbar: PropTypes.any,
        noRecords: PropTypes.any,
        onExpandChange: PropTypes.func,
        expandField: PropTypes.string,
        subItemsField: PropTypes.string,
        selectedField: PropTypes.string,
        onSelectionChange: PropTypes.func,
        onHeaderSelectionChange: PropTypes.func,
        onRowClick: PropTypes.func,
        onItemChange: PropTypes.func,
        editField: PropTypes.string,
        scrollable: PropTypes.oneOf(['none', 'scrollable', 'virtual']),
        rowHeight: PropTypes.number,
        style: PropTypes.object,
        tableProps: PropTypes.object,
        pager: PropTypes.any,
        skip: PropTypes.number,
        take: PropTypes.number,
        onPageChange: PropTypes.func,
        onDataStateChange: PropTypes.func,
        onColumnResize: PropTypes.func,
        onColumnReorder: PropTypes.func,
        dataItemKey: PropTypes.string,
        navigatable: PropTypes.bool
    };
    /** @hidden */
    TreeList.contextType = TableKeyboardNavigationContext;
    return TreeList;
}(React.Component));
export { TreeList };
