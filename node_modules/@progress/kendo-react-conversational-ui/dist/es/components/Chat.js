var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Keys, classNames, dispatchEvent } from '@progress/kendo-react-common';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { convertMsgsToViewItems } from './../ViewItem';
import ActionGroup from './ActionGroup';
import AttachmentGroup from './AttachmentGroup';
import DateMarker from './DateMarker';
import MessageGroup from './MessageGroup';
import NewMessage from './NewMessage';
import { ChatMessage } from './ChatMessage';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from '../package-metadata';
import { ariaLabelMessageList, messages } from '../messages';
import { provideLocalizationService } from '@progress/kendo-react-intl';
/**
 * Represents the [KendoReact Chat component]({% slug overview_convui %}).
 */
var Chat = /** @class */ (function (_super) {
    __extends(Chat, _super);
    function Chat(props) {
        var _this = _super.call(this, props) || this;
        _this.viewItems = [];
        _this.isDirectionRightToLeft = false;
        _this.scrollToBottomOnLoadingData = true;
        _this.onFocus = function () {
            clearTimeout(_this.timeoutIdForChatLosingFocus);
        };
        _this.onBlur = function () {
            // This is a hacky solution to clear the selection when the focus is lost
            // in favor of an element outside the Chat.
            // https://medium.com/@jessebeach/dealing-with-focus-and-blur-in-a-composite-widget-in-react-90d3c3b49a9b
            _this.timeoutIdForChatLosingFocus = window.setTimeout(function () { _this.setState({ selectedItemIndex: null }); }, 0);
        };
        _this.onSelectionRequested = function (clickedItemIndex) {
            _this.setState({ selectedItemIndex: clickedItemIndex });
        };
        _this.onKeyDown = function (event) {
            var newSelectedItemIndex = null;
            var currentSelectedItemIndex = _this.state.selectedItemIndex !== null ?
                _this.state.selectedItemIndex :
                _this.viewItems.lastSelectionIndex;
            if (event.keyCode === Keys.up) {
                if (currentSelectedItemIndex === null) {
                    newSelectedItemIndex = 0;
                }
                else if (currentSelectedItemIndex > 0) {
                    newSelectedItemIndex = currentSelectedItemIndex - 1;
                }
            }
            else if (event.keyCode === Keys.down) {
                if (currentSelectedItemIndex === null) {
                    newSelectedItemIndex = 0;
                }
                else if (currentSelectedItemIndex < _this.viewItems.lastSelectionIndex) {
                    newSelectedItemIndex = currentSelectedItemIndex + 1;
                }
            }
            if (newSelectedItemIndex !== null) {
                _this.setState({ selectedItemIndex: newSelectedItemIndex });
                // Prevent the default behavior of moving of the scrollbar
                // because scrolling is achieved through item focusing.
                event.preventDefault();
            }
        };
        _this.onMessageSend = function (message, event) {
            dispatchEvent(_this.props.onMessageSend, event, _this, { message: message });
        };
        _this.onActionExecute = function (action, event) {
            dispatchEvent(_this.props.onActionExecute, event, _this, { action: action });
            if (!event.isDefaultPrevented()) {
                switch (action.type) {
                    case 'reply':
                        _this.onMessageSend({
                            author: _this.props.user,
                            text: action.value,
                            timestamp: new Date()
                        }, event);
                        break;
                    case 'call':
                        window.open('tel:' + action.value);
                        break;
                    case 'openUrl':
                        window.open(action.value);
                        break;
                    default:
                        break;
                }
                _this.newMsgComp.focusInput();
            }
        };
        validatePackage(packageMetadata);
        _this.state = { selectedItemIndex: null, isFirstRender: true };
        return _this;
    }
    /**
     * @hidden
     */
    Chat.prototype.render = function () {
        var _this = this;
        this.viewItems = this.getViewItemsFromMsgs(this.props.messages);
        this.isDirectionRightToLeft = this.checkIsDirectionRightToLeft(this.props);
        var localizationService = provideLocalizationService(this);
        return (React.createElement("div", { style: { width: this.props.width }, onKeyDown: this.onKeyDown, className: this.getClassNames(), ref: function (el) { return _this.chatWrapperEl = el; } },
            React.createElement("div", { className: "k-message-list k-avatars", onBlur: this.onBlur, onFocus: this.onFocus, role: "log", "aria-label": localizationService.toLanguageString(ariaLabelMessageList, messages[ariaLabelMessageList]), "aria-live": "polite", onScroll: function (e) {
                    _this.scrollToBottomOnLoadingData =
                        (e.currentTarget.scrollTop === e.currentTarget.scrollHeight - e.currentTarget.clientHeight);
                }, ref: function (el) { return _this.viewItemsWrapperEl = el; } },
                React.createElement("div", { className: "k-message-list-content" }, this.renderViewItems())),
            React.createElement(NewMessage, { user: this.props.user, onMessageSend: this.onMessageSend, isDirectionRightToLeft: this.isDirectionRightToLeft, ref: function (comp) { return _this.newMsgComp = comp; }, placeholder: this.props.placeholder, MessageBox: this.props.messageBox, toolbar: this.props.toolbar, onToolbarActionButtonClick: this.props.onToolbarActionExecute, showToolbar: this.props.showToolbar })));
    };
    /**
     * @hidden
     */
    Chat.prototype.componentDidMount = function () {
        var _this = this;
        this.setState({ isFirstRender: false }, function () {
            // W/o window.setTimeout the scrolling does not manage to go to the bottom, some offset is left.
            _this.nextTickId = window.setTimeout(function () { return _this.scrollViewItemsToBottom(); }, 250);
        });
    };
    /**
     * @hidden
     */
    Chat.prototype.componentWillUnmount = function () {
        clearTimeout(this.nextTickId);
    };
    /**
     * @hidden
     */
    Chat.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.messages.length !== this.props.messages.length && this.scrollToBottomOnLoadingData) {
            this.scrollViewItemsToBottom();
        }
    };
    Chat.prototype.getClassNames = function () {
        return classNames('k-widget', 'k-chat', this.props.className, { 'k-rtl': this.isDirectionRightToLeft });
    };
    Chat.prototype.checkIsDirectionRightToLeft = function (props) {
        var result = props.dir !== undefined ? props.dir === 'rtl' :
            this.chatWrapperEl && getComputedStyle(this.chatWrapperEl).direction === 'rtl';
        return Boolean(result);
    };
    Chat.prototype.renderViewItems = function () {
        var _this = this;
        var lastViewItemIndex = this.viewItems.length - 1;
        return this.viewItems
            .map(function (viewItem, index) {
            if (viewItem.type === 'date-marker') {
                return React.createElement(DateMarker, { item: viewItem, key: index });
            }
            else if (viewItem.type === 'message-group') {
                return (React.createElement(MessageGroup, { group: viewItem, itemTemplate: _this.props.messageTemplate, attachmentTemplate: _this.props.attachmentTemplate, user: _this.props.user, selectedItemIndex: _this.state.selectedItemIndex, onRequestSelection: _this.onSelectionRequested, isLastGroup: index === lastViewItemIndex, key: index, message: _this.props.message || Chat.defaultProps.message }));
            }
            else if (viewItem.type === 'attachment-group') {
                return (React.createElement(AttachmentGroup, { group: viewItem, itemTemplate: _this.props.attachmentTemplate, onRequestSelection: _this.onSelectionRequested, selected: viewItem.selectionIndex === _this.state.selectedItemIndex, isLastGroup: index === lastViewItemIndex, key: index }));
            }
            else if (viewItem.type === 'action-group') {
                return (React.createElement(ActionGroup, { group: viewItem, onActionExecute: _this.onActionExecute, onRequestSelection: _this.onSelectionRequested, selected: viewItem.selectionIndex === _this.state.selectedItemIndex, isLastGroup: index === lastViewItemIndex, key: index }));
            }
        });
    };
    Chat.prototype.scrollViewItemsToBottom = function () {
        if (this.viewItemsWrapperEl) {
            this.viewItemsWrapperEl.scrollTop =
                this.viewItemsWrapperEl.scrollHeight - this.viewItemsWrapperEl.clientHeight;
        }
    };
    Chat.prototype.getViewItemsFromMsgs = function (msgs) {
        return msgs.length > 0 ? convertMsgsToViewItems(msgs) : [];
    };
    /**
     * @hidden
     */
    Chat.propTypes = {
        messages: PropTypes.arrayOf(PropTypes.object),
        user: PropTypes.object,
        messageTemplate: PropTypes.any,
        attachmentTemplate: PropTypes.any,
        width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        onMessageSend: PropTypes.func,
        onActionExecute: PropTypes.func,
        dir: PropTypes.string,
        messageBox: PropTypes.any
    };
    /**
     * @hidden
     */
    Chat.defaultProps = {
        messages: [],
        dateFormat: 'g',
        message: ChatMessage
    };
    return Chat;
}(React.Component));
export { Chat };
