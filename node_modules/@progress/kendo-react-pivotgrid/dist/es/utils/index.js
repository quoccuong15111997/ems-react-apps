var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { toColumns, toData, toRows, toTree } from '@progress/kendo-pivotgrid-common';
/**
 * Generates suitable data for Charting visualization.
 *
 * @param rows - The PivotGrid's rows prop.
 * @param columns - The PivotGrid's columns prop.
 * @param data - The PivotGrid's data prop.
 * @returns - Suitable data for Charting visualization.
 */
export var dataCells = function (rows, columns, data) {
    var pRows = JSON.parse(JSON.stringify(rows || []));
    var pColumns = JSON.parse(JSON.stringify(columns || []));
    var pData = JSON.parse(JSON.stringify(data || []));
    var rowsTree = toTree(pRows);
    var _a = toRows(rowsTree), rowHeaderLeafs = _a[1], rowHeaderDepth = _a[2];
    var columnsTree = toTree(pColumns);
    var _b = toColumns(columnsTree), columnHeaderLeafs = _b[1], columnHeaderBreadth = _b[3];
    return toData(pData, columnHeaderLeafs, rowHeaderLeafs, columnHeaderBreadth, rowHeaderDepth);
};
/**
 * @hidden
 */
export var recursiveMap = function (nodes, map, parent) {
    if (nodes === void 0) { nodes = []; }
    if (map === void 0) { map = {}; }
    if (parent === void 0) { parent = null; }
    return nodes.map(function (node) {
        var result = { dataItem: node };
        Object.keys(map).forEach(function (key) {
            result[key] = map[key](result, parent);
        });
        return result;
    });
};
/**
 * @hidden
 */
export var flatMap = function (nodes) {
    if (nodes === void 0) { nodes = []; }
    var result = __spreadArray([], nodes, true);
    (nodes || []).forEach(function (child) {
        result = result.concat(flatMap(child.children));
    });
    return result;
};
/**
 * @hidden
 */
export var extractDefaultFields = function (columns) {
    if (columns === void 0) { columns = []; }
    var result = new Set();
    columns.forEach(function (column) {
        result.add(String(column.name));
    });
    return Array.from(result);
};
/**
 * @hidden
 */
export var generateKey = function (args) {
    if (args === void 0) { args = []; }
    return "".concat(args.join(','));
};
/**
 * @hidden
 */
export var generateDataKey = function (rows, columns) { return "".concat(generateKey(rows.map(function (m) { return m.name; })), "|").concat(generateKey(columns.map(function (m) { return m.name; }))); };
/**
 * @hidden
 */
export var findFilter = function (filter, member, operator) {
    if (!filter) {
        return;
    }
    var idx = 0;
    var result;
    var length = filter.length;
    var filterOperator;
    for (; idx < length; idx++) {
        filterOperator = filter[idx].operator;
        if (((!operator && filterOperator !== 'in') || (filterOperator === operator)) && filter[idx].field === member) {
            result = (filter[idx]);
        }
    }
    return result;
};
/**
 * @hidden
 */
export var findFilters = function (filter, member, operator) {
    if (!filter) {
        return [];
    }
    var idx = 0;
    var result = [];
    var length = filter.length;
    var filterOperator;
    for (; idx < length; idx++) {
        filterOperator = filter[idx].operator;
        if (((!operator && filterOperator !== 'in') || (filterOperator === operator)) && filter[idx].field === member) {
            result.push(filter[idx]);
        }
    }
    return result;
};
/**
 * @hidden
 */
export var compareFields = function (a, b) { return a.uniqueName === b.uniqueName; };
