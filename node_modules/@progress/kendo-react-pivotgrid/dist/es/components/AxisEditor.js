var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import { compareAxes } from '@progress/kendo-pivotgrid-common';
import { useDraggable, useCustomComponent, canUseRef } from '@progress/kendo-react-common';
import { ColumnMenuTextColumn as KendoReactColumnMenuTextColumn, ColumnMenuTextFilter } from '@progress/kendo-react-data-tools';
import { Chip as KendoReactChip } from '@progress/kendo-react-buttons';
import { findFilters, findFilter } from '../utils';
import { PIVOT_CONFIGURATOR_ACTION } from '../hooks/';
import { PivotGridConfiguratorEditorStateContext } from '../shared';
import { PivotGridConfiguratorEditorAxesContext } from './AxesEditor';
import { PivotGridAxisFilterFieldsEditor } from './AxisFilterFieldsEditor';
/**
 * Represents the [KendoReact PivotGridAxisEditor component]({% slug api_pivotgrid_pivotgridaxiseditorprops %}).
 */
export var PivotGridAxisEditor = React.forwardRef(function (props, ref) {
    var initialX = React.useRef(0);
    var initialY = React.useRef(0);
    var chip = React.useRef(null);
    var element = React.useRef(null);
    var target = React.useRef(null);
    var axes = React.useContext(PivotGridConfiguratorEditorAxesContext).axes;
    var _a = React.useState(false), drag = _a[0], setDrag = _a[1];
    var _b = React.useContext(PivotGridConfiguratorEditorStateContext), state = _b[0], dispatchState = _b[1];
    React.useImperativeHandle(element, function () { return chip.current && chip.current.element; });
    React.useImperativeHandle(target, function () { return ({ props: props, element: element.current }); });
    React.useImperativeHandle(ref, function () { return target.current; });
    var _c = useCustomComponent(props.chip || defaultProps.chip), ChipComponent = _c[0], ChipProps = _c[1];
    var _d = useCustomComponent(props.dropClue || defaultProps.dropClue), DropClueComponent = _d[0], DropClueProps = _d[1];
    var _e = useCustomComponent(props.columnMenuTextColumn || defaultProps.columnMenuTextColumn), ColumnMenuTextColumnComponent = _e[0], ColumnMenuTextColumnProps = _e[1];
    var _f = useCustomComponent(props.filterFieldsEditor || defaultProps.filterFieldsEditor), FilterFieldsEditorComponent = _f[0], FilterFieldsEditorProps = _f[1];
    var inFilter = findFilters(state.filter, String(props.value), 'in');
    var textFilter = findFilters(state.filter, String(props.value));
    var handleSortChange = function (syntheticEvent, sort) {
        dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setSort, payload: sort }, syntheticEvent);
    };
    var handleFilterChange = function (syntheticEvent, filter) {
        if (filter.length) {
            dispatchState({
                type: PIVOT_CONFIGURATOR_ACTION.setFilter,
                payload: __spreadArray(__spreadArray([], (inFilter || []), true), filter.reduce(function (acc, current) { return __spreadArray(__spreadArray([], acc, true), current.filters.filter(function (f) { return f.value; }), true); }, []), true)
            }, syntheticEvent);
        }
        else {
            dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setFilter, payload: inFilter }, syntheticEvent);
        }
    };
    var handleRemove = function (event) {
        dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.remove, payload: props.dataItem }, event.syntheticEvent);
    };
    var customRender = function (children) {
        var customizedChildren = children.slice();
        var filter = findFilter(state.filter, String(props.dataItem.name), 'in');
        customizedChildren.splice(1, 0, (React.createElement(FilterFieldsEditorComponent, __assign({ key: 'axis-filter-fields-editor', defaultFilter: filter, dataItem: props.dataItem, data: props.dataItem.fields, axes: axes }, FilterFieldsEditorProps))));
        return customizedChildren;
    };
    var handlePress = function (event) {
        initialX.current = event.clientX;
        initialY.current = event.clientY;
    };
    var handleDrag = function (event) {
        if (Math.abs(initialX.current - event.clientX) < 10 &&
            Math.abs(initialY.current - event.clientY) < 10) {
            return;
        }
        if (element.current) {
            element.current.style.transform = "translate(".concat(event.clientX - initialX.current, "px, ").concat(event.clientY - initialY.current, "px)");
        }
        setDrag(true);
        dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setDragItem, payload: props.dataItem });
    };
    var handleRelease = function () {
        setDrag(false);
        if (state.dragItem) {
            if (element.current) {
                element.current.style.transform = '';
            }
            dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.drop, payload: props.dataItem });
        }
    };
    var handleMouseEnter = function (event) {
        if (state.dragItem) {
            dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setDropTarget, payload: props.dataItem }, event.syntheticEvent);
            dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setDropZone, payload: axes }, event.syntheticEvent);
        }
    };
    var handleMouseMove = function (event) {
        if (state.dragItem && !drag) {
            if (element.current) {
                var rect = element.current.getBoundingClientRect();
                var x = event.syntheticEvent.clientX - rect.left;
                var direction = x < rect.width / 2 ? 'before' : 'after';
                dispatchState({ type: PIVOT_CONFIGURATOR_ACTION.setDropDirection, payload: direction }, event.syntheticEvent);
            }
        }
    };
    useDraggable(element, {
        onPress: handlePress,
        onDrag: handleDrag,
        onRelease: handleRelease
    });
    return (React.createElement(React.Fragment, null,
        (state.dropTarget && compareAxes(state.dropTarget, props.dataItem) && state.dropDirection === 'before')
            && (React.createElement(DropClueComponent, __assign({}, DropClueProps))),
        React.createElement(ChipComponent, __assign({ ref: canUseRef(ChipComponent) ? chip : undefined }, props, { removable: true, onRemove: handleRemove, onMouseEnter: handleMouseEnter, onMouseMove: handleMouseMove, style: { pointerEvents: drag ? 'none' : undefined }, rounded: 'full' }, ChipProps),
            props.text,
            (axes !== 'measureAxes') && (React.createElement(ColumnMenuTextColumnComponent, __assign({ field: String(props.value), itemsRender: customRender, sort: state.sort, onSortChange: handleSortChange, filter: (textFilter && textFilter.length) ? [{ logic: 'and', filters: textFilter }] : undefined, onFilterChange: handleFilterChange, filterContent: [
                    ColumnMenuTextFilter
                ] }, ColumnMenuTextColumnProps)))),
        (state.dropTarget && compareAxes(state.dropTarget, props.dataItem) && state.dropDirection === 'after')
            && (React.createElement(DropClueComponent, __assign({}, DropClueProps)))));
});
var defaultProps = {
    chip: KendoReactChip,
    columnMenuTextColumn: KendoReactColumnMenuTextColumn,
    filterFieldsEditor: PivotGridAxisFilterFieldsEditor,
    dropClue: function (props) { return React.createElement("div", __assign({ className: "k-grouping-dropclue", style: { position: 'relative', zIndex: 10000 } }, props)); }
};
PivotGridAxisEditor.defaultProps = defaultProps;
PivotGridAxisEditor.displayName = 'KendoReactPivotGridAxisEditor';
