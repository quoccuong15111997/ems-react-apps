"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareFields = exports.findFilters = exports.findFilter = exports.generateDataKey = exports.generateKey = exports.extractDefaultFields = exports.flatMap = exports.recursiveMap = exports.dataCells = void 0;
var kendo_pivotgrid_common_1 = require("@progress/kendo-pivotgrid-common");
/**
 * Generates suitable data for Charting visualization.
 *
 * @param rows - The PivotGrid's rows prop.
 * @param columns - The PivotGrid's columns prop.
 * @param data - The PivotGrid's data prop.
 * @returns - Suitable data for Charting visualization.
 */
var dataCells = function (rows, columns, data) {
    var pRows = JSON.parse(JSON.stringify(rows || []));
    var pColumns = JSON.parse(JSON.stringify(columns || []));
    var pData = JSON.parse(JSON.stringify(data || []));
    var rowsTree = (0, kendo_pivotgrid_common_1.toTree)(pRows);
    var _a = (0, kendo_pivotgrid_common_1.toRows)(rowsTree), rowHeaderLeafs = _a[1], rowHeaderDepth = _a[2];
    var columnsTree = (0, kendo_pivotgrid_common_1.toTree)(pColumns);
    var _b = (0, kendo_pivotgrid_common_1.toColumns)(columnsTree), columnHeaderLeafs = _b[1], columnHeaderBreadth = _b[3];
    return (0, kendo_pivotgrid_common_1.toData)(pData, columnHeaderLeafs, rowHeaderLeafs, columnHeaderBreadth, rowHeaderDepth);
};
exports.dataCells = dataCells;
/**
 * @hidden
 */
var recursiveMap = function (nodes, map, parent) {
    if (nodes === void 0) { nodes = []; }
    if (map === void 0) { map = {}; }
    if (parent === void 0) { parent = null; }
    return nodes.map(function (node) {
        var result = { dataItem: node };
        Object.keys(map).forEach(function (key) {
            result[key] = map[key](result, parent);
        });
        return result;
    });
};
exports.recursiveMap = recursiveMap;
/**
 * @hidden
 */
var flatMap = function (nodes) {
    if (nodes === void 0) { nodes = []; }
    var result = __spreadArray([], nodes, true);
    (nodes || []).forEach(function (child) {
        result = result.concat((0, exports.flatMap)(child.children));
    });
    return result;
};
exports.flatMap = flatMap;
/**
 * @hidden
 */
var extractDefaultFields = function (columns) {
    if (columns === void 0) { columns = []; }
    var result = new Set();
    columns.forEach(function (column) {
        result.add(String(column.name));
    });
    return Array.from(result);
};
exports.extractDefaultFields = extractDefaultFields;
/**
 * @hidden
 */
var generateKey = function (args) {
    if (args === void 0) { args = []; }
    return "".concat(args.join(','));
};
exports.generateKey = generateKey;
/**
 * @hidden
 */
var generateDataKey = function (rows, columns) { return "".concat((0, exports.generateKey)(rows.map(function (m) { return m.name; })), "|").concat((0, exports.generateKey)(columns.map(function (m) { return m.name; }))); };
exports.generateDataKey = generateDataKey;
/**
 * @hidden
 */
var findFilter = function (filter, member, operator) {
    if (!filter) {
        return;
    }
    var idx = 0;
    var result;
    var length = filter.length;
    var filterOperator;
    for (; idx < length; idx++) {
        filterOperator = filter[idx].operator;
        if (((!operator && filterOperator !== 'in') || (filterOperator === operator)) && filter[idx].field === member) {
            result = (filter[idx]);
        }
    }
    return result;
};
exports.findFilter = findFilter;
/**
 * @hidden
 */
var findFilters = function (filter, member, operator) {
    if (!filter) {
        return [];
    }
    var idx = 0;
    var result = [];
    var length = filter.length;
    var filterOperator;
    for (; idx < length; idx++) {
        filterOperator = filter[idx].operator;
        if (((!operator && filterOperator !== 'in') || (filterOperator === operator)) && filter[idx].field === member) {
            result.push(filter[idx]);
        }
    }
    return result;
};
exports.findFilters = findFilters;
/**
 * @hidden
 */
var compareFields = function (a, b) { return a.uniqueName === b.uniqueName; };
exports.compareFields = compareFields;
