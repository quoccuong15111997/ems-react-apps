"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expandedChildren = exports.hasChildren = exports.isExpanded = exports.getTimelineWidth = exports.getTimelineContent = exports.getTimelineHeader = exports.getYearSlots = exports.getMonthSlots = exports.getWeekSlots = exports.getDaySlots = exports.getHourSlots = exports.toYearRanges = exports.toMonthRanges = exports.toWeekRanges = exports.toRanges = exports.isWorkDay = exports.getWorkDays = exports.addArrowEast = exports.addArrowWest = exports.addArrow = exports.dependencyCoordinates = exports.MIN_LINE_WIDTH = exports.ARROW_SIZE = exports.toUTCDateTime = exports.isInRange = exports.getEndDate = exports.getStartDate = exports.getDependencyModelFields = exports.getTaskModelFields = exports.createDataTree = exports.extendDataItem = exports.mapTree = exports.filterBy = exports.orderBy = void 0;
var React = require("react");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var kendo_date_math_1 = require("@progress/kendo-date-math");
var kendo_react_common_2 = require("@progress/kendo-react-common");
var kendo_react_data_tools_1 = require("@progress/kendo-react-data-tools");
var kendo_react_treelist_1 = require("@progress/kendo-react-treelist");
/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
exports.orderBy = kendo_react_data_tools_1.orderBy;
/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
exports.filterBy = kendo_react_data_tools_1.filterBy;
/**
 * Creates a new array with the results of calling the provided callback function
 * on every element in the provided data tree.
 *
 * @param {any[]} tree - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(value: any) => any} callback - The callback function.
 * @returns {any[]} - The new data tree.
 */
exports.mapTree = kendo_react_common_2.mapTree;
/**
 * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.
 *
 * @param {object} item - The source data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {object} propsToExtend - The props with which the source data item will be extended.
 * @returns {object} - The target data item.
 */
exports.extendDataItem = kendo_react_common_2.extendDataItem;
/**
 * Creates a tree from the passed dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {(item: object) => any} getId - A function which will return the id of the data item.
 * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are structured in a tree.
 */
exports.createDataTree = kendo_react_treelist_1.createDataTree;
var constants_1 = require("../constants");
/** @hidden */
var getTaskModelFields = function (taskModelFields) {
    return { fields: __assign(__assign({}, constants_1.DEFAULT_TASK_MODEL_FIELDS), taskModelFields) };
};
exports.getTaskModelFields = getTaskModelFields;
/** @hidden */
var getDependencyModelFields = function (dependencyModelFields) {
    return { fields: __assign(__assign({}, constants_1.DEFAULT_DEPENDENCY_MODEL_FIELDS), dependencyModelFields) };
};
exports.getDependencyModelFields = getDependencyModelFields;
/** @hidden */
var getStartDate = function (date) { return (0, kendo_date_math_1.getDate)(date); };
exports.getStartDate = getStartDate;
/** @hidden */
var getEndDate = function (date, numberOfDays) { return (0, kendo_date_math_1.getDate)((0, kendo_date_math_1.addDays)(date, numberOfDays || 1)); };
exports.getEndDate = getEndDate;
/** @hidden */
var isInRange = function (slotStart, slotEnd, taskStart, taskEnd) { return taskStart < slotEnd && slotStart <= taskEnd; };
exports.isInRange = isInRange;
/** @hidden */
function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
exports.toUTCDateTime = toUTCDateTime;
/** @hidden */
exports.ARROW_SIZE = 4;
/** @hidden */
exports.MIN_LINE_WIDTH = 10;
/** @hidden */
// 0 - Finish-Finish
// 1 - Finish-Start
// 2 - Start-Finish
// 3 - Start-Start
var dependencyCoordinates = function (from, to, rowHeight, type) {
    var points = [];
    var currentTop = 0;
    var currentLeft = 0;
    var minTurnWidth = exports.MIN_LINE_WIDTH;
    var minTurnHeight = Math.floor(rowHeight / 2);
    var drawingDown = from.top < to.top;
    var addPoint = function () { return points.push({ left: currentLeft, top: currentTop }); };
    if (type === 0 || type === 3) {
        var dir = type === 3 ? 'start' : 'end';
        currentTop = from.top;
        currentLeft = from[dir];
        addPoint();
        currentLeft = Math[dir === 'start' ? 'min' : 'max'](from[dir], to[dir]);
        currentLeft = dir === 'start' ? currentLeft - minTurnWidth : currentLeft + minTurnWidth;
        addPoint();
        currentTop = to.top;
        addPoint();
        currentLeft = dir === 'start' ? to[dir] - exports.ARROW_SIZE : to[dir] + exports.ARROW_SIZE;
        addPoint();
        (0, exports.addArrow)(currentTop, currentLeft, points, dir !== 'start');
    }
    else {
        var startDir = type === 2 ? 'start' : 'end';
        var endDir = type === 2 ? 'end' : 'start';
        var simpleLine = type === 2 ?
            from[startDir] - (exports.MIN_LINE_WIDTH * 2) >= to[endDir] :
            from[startDir] + (exports.MIN_LINE_WIDTH * 2) <= to[endDir];
        currentTop = from.top;
        currentLeft = from[startDir];
        addPoint();
        currentLeft = startDir === 'start' ? currentLeft - minTurnWidth : currentLeft + minTurnWidth;
        addPoint();
        if (!simpleLine) {
            currentTop = drawingDown ? currentTop + minTurnHeight : currentTop - minTurnHeight;
            addPoint();
            currentLeft = startDir === 'start' ? to[endDir] + minTurnWidth : to[endDir] - minTurnWidth;
            addPoint();
        }
        currentTop = to.top;
        addPoint();
        currentLeft = endDir === 'start' ? to[endDir] - exports.ARROW_SIZE : to[endDir] + exports.ARROW_SIZE;
        addPoint();
        (0, exports.addArrow)(currentTop, currentLeft, points, endDir !== 'start');
    }
    return points;
};
exports.dependencyCoordinates = dependencyCoordinates;
/** @hidden */
var addArrow = function (top, left, points, isArrowWest) {
    return isArrowWest ? (0, exports.addArrowWest)(top, left, points) : (0, exports.addArrowEast)(top, left, points);
};
exports.addArrow = addArrow;
/** @hidden */
var addArrowWest = function (top, left, points) {
    points.push({
        top: top - (exports.ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left - exports.ARROW_SIZE + 1
    });
    points.push({
        top: top + (exports.ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left
    });
};
exports.addArrowWest = addArrowWest;
/** @hidden */
var addArrowEast = function (top, left, points) {
    points.push({
        top: top + (exports.ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left + exports.ARROW_SIZE - 1
    });
    points.push({
        top: top - (exports.ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left
    });
};
exports.addArrowEast = addArrowEast;
/**
 * @hidden
 */
var getWorkDays = function (options) {
    if (options.workWeekStart === undefined || options.workWeekEnd === undefined) {
        return [];
    }
    var workDays = [];
    var dayIndex = options.workWeekStart;
    workDays.push(dayIndex);
    while (options.workWeekEnd !== dayIndex) {
        if (dayIndex > 6) {
            dayIndex -= 7;
        }
        else {
            dayIndex++;
        }
        workDays.push(dayIndex);
    }
    return workDays;
};
exports.getWorkDays = getWorkDays;
/**
 * @hidden
 */
var isWorkDay = function (date, workDays) {
    var day = date.getDay();
    return workDays.indexOf(day) > -1;
};
exports.isWorkDay = isWorkDay;
/**
 * @hidden
 */
var toRanges = function (dateRange, _a) {
    var step = _a.step, timezone = _a.timezone;
    var ranges = [];
    // TODO: not sure we need this conversion here and in Scheduler when dateRange already contains zoned dates
    var zonedRangeStart = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.end, timezone);
    var current = zonedRangeStart.clone();
    while (current.getTime() < zonedRangeEnd.getTime()) {
        var zonedStart = current.clone();
        var zonedEnd = zonedStart.clone().addTime(step);
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
        current = current.addTime(step);
    }
    return ranges;
};
exports.toRanges = toRanges;
/**
 * @hidden
 */
var toWeekRanges = function (dateRange, _a, intl) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var endCandidate = (0, exports.getEndDate)((0, kendo_date_math_1.firstDayInWeek)((0, kendo_date_math_1.getDate)(zonedStart), intl.firstDay()), constants_1.DAYS_IN_WEEK_COUNT);
        var zonedEndCandidate = kendo_date_math_1.ZonedDate.fromUTCDate(toUTCDateTime(endCandidate), timezone);
        var zonedEnd = zonedEndCandidate.getTime() > zonedRangeEnd.getTime() ? zonedRangeEnd.clone() : zonedEndCandidate;
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
exports.toWeekRanges = toWeekRanges;
/**
 * @hidden
 */
var toMonthRanges = function (dateRange, _a) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var zonedEnd = kendo_date_math_1.ZonedDate.fromLocalDate((0, kendo_date_math_1.addMonths)(new Date(zonedStart.getTime()), 1), timezone);
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
exports.toMonthRanges = toMonthRanges;
/**
 * @hidden
 */
var toYearRanges = function (dateRange, _a) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = kendo_date_math_1.ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var zonedEnd = kendo_date_math_1.ZonedDate.fromLocalDate((0, kendo_date_math_1.addMonths)(new Date(zonedStart.getTime()), 12), timezone);
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
exports.toYearRanges = toYearRanges;
/**
 * @hidden
 */
var getHourSlots = function (range, options, intl) {
    var workDayStart = intl.parseDate(options.workDayStart).getHours();
    var workDayEnd = intl.parseDate(options.workDayEnd).getHours();
    var ranges = (0, exports.toRanges)(range, { step: kendo_date_math_1.MS_PER_MINUTE * options.slotDuration, timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var hours = currentRange.zonedStart.getHours();
        return {
            range: currentRange,
            isWork: hours >= workDayStart && hours < workDayEnd,
            span: 1,
            text: intl.formatDate(currentRange.zonedStart, constants_1.HOUR_DATE_FORMAT),
            type: 'time'
        };
    });
};
exports.getHourSlots = getHourSlots;
/**
 * @hidden
 */
var getDaySlots = function (range, options, intl) {
    var ranges = (0, exports.toRanges)(range, { step: constants_1.MS_PER_DAY, timezone: options.timezone });
    return ranges.map(function (currentRange) {
        return {
            range: currentRange,
            isWork: (0, exports.isWorkDay)(currentRange.start, options.workDays),
            span: 1,
            text: intl.formatDate(currentRange.zonedStart, constants_1.DAY_DATE_FORMAT),
            type: 'day'
        };
    });
};
exports.getDaySlots = getDaySlots;
/**
 * @hidden
 */
var getWeekSlots = function (range, options, intl) {
    var ranges = (0, exports.toWeekRanges)(range, { timezone: options.timezone }, intl);
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / constants_1.MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: "".concat(intl.formatDate(currentRange.zonedStart, constants_1.DAY_DATE_FORMAT), " - ").concat(intl.formatDate(currentRange.zonedEnd, constants_1.DAY_DATE_FORMAT)),
            type: 'week'
        };
    });
};
exports.getWeekSlots = getWeekSlots;
/**
 * @hidden
 */
var getMonthSlots = function (range, options, intl) {
    var ranges = (0, exports.toMonthRanges)(range, { timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / constants_1.MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: intl.formatDate(currentRange.zonedStart, constants_1.MONTH_DATE_FORMAT),
            type: 'month'
        };
    });
};
exports.getMonthSlots = getMonthSlots;
/**
 * @hidden
 */
var getYearSlots = function (range, options, intl) {
    var ranges = (0, exports.toYearRanges)(range, { timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / constants_1.MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: intl.formatDate(currentRange.zonedStart, constants_1.YEAR_DATE_FORMAT),
            type: 'year'
        };
    });
};
exports.getYearSlots = getYearSlots;
/**
 * @hidden
 */
var getTimelineHeader = function (slotLevels, ref, timelineHeaderCell) {
    var HeaderCell = timelineHeaderCell;
    return (React.createElement("table", { className: 'k-table k-table-md', ref: ref, "aria-hidden": true },
        React.createElement("tbody", { className: 'k-table-tbody' }, slotLevels.map(function (slotLevel, slotLevelIdx) { return (React.createElement("tr", { className: 'k-table-row', key: slotLevelIdx }, slotLevel.map(function (slot, slotIndex) { return (React.createElement("td", { key: slot.range.start.getTime(), colSpan: slot.span, className: (0, kendo_react_common_1.classNames)('k-table-th', {
                'k-header': true,
                'k-nonwork-hour': !slot.isWork
            }) }, HeaderCell ?
            (React.createElement(HeaderCell, { rowIndex: slotLevelIdx, index: slotIndex, range: slot.range, text: slot.text, isWork: slot.isWork, type: slot.type })) : slot.text)); }))); }))));
};
exports.getTimelineHeader = getTimelineHeader;
/**
 * @hidden
 */
var getTimelineContent = function (slotLevels, ref) {
    var lastSlotLevel = slotLevels[slotLevels.length - 1];
    return (React.createElement("table", { className: 'k-table k-table-md k-gantt-columns', ref: ref, "aria-hidden": true },
        React.createElement("tbody", { className: 'k-table-tbody' },
            React.createElement("tr", { className: 'k-table-row' }, lastSlotLevel.map(function (slot) { return (React.createElement("td", { key: slot.range.start.getTime(), colSpan: slot.span, className: (0, kendo_react_common_1.classNames)('k-table-td', {
                    'k-nonwork-hour': !slot.isWork
                }) })); })))));
};
exports.getTimelineContent = getTimelineContent;
/**
 * @hidden
 */
var getTimelineWidth = function (slotLevels, slotWidth) {
    var lastSlotLevel = slotLevels[slotLevels.length - 1];
    var maxSpan = 0;
    var totalSpan = 0;
    lastSlotLevel.forEach(function (slot) {
        var currentSpan = slot.span;
        totalSpan += currentSpan;
        if (currentSpan > maxSpan) {
            maxSpan = currentSpan;
        }
    });
    return Math.round((totalSpan * slotWidth) / maxSpan);
};
exports.getTimelineWidth = getTimelineWidth;
/**
 * @hidden
 */
var isExpanded = function (dataItem, expandedField) { return Boolean((0, kendo_react_common_1.getter)(expandedField)(dataItem)); };
exports.isExpanded = isExpanded;
/**
 * @hidden
 */
var hasChildren = function (dataItem, childrenField) { return Boolean((0, kendo_react_common_1.getter)(childrenField)(dataItem)); };
exports.hasChildren = hasChildren;
/**
 * @hidden
 */
var expandedChildren = function (expandedField, childrenField) { return function (dataItem) {
    if ((0, exports.isExpanded)(dataItem, expandedField) && (0, exports.hasChildren)(dataItem, childrenField)) {
        return __spreadArray([], (0, kendo_react_common_1.getter)(childrenField)(dataItem), true);
    }
    return [];
}; };
exports.expandedChildren = expandedChildren;
