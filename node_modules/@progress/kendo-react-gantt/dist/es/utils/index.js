var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import { classNames, getter } from '@progress/kendo-react-common';
import { getDate, addDays, ZonedDate, addMonths, firstDayInWeek, MS_PER_MINUTE } from '@progress/kendo-date-math';
import { mapTree as mapTreeCommon, extendDataItem as extendDataItemCommon } from '@progress/kendo-react-common';
import { filterBy as filterByCommon, orderBy as orderByCommon } from '@progress/kendo-react-data-tools';
import { createDataTree as treeListCreateDataTree } from '@progress/kendo-react-treelist';
/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
export var orderBy = orderByCommon;
/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
export var filterBy = filterByCommon;
/**
 * Creates a new array with the results of calling the provided callback function
 * on every element in the provided data tree.
 *
 * @param {any[]} tree - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(value: any) => any} callback - The callback function.
 * @returns {any[]} - The new data tree.
 */
export var mapTree = mapTreeCommon;
/**
 * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.
 *
 * @param {object} item - The source data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {object} propsToExtend - The props with which the source data item will be extended.
 * @returns {object} - The target data item.
 */
export var extendDataItem = extendDataItemCommon;
/**
 * Creates a tree from the passed dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {(item: object) => any} getId - A function which will return the id of the data item.
 * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are structured in a tree.
 */
export var createDataTree = treeListCreateDataTree;
import { HOUR_DATE_FORMAT, DAY_DATE_FORMAT, MS_PER_DAY, DAYS_IN_WEEK_COUNT, MONTH_DATE_FORMAT, DEFAULT_TASK_MODEL_FIELDS, DEFAULT_DEPENDENCY_MODEL_FIELDS, YEAR_DATE_FORMAT } from '../constants';
/** @hidden */
export var getTaskModelFields = function (taskModelFields) {
    return { fields: __assign(__assign({}, DEFAULT_TASK_MODEL_FIELDS), taskModelFields) };
};
/** @hidden */
export var getDependencyModelFields = function (dependencyModelFields) {
    return { fields: __assign(__assign({}, DEFAULT_DEPENDENCY_MODEL_FIELDS), dependencyModelFields) };
};
/** @hidden */
export var getStartDate = function (date) { return getDate(date); };
/** @hidden */
export var getEndDate = function (date, numberOfDays) { return getDate(addDays(date, numberOfDays || 1)); };
/** @hidden */
export var isInRange = function (slotStart, slotEnd, taskStart, taskEnd) { return taskStart < slotEnd && slotStart <= taskEnd; };
/** @hidden */
export function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
/** @hidden */
export var ARROW_SIZE = 4;
/** @hidden */
export var MIN_LINE_WIDTH = 10;
/** @hidden */
// 0 - Finish-Finish
// 1 - Finish-Start
// 2 - Start-Finish
// 3 - Start-Start
export var dependencyCoordinates = function (from, to, rowHeight, type) {
    var points = [];
    var currentTop = 0;
    var currentLeft = 0;
    var minTurnWidth = MIN_LINE_WIDTH;
    var minTurnHeight = Math.floor(rowHeight / 2);
    var drawingDown = from.top < to.top;
    var addPoint = function () { return points.push({ left: currentLeft, top: currentTop }); };
    if (type === 0 || type === 3) {
        var dir = type === 3 ? 'start' : 'end';
        currentTop = from.top;
        currentLeft = from[dir];
        addPoint();
        currentLeft = Math[dir === 'start' ? 'min' : 'max'](from[dir], to[dir]);
        currentLeft = dir === 'start' ? currentLeft - minTurnWidth : currentLeft + minTurnWidth;
        addPoint();
        currentTop = to.top;
        addPoint();
        currentLeft = dir === 'start' ? to[dir] - ARROW_SIZE : to[dir] + ARROW_SIZE;
        addPoint();
        addArrow(currentTop, currentLeft, points, dir !== 'start');
    }
    else {
        var startDir = type === 2 ? 'start' : 'end';
        var endDir = type === 2 ? 'end' : 'start';
        var simpleLine = type === 2 ?
            from[startDir] - (MIN_LINE_WIDTH * 2) >= to[endDir] :
            from[startDir] + (MIN_LINE_WIDTH * 2) <= to[endDir];
        currentTop = from.top;
        currentLeft = from[startDir];
        addPoint();
        currentLeft = startDir === 'start' ? currentLeft - minTurnWidth : currentLeft + minTurnWidth;
        addPoint();
        if (!simpleLine) {
            currentTop = drawingDown ? currentTop + minTurnHeight : currentTop - minTurnHeight;
            addPoint();
            currentLeft = startDir === 'start' ? to[endDir] + minTurnWidth : to[endDir] - minTurnWidth;
            addPoint();
        }
        currentTop = to.top;
        addPoint();
        currentLeft = endDir === 'start' ? to[endDir] - ARROW_SIZE : to[endDir] + ARROW_SIZE;
        addPoint();
        addArrow(currentTop, currentLeft, points, endDir !== 'start');
    }
    return points;
};
/** @hidden */
export var addArrow = function (top, left, points, isArrowWest) {
    return isArrowWest ? addArrowWest(top, left, points) : addArrowEast(top, left, points);
};
/** @hidden */
export var addArrowWest = function (top, left, points) {
    points.push({
        top: top - (ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left - ARROW_SIZE + 1
    });
    points.push({
        top: top + (ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left
    });
};
/** @hidden */
export var addArrowEast = function (top, left, points) {
    points.push({
        top: top + (ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left + ARROW_SIZE - 1
    });
    points.push({
        top: top - (ARROW_SIZE / 2),
        left: left
    });
    points.push({
        top: top,
        left: left
    });
};
/**
 * @hidden
 */
export var getWorkDays = function (options) {
    if (options.workWeekStart === undefined || options.workWeekEnd === undefined) {
        return [];
    }
    var workDays = [];
    var dayIndex = options.workWeekStart;
    workDays.push(dayIndex);
    while (options.workWeekEnd !== dayIndex) {
        if (dayIndex > 6) {
            dayIndex -= 7;
        }
        else {
            dayIndex++;
        }
        workDays.push(dayIndex);
    }
    return workDays;
};
/**
 * @hidden
 */
export var isWorkDay = function (date, workDays) {
    var day = date.getDay();
    return workDays.indexOf(day) > -1;
};
/**
 * @hidden
 */
export var toRanges = function (dateRange, _a) {
    var step = _a.step, timezone = _a.timezone;
    var ranges = [];
    // TODO: not sure we need this conversion here and in Scheduler when dateRange already contains zoned dates
    var zonedRangeStart = ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = ZonedDate.fromLocalDate(dateRange.end, timezone);
    var current = zonedRangeStart.clone();
    while (current.getTime() < zonedRangeEnd.getTime()) {
        var zonedStart = current.clone();
        var zonedEnd = zonedStart.clone().addTime(step);
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
        current = current.addTime(step);
    }
    return ranges;
};
/**
 * @hidden
 */
export var toWeekRanges = function (dateRange, _a, intl) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var endCandidate = getEndDate(firstDayInWeek(getDate(zonedStart), intl.firstDay()), DAYS_IN_WEEK_COUNT);
        var zonedEndCandidate = ZonedDate.fromUTCDate(toUTCDateTime(endCandidate), timezone);
        var zonedEnd = zonedEndCandidate.getTime() > zonedRangeEnd.getTime() ? zonedRangeEnd.clone() : zonedEndCandidate;
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
/**
 * @hidden
 */
export var toMonthRanges = function (dateRange, _a) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var zonedEnd = ZonedDate.fromLocalDate(addMonths(new Date(zonedStart.getTime()), 1), timezone);
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
/**
 * @hidden
 */
export var toYearRanges = function (dateRange, _a) {
    var timezone = _a.timezone;
    var ranges = [];
    var zonedRangeStart = ZonedDate.fromLocalDate(dateRange.start, timezone);
    var zonedRangeEnd = ZonedDate.fromLocalDate(dateRange.end, timezone);
    for (var current = zonedRangeStart.clone(), index = 0; current.getTime() < zonedRangeEnd.getTime(); index++) {
        var zonedStart = current.clone();
        var zonedEnd = ZonedDate.fromLocalDate(addMonths(new Date(zonedStart.getTime()), 12), timezone);
        current = zonedEnd.clone();
        var start = new Date(zonedStart.getTime());
        var end = new Date(zonedEnd.getTime());
        var range = {
            end: end,
            start: start,
            zonedStart: zonedStart,
            zonedEnd: zonedEnd
        };
        ranges.push(range);
    }
    return ranges;
};
/**
 * @hidden
 */
export var getHourSlots = function (range, options, intl) {
    var workDayStart = intl.parseDate(options.workDayStart).getHours();
    var workDayEnd = intl.parseDate(options.workDayEnd).getHours();
    var ranges = toRanges(range, { step: MS_PER_MINUTE * options.slotDuration, timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var hours = currentRange.zonedStart.getHours();
        return {
            range: currentRange,
            isWork: hours >= workDayStart && hours < workDayEnd,
            span: 1,
            text: intl.formatDate(currentRange.zonedStart, HOUR_DATE_FORMAT),
            type: 'time'
        };
    });
};
/**
 * @hidden
 */
export var getDaySlots = function (range, options, intl) {
    var ranges = toRanges(range, { step: MS_PER_DAY, timezone: options.timezone });
    return ranges.map(function (currentRange) {
        return {
            range: currentRange,
            isWork: isWorkDay(currentRange.start, options.workDays),
            span: 1,
            text: intl.formatDate(currentRange.zonedStart, DAY_DATE_FORMAT),
            type: 'day'
        };
    });
};
/**
 * @hidden
 */
export var getWeekSlots = function (range, options, intl) {
    var ranges = toWeekRanges(range, { timezone: options.timezone }, intl);
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: "".concat(intl.formatDate(currentRange.zonedStart, DAY_DATE_FORMAT), " - ").concat(intl.formatDate(currentRange.zonedEnd, DAY_DATE_FORMAT)),
            type: 'week'
        };
    });
};
/**
 * @hidden
 */
export var getMonthSlots = function (range, options, intl) {
    var ranges = toMonthRanges(range, { timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: intl.formatDate(currentRange.zonedStart, MONTH_DATE_FORMAT),
            type: 'month'
        };
    });
};
/**
 * @hidden
 */
export var getYearSlots = function (range, options, intl) {
    var ranges = toYearRanges(range, { timezone: options.timezone });
    return ranges.map(function (currentRange) {
        var span = Math.round((currentRange.zonedEnd.getTime() - currentRange.zonedStart.getTime()) / MS_PER_DAY);
        return {
            range: currentRange,
            isWork: false,
            span: span,
            text: intl.formatDate(currentRange.zonedStart, YEAR_DATE_FORMAT),
            type: 'year'
        };
    });
};
/**
 * @hidden
 */
export var getTimelineHeader = function (slotLevels, ref, timelineHeaderCell) {
    var HeaderCell = timelineHeaderCell;
    return (React.createElement("table", { className: 'k-table k-table-md', ref: ref, "aria-hidden": true },
        React.createElement("tbody", { className: 'k-table-tbody' }, slotLevels.map(function (slotLevel, slotLevelIdx) { return (React.createElement("tr", { className: 'k-table-row', key: slotLevelIdx }, slotLevel.map(function (slot, slotIndex) { return (React.createElement("td", { key: slot.range.start.getTime(), colSpan: slot.span, className: classNames('k-table-th', {
                'k-header': true,
                'k-nonwork-hour': !slot.isWork
            }) }, HeaderCell ?
            (React.createElement(HeaderCell, { rowIndex: slotLevelIdx, index: slotIndex, range: slot.range, text: slot.text, isWork: slot.isWork, type: slot.type })) : slot.text)); }))); }))));
};
/**
 * @hidden
 */
export var getTimelineContent = function (slotLevels, ref) {
    var lastSlotLevel = slotLevels[slotLevels.length - 1];
    return (React.createElement("table", { className: 'k-table k-table-md k-gantt-columns', ref: ref, "aria-hidden": true },
        React.createElement("tbody", { className: 'k-table-tbody' },
            React.createElement("tr", { className: 'k-table-row' }, lastSlotLevel.map(function (slot) { return (React.createElement("td", { key: slot.range.start.getTime(), colSpan: slot.span, className: classNames('k-table-td', {
                    'k-nonwork-hour': !slot.isWork
                }) })); })))));
};
/**
 * @hidden
 */
export var getTimelineWidth = function (slotLevels, slotWidth) {
    var lastSlotLevel = slotLevels[slotLevels.length - 1];
    var maxSpan = 0;
    var totalSpan = 0;
    lastSlotLevel.forEach(function (slot) {
        var currentSpan = slot.span;
        totalSpan += currentSpan;
        if (currentSpan > maxSpan) {
            maxSpan = currentSpan;
        }
    });
    return Math.round((totalSpan * slotWidth) / maxSpan);
};
/**
 * @hidden
 */
export var isExpanded = function (dataItem, expandedField) { return Boolean(getter(expandedField)(dataItem)); };
/**
 * @hidden
 */
export var hasChildren = function (dataItem, childrenField) { return Boolean(getter(childrenField)(dataItem)); };
/**
 * @hidden
 */
export var expandedChildren = function (expandedField, childrenField) { return function (dataItem) {
    if (isExpanded(dataItem, expandedField) && hasChildren(dataItem, childrenField)) {
        return __spreadArray([], getter(childrenField)(dataItem), true);
    }
    return [];
}; };
