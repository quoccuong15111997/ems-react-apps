var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { getter, setter } from '@progress/kendo-react-common';
import { mapTree } from './';
/**
 * @hidden
 */
export var addDependency = function (options) {
    var dependencyData = options.dependencyData, dependencyModelFields = options.dependencyModelFields, defaultDataItem = options.defaultDataItem, fromId = options.fromId, toId = options.toId, type = options.type;
    var dataCopy = dependencyData.map(function (dependency) { return (__assign({}, dependency)); });
    var setFromId = setter(dependencyModelFields.fromId);
    var setToId = setter(dependencyModelFields.toId);
    var setType = setter(dependencyModelFields.type);
    var newDependency = defaultDataItem ? __assign({}, defaultDataItem) : {};
    setFromId(newDependency, fromId);
    setToId(newDependency, toId);
    setType(newDependency, type);
    dataCopy.push(newDependency);
    return dataCopy;
};
/**
 * @hidden
 */
export var addTask = function (options) {
    var _a;
    var defaultDataItem = options.defaultDataItem, selectedDataItem = options.selectedDataItem, direction = options.direction, taskModelFields = options.taskModelFields, dataTree = options.dataTree, slotStart = options.slotStart, slotEnd = options.slotEnd;
    var dataTreeCopy = mapTree(dataTree, taskModelFields.children, function (item) { return (__assign({}, item)); });
    var setStart = setter(taskModelFields.start);
    var setEnd = setter(taskModelFields.end);
    var getStart = getter(taskModelFields.start);
    var getEnd = getter(taskModelFields.end);
    var newTask = defaultDataItem ? __assign({}, defaultDataItem) : {};
    var defaultDatesSet = getStart(newTask) && getEnd(newTask);
    if (!selectedDataItem || direction === 'none') {
        if (!defaultDatesSet) {
            setStart(newTask, slotStart);
            setEnd(newTask, slotEnd);
        }
        dataTreeCopy.unshift(newTask);
    }
    else {
        var stack = [{
                task: (_a = {}, _a[taskModelFields.children] = dataTreeCopy, _a),
                childrenIndex: 0
            }];
        var getId = getter(taskModelFields.id);
        var getChildren = getter(taskModelFields.children);
        var setChildren = setter(taskModelFields.children);
        var selectedTaskId = getId(selectedDataItem);
        while (stack.length > 0) {
            var stackItem = stack[stack.length - 1];
            var task = stackItem.task;
            var taskId = getId(task);
            var children = getChildren(task);
            if (taskId && taskId === selectedTaskId) {
                break;
            }
            if (children && children.length && children.length > stackItem.childrenIndex) {
                stack.push({
                    task: children[stackItem.childrenIndex],
                    childrenIndex: 0
                });
                stackItem.childrenIndex++;
            }
            else {
                stack.pop();
            }
        }
        if (stack.length > 1) {
            var targetTask = stack[stack.length - 1].task;
            var targetIndex = stack[stack.length - 2].childrenIndex;
            var parentStackItem = stack[stack.length - 2];
            var parentTask = parentStackItem.task;
            var parentTaskChildren = getChildren(parentTask);
            switch (direction) {
                case 'child':
                    var targetChildren = getChildren(targetTask);
                    if (!targetChildren) {
                        targetChildren = [];
                        setChildren(targetTask, targetChildren);
                    }
                    if (!defaultDatesSet) {
                        setStart(newTask, new Date(getStart(targetTask).getTime()));
                        setEnd(newTask, new Date(getEnd(targetTask).getTime()));
                    }
                    targetChildren.push(newTask);
                    resolveSummaryFields(stack.splice(1, stack.length - 1).map(function (stackItem) { return stackItem.task; }), taskModelFields);
                    break;
                case 'above':
                    if (getStart(parentTask) && getEnd(parentTask) && !defaultDatesSet) {
                        setStart(newTask, new Date(getStart(targetTask).getTime()));
                        setEnd(newTask, new Date(getEnd(targetTask).getTime()));
                    }
                    else {
                        setStart(newTask, slotStart);
                        setEnd(newTask, slotEnd);
                    }
                    parentTaskChildren.splice(targetIndex - 1, 0, newTask);
                    resolveSummaryFields(stack.splice(1, stack.length - 2).map(function (stackItem) { return stackItem.task; }), taskModelFields);
                    break;
                case 'below':
                    if (getStart(parentTask) && getEnd(parentTask) && !defaultDatesSet) {
                        setStart(newTask, new Date(getStart(targetTask).getTime()));
                        setEnd(newTask, new Date(getEnd(targetTask).getTime()));
                    }
                    else {
                        setStart(newTask, slotStart);
                        setEnd(newTask, slotEnd);
                    }
                    parentTaskChildren.splice(targetIndex, 0, newTask);
                    resolveSummaryFields(stack.splice(1, stack.length - 2).map(function (stackItem) { return stackItem.task; }), taskModelFields);
                    break;
                default:
                    break;
            }
        }
    }
    return dataTreeCopy;
};
/**
 * @hidden
 */
export var updateTask = function (options) {
    var _a;
    var updatedDataItem = options.updatedDataItem, taskModelFields = options.taskModelFields, dataTree = options.dataTree;
    var getId = getter(taskModelFields.id);
    var getChildren = getter(taskModelFields.children);
    var updatedTaskId = getId(updatedDataItem);
    var oldTask;
    var dataTreeCopy = mapTree(dataTree, taskModelFields.children, function (item) {
        if (getId(item) === updatedTaskId) {
            oldTask = item;
            return __assign({}, updatedDataItem);
        }
        return __assign({}, item);
    });
    var stack = [{
            task: (_a = {}, _a[taskModelFields.children] = dataTreeCopy, _a),
            childrenIndex: 0
        }];
    while (stack.length > 0) {
        var stackItem = stack[stack.length - 1];
        var task = stackItem.task;
        var taskId = getId(task);
        var children = getChildren(task);
        if (taskId && taskId === updatedTaskId) {
            break;
        }
        if (children && children.length && children.length > stackItem.childrenIndex) {
            stack.push({
                task: children[stackItem.childrenIndex],
                childrenIndex: 0
            });
            stackItem.childrenIndex++;
        }
        else {
            stack.pop();
        }
    }
    if (stack.length > 1) {
        stack = stack.splice(1, stack.length - 2);
        var getStart = getter(taskModelFields.start);
        var getEnd = getter(taskModelFields.end);
        var getPercentComplete = getter(taskModelFields.percentComplete);
        if (getStart(oldTask).getTime() !== getStart(updatedDataItem).getTime()) {
            resolveSummaryStart(stack.map(function (stackItem) { return stackItem.task; }), taskModelFields);
            var offset = getStart(updatedDataItem).getTime() - getStart(oldTask).getTime();
            offsetChildren(getChildren(updatedDataItem), taskModelFields, offset);
        }
        if (getEnd(oldTask).getTime() !== getEnd(updatedDataItem).getTime()) {
            resolveSummaryEnd(stack.map(function (stackItem) { return stackItem.task; }), taskModelFields);
        }
        if (getPercentComplete(oldTask) !== getPercentComplete(updatedDataItem)) {
            resolveSummaryPercentComplete(stack.map(function (stackItem) { return stackItem.task; }), taskModelFields);
        }
    }
    return dataTreeCopy;
};
/**
 * @hidden
 */
export var removeTask = function (options) {
    var _a;
    var removedDataItem = options.removedDataItem, taskModelFields = options.taskModelFields, dataTree = options.dataTree;
    var dataTreeCopy = mapTree(dataTree, taskModelFields.children, function (item) { return (__assign({}, item)); });
    var stack = [{
            task: (_a = {}, _a[taskModelFields.children] = dataTreeCopy, _a),
            childrenIndex: 0
        }];
    var getId = getter(taskModelFields.id);
    var getChildren = getter(taskModelFields.children);
    var removedTaskId = getId(removedDataItem);
    while (stack.length > 0) {
        var stackItem = stack[stack.length - 1];
        var task = stackItem.task;
        var taskId = getId(task);
        var children = getChildren(task);
        if (taskId && taskId === removedTaskId) {
            break;
        }
        if (children && children.length && children.length > stackItem.childrenIndex) {
            stack.push({
                task: children[stackItem.childrenIndex],
                childrenIndex: 0
            });
            stackItem.childrenIndex++;
        }
        else {
            stack.pop();
        }
    }
    if (stack.length > 1) {
        var parentStackItem = stack[stack.length - 2];
        var parentTask = parentStackItem.task;
        var parentTaskChildren = getChildren(parentTask);
        parentTaskChildren.splice(parentStackItem.childrenIndex - 1, 1);
        stack = stack.splice(1, stack.length - 2);
        resolveSummaryFields(stack.map(function (stackItem) { return stackItem.task; }), taskModelFields);
    }
    return dataTreeCopy;
};
var resolveSummaryFields = function (stack, taskModelFields) {
    resolveSummaryStart(stack, taskModelFields);
    resolveSummaryEnd(stack, taskModelFields);
    resolveSummaryPercentComplete(stack, taskModelFields);
};
var resolveSummaryStart = function (stack, taskModelFields) {
    if (!stack.length) {
        return;
    }
    var getChildren = getter(taskModelFields.children);
    var getStart = getter(taskModelFields.start);
    var setStart = setter(taskModelFields.start);
    for (var i = stack.length - 1; i >= 0; i--) {
        var task = stack[i];
        var children = getChildren(task);
        if (children && children.length) {
            var minStart = children.reduce(function (minValue, currentTask) { return Math.min(minValue, getStart(currentTask).getTime()); }, getStart(children[0]).getTime());
            setStart(task, new Date(minStart));
        }
    }
};
var resolveSummaryEnd = function (stack, taskModelFields) {
    if (!stack.length) {
        return;
    }
    var getChildren = getter(taskModelFields.children);
    var getEnd = getter(taskModelFields.end);
    var setEnd = setter(taskModelFields.end);
    for (var i = stack.length - 1; i >= 0; i--) {
        var task = stack[i];
        var children = getChildren(task);
        if (children && children.length) {
            var maxEnd = children.reduce(function (maxValue, currentTask) { return Math.max(maxValue, getEnd(currentTask).getTime()); }, getEnd(children[0]).getTime());
            setEnd(task, new Date(maxEnd));
        }
    }
};
var resolveSummaryPercentComplete = function (stack, taskModelFields) {
    if (!stack.length) {
        return;
    }
    var getChildren = getter(taskModelFields.children);
    var getPercentComplete = getter(taskModelFields.percentComplete);
    var setPercentComplete = setter(taskModelFields.percentComplete);
    var avarageReducer = function (_a, currentTask) {
        var avg = _a.avg, n = _a.n;
        var currentPercent = getPercentComplete(currentTask);
        return {
            avg: ((currentPercent || 0) + n * avg) / (n + 1),
            n: n + 1
        };
    };
    for (var i = stack.length - 1; i >= 0; i--) {
        var task = stack[i];
        var children = getChildren(task);
        if (children && children.length) {
            var avaragePercentComplete = children.reduce(avarageReducer, { avg: 0, n: 0 }).avg;
            setPercentComplete(task, avaragePercentComplete);
        }
    }
};
var offsetChildren = function (data, taskModelFields, offset) {
    if (!data) {
        return;
    }
    var getChildren = getter(taskModelFields.children);
    var getStart = getter(taskModelFields.start);
    var setStart = setter(taskModelFields.start);
    var getEnd = getter(taskModelFields.end);
    var setEnd = setter(taskModelFields.end);
    var stack = data.map(function (item) { return ({ task: item, childrenIndex: 0 }); });
    while (stack.length > 0) {
        var stackItem = stack[stack.length - 1];
        var task = stackItem.task;
        var children = getChildren(task);
        if (children && children.length && children.length > stackItem.childrenIndex) {
            stack.push({
                task: children[stackItem.childrenIndex],
                childrenIndex: 0
            });
            stackItem.childrenIndex++;
        }
        else {
            stack.pop();
            setStart(task, new Date(getStart(task).getTime() + offset));
            setEnd(task, new Date(getEnd(task).getTime() + offset));
        }
    }
};
