var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { useGanttTaskModelFieldsContext, useGanttDateRangeContext, useGanttTaskEventsContext } from './../context/GanttContext';
import { isInRange } from '../utils';
import { classNames, getter, IconWrap, useDraggable } from '@progress/kendo-react-common';
import { xIcon } from '@progress/kendo-svg-icons';
import { useGanttViewDependencyDragContext, useGanttViewTimelineWidthContext } from '../context/GanttViewContext';
import { useGanttTask } from '../hooks/useGanttTask';
import { DEPENDENCY_DRAG_HANDLE_FINISH_ATT, DEPENDENCY_DRAG_HANDLE_START_ATT, MILESTONE_OFFSET, TASK_ID_ATT } from '../constants';
/** @hidden */
export var GanttTask = React.forwardRef(function (props, ref) {
    var _a, _b;
    var range = useGanttDateRangeContext();
    var taskModelFields = useGanttTaskModelFieldsContext();
    var timelineWidth = useGanttViewTimelineWidthContext();
    var dependencyDrag = useGanttViewDependencyDragContext();
    var taskEvents = useGanttTaskEventsContext();
    var taskElementRef = React.useRef(null);
    var completeElementRef = React.useRef(null);
    useGanttTask(props.dataItem, getter(taskModelFields.id)(props.dataItem), ref, taskElementRef);
    var slotElementRef = React.useRef(null);
    var taskId = getter(taskModelFields.id)(props.dataItem);
    var taskStart = getter(taskModelFields.start)(props.dataItem);
    var taskEnd = getter(taskModelFields.end)(props.dataItem);
    var taskTitle = getter(taskModelFields.title)(props.dataItem);
    var percentComplete = getter(taskModelFields.percentComplete)(props.dataItem);
    var taskChildren = getter(taskModelFields.children)(props.dataItem);
    var taskSelected = getter(taskModelFields.isSelected)(props.dataItem);
    var taskStartTime = taskStart && taskStart.getTime();
    var taskEndTime = taskEnd && taskEnd.getTime();
    var isSummaryTask = taskChildren && taskChildren.length;
    var isMilestone = !isSummaryTask && taskStartTime === taskEndTime;
    var display = taskStartTime && taskEndTime && isInRange(range.start, range.end, taskStart, taskEnd);
    var _c = React.useState(false), visible = _c[0], setVisible = _c[1];
    var dependencyStartElementRef = React.useRef(null);
    var dependencyEndElementRef = React.useRef(null);
    useDraggable(dependencyStartElementRef, {
        onPress: dependencyDrag.onDependencyHandlePress,
        onDrag: dependencyDrag.onDependencyHandleDrag,
        onRelease: dependencyDrag.onDependencyHandleRelease
    });
    useDraggable(dependencyEndElementRef, {
        onPress: dependencyDrag.onDependencyHandlePress,
        onDrag: dependencyDrag.onDependencyHandleDrag,
        onRelease: dependencyDrag.onDependencyHandleRelease
    });
    var onClickHandler = React.useCallback(function (event) {
        if (taskEvents.onTaskClick) {
            taskEvents.onTaskClick({
                dataItem: props.dataItem,
                level: props.level,
                nativeEvent: event && event.nativeEvent,
                syntheticEvent: event,
                target: null
            });
        }
    }, [props.dataItem, props.level]);
    var onDoubleClickHandler = React.useCallback(function (event) {
        if (taskEvents.onTaskDoubleClick) {
            taskEvents.onTaskDoubleClick({
                dataItem: props.dataItem,
                level: props.level,
                nativeEvent: event && event.nativeEvent,
                syntheticEvent: event,
                target: null
            });
        }
    }, [props.dataItem, props.level]);
    var onContextMenuHandler = React.useCallback(function (event) {
        if (taskEvents.onTaskContextMenu) {
            taskEvents.onTaskContextMenu({
                dataItem: props.dataItem,
                level: props.level,
                nativeEvent: event && event.nativeEvent,
                syntheticEvent: event,
                target: null
            });
        }
    }, [props.dataItem, props.level]);
    var onRemoveHandler = React.useCallback(function (event) {
        if (taskEvents.onTaskRemoveClick) {
            taskEvents.onTaskRemoveClick({
                dataItem: props.dataItem,
                level: props.level,
                nativeEvent: event && event.nativeEvent,
                syntheticEvent: event,
                target: null
            });
        }
    }, [props.dataItem, props.level]);
    var position = React.useCallback(function () {
        var slotStart = range.start;
        var slotEnd = range.end;
        var slotElement = slotElementRef.current;
        var taskElement = taskElementRef.current;
        var completeElement = completeElementRef.current;
        if (!display || slotElement === null || taskElement === null) {
            return;
        }
        var pxPerMillisecond = slotElement.clientWidth / (slotEnd.getTime() - slotStart.getTime());
        var left = (taskStart.getTime() - slotStart.getTime()) * pxPerMillisecond;
        var width = (taskEnd.getTime() - taskStart.getTime()) * pxPerMillisecond;
        var top = (slotElement.offsetHeight - taskElement.offsetHeight) / 2;
        taskElement.style.left = "".concat(Math.round(isMilestone ? left - MILESTONE_OFFSET : left), "px");
        taskElement.style.top = "".concat(Math.round(top), "px");
        if (!isMilestone) {
            taskElement.style.width = "".concat(Math.round(width), "px");
            if (completeElement !== null) {
                completeElement.style.width = "".concat(Math.round(width * (percentComplete || 0)), "px");
            }
        }
        setVisible(true);
    }, [range.start.getTime(), range.end.getTime(), taskStartTime, taskEndTime, display, percentComplete, timelineWidth]);
    React.useEffect(position, [position]);
    var taskStyles = {
        visibility: visible ? undefined : 'hidden',
        display: display ? undefined : 'none'
    };
    var dependencyDragStyles = {
        userSelect: 'none',
        display: dependencyDrag.draggedId === String(taskId) ? 'block' : undefined
    };
    return (React.createElement("td", { ref: slotElementRef, key: taskId, role: 'presentation' }, isMilestone ?
        (React.createElement("div", __assign({ "aria-hidden": true, className: classNames({
                'k-task': true,
                'k-task-milestone': true,
                'k-selected': taskSelected && !Array.isArray(taskSelected)
            }), style: taskStyles, ref: taskElementRef }, (_a = {}, _a[TASK_ID_ATT] = taskId, _a), { onClick: onClickHandler, onDoubleClick: onDoubleClickHandler, onContextMenu: onContextMenuHandler }),
            React.createElement("div", { className: 'k-task-milestone-content' }),
            dependencyDrag.isEnabled &&
                (React.createElement("div", __assign({ className: 'k-task-dot k-task-start', ref: dependencyStartElementRef, style: dependencyDragStyles }, DEPENDENCY_DRAG_HANDLE_START_ATT))),
            dependencyDrag.isEnabled &&
                (React.createElement("div", __assign({ className: 'k-task-dot k-task-end', ref: dependencyEndElementRef, style: dependencyDragStyles }, DEPENDENCY_DRAG_HANDLE_FINISH_ATT))))) :
        (React.createElement("div", __assign({ "aria-hidden": true, className: classNames({
                'k-task': true,
                'k-task-summary': isSummaryTask,
                'k-task-single': !isSummaryTask,
                'k-selected': taskSelected && !Array.isArray(taskSelected)
            }), ref: taskElementRef, style: taskStyles }, (_b = {}, _b[TASK_ID_ATT] = taskId, _b), { onClick: onClickHandler, onDoubleClick: onDoubleClickHandler, onContextMenu: onContextMenuHandler }),
            isSummaryTask ?
                (React.createElement("div", { className: 'k-task-summary-progress', ref: completeElementRef },
                    React.createElement("div", { className: 'k-task-summary-complete' }))) :
                (React.createElement("div", { className: 'k-task-complete', ref: completeElementRef })),
            !isSummaryTask && (React.createElement(React.Fragment, null,
                React.createElement("div", { className: 'k-task-content' }, taskTitle),
                taskEvents.onTaskRemoveClick ? (React.createElement("span", { className: 'k-task-actions' },
                    React.createElement("span", { onClick: onRemoveHandler, className: 'k-link k-task-delete', "aria-label": "Delete" },
                        React.createElement(IconWrap, { name: "x", icon: xIcon })))) : null)),
            dependencyDrag.isEnabled &&
                React.createElement("div", __assign({ className: 'k-task-dot k-task-start', ref: dependencyStartElementRef, style: dependencyDragStyles }, DEPENDENCY_DRAG_HANDLE_START_ATT)),
            dependencyDrag.isEnabled &&
                React.createElement("div", __assign({ className: 'k-task-dot k-task-end', ref: dependencyEndElementRef, style: dependencyDragStyles }, DEPENDENCY_DRAG_HANDLE_FINISH_ATT))))));
});
GanttTask.displayName = 'KendoReactGanttTask';
