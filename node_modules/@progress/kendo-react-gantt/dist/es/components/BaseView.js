var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import { useGanttPropsContext, useGanttTaskModelFieldsContext, useGanttTaskDataContext, useGanttDependencyDataContext, useGanttRowHeightContext, useGanttToolbarHeightContext, useGanttEventsContext, useGanttDependencyModelFieldsContext } from './../context/GanttContext';
import { GanttViewContext } from '../context/GanttViewContext';
import { GanttTask } from './GanttTask';
import { useDictionaryStore } from '../hooks/useDictionaryStore';
import { GanttDependency } from './GanttDependency';
import { getTimelineHeader, getTimelineContent, getTimelineWidth } from '../utils';
import { readColumns, mapColumns } from '@progress/kendo-react-data-tools';
import { DEFAULT_COLUMN_WIDTH, DEPENDENCY_DRAG_HANDLE, TASK_ID_ATT } from '../constants';
import { GanttTreeList } from './GanttTreelist';
import { getter, guid } from '@progress/kendo-react-common';
export var BaseView = React.forwardRef(function (props, ref) {
    var slotLevels = props.slotLevels, slotWidth = props.slotWidth, timelineHeaderCell = props.timelineHeaderCell;
    var _a = useGanttPropsContext(), columns = _a.columns, noRecords = _a.noRecords, resizable = _a.resizable, reorderable = _a.reorderable, sortable = _a.sortable, sort = _a.sort, filter = _a.filter, columnMenuFilter = _a.columnMenuFilter, columnMenu = _a.columnMenu, navigatable = _a.navigatable, row = _a.row, selectable = _a.selectable;
    var _b = useGanttEventsContext(), onDataStateChange = _b.onDataStateChange, onSortChange = _b.onSortChange, onFilterChange = _b.onFilterChange, onColumnMenuFilterChange = _b.onColumnMenuFilterChange, onExpandChange = _b.onExpandChange, onRowClick = _b.onRowClick, onRowDoubleClick = _b.onRowDoubleClick, onRowContextMenu = _b.onRowContextMenu, onColumnResize = _b.onColumnResize, onColumnReorder = _b.onColumnReorder, onDependencyCreate = _b.onDependencyCreate, onKeyDown = _b.onKeyDown, onSelectionChange = _b.onSelectionChange, onHeaderSelectionChange = _b.onHeaderSelectionChange;
    var rowHeight = useGanttRowHeightContext();
    var toolbarHeight = useGanttToolbarHeightContext();
    var taskModelFields = useGanttTaskModelFieldsContext();
    var dependencyModelFields = useGanttDependencyModelFieldsContext();
    var tasksData = useGanttTaskDataContext();
    var dependenciesData = useGanttDependencyDataContext();
    var timelineHeaderRef = React.useRef(null);
    var timelineContentRef = React.useRef(null);
    var treelistRef = React.useRef(null);
    var timelineSvgRef = React.useRef(null);
    var svgLeftRef = React.useRef(0);
    var idPrefixRef = React.useRef(guid());
    var contentRef = React.useRef(null);
    var baseViewRef = React.useRef(null);
    var scrollIntoView = React.useCallback(function (options) {
        if (treelistRef.current) {
            treelistRef.current.scrollIntoView(options);
        }
    }, []);
    React.useImperativeHandle(baseViewRef, function () { return ({ scrollIntoView: scrollIntoView }); });
    React.useImperativeHandle(ref, function () { return baseViewRef.current; });
    var initialXRef = React.useRef(0);
    var initialYRef = React.useRef(0);
    var offsetXRef = React.useRef(0);
    var offsetYRef = React.useRef(0);
    var startIdRef = React.useRef(null);
    var startDirectionRef = React.useRef(null);
    var _c = React.useState(null), coordinates = _c[0], setCoordinates = _c[1];
    var timelineHeader = getTimelineHeader(slotLevels, timelineHeaderRef, timelineHeaderCell);
    var timelineContent = getTimelineContent(slotLevels, timelineContentRef);
    var timelineWidth = getTimelineWidth(slotLevels, slotWidth);
    var _d = React.useMemo(function () {
        var extendedCols = readColumns(__spreadArray(__spreadArray([], columns, true), [
            {
                title: '',
                sortable: false,
                resizable: false,
                reorderable: false,
                width: timelineWidth,
                headerCell: function () { return timelineHeader; },
                cell: GanttTask,
                orderIndex: Number.MAX_SAFE_INTEGER,
                navigatable: false
            }
        ], false), { prevId: 0, idPrefix: idPrefixRef.current });
        var columnsWidthSum = 0;
        extendedCols.forEach(function (column, index, array) {
            var isLast = index + 1 === array.length;
            var isLeaf = column.children.length === 0;
            if (!isLast) {
                column.locked = true;
                if (isLeaf) {
                    column.width = column.width || DEFAULT_COLUMN_WIDTH;
                }
            }
            else {
                column.isAccessible = false;
            }
            if (isLeaf) {
                columnsWidthSum += parseFloat(String(column.width));
            }
        });
        return {
            extendedColumns: extendedCols,
            columnsWidth: columnsWidthSum,
            columnsMap: mapColumns(extendedCols)
        };
    }, [columns, timelineWidth]), extendedColumns = _d.extendedColumns, columnsWidth = _d.columnsWidth, columnsMap = _d.columnsMap;
    var _e = useDictionaryStore(), tasksStore = _e[0], dispatchTaskRef = _e[1];
    var getTimelineHeaderElement = React.useCallback(function () { return timelineHeaderRef.current && timelineHeaderRef.current.parentElement; }, []);
    var positionTimelineContent = function () {
        var timelineHeaderElement = getTimelineHeaderElement();
        var timelineContentElement = timelineContentRef.current;
        var treelistTbodyElement = treelistRef.current && treelistRef.current.tbodyElement;
        if (!timelineHeaderElement || !timelineContentElement || !treelistTbodyElement) {
            return;
        }
        var contentTop = treelistTbodyElement.offsetTop;
        var contentLeft = timelineHeaderElement.offsetLeft;
        var contentWidth = timelineWidth;
        timelineContentElement.style.top = contentTop + 'px';
        timelineContentElement.style.left = contentLeft + 'px';
        timelineContentElement.style.width = contentWidth + 'px';
        timelineContentElement.style.height = treelistTbodyElement.offsetHeight + 'px';
    };
    var getSvgLeft = function () {
        var timelineHeaderElement = getTimelineHeaderElement();
        if (!timelineHeaderElement) {
            return;
        }
        // Better be extracted as ColumnResizeStart event
        svgLeftRef.current = timelineHeaderElement.offsetLeft;
    };
    React.useEffect(positionTimelineContent);
    React.useEffect(getSvgLeft);
    var onColumnResizeHandler = React.useCallback(function (event) {
        if (!timelineSvgRef.current) {
            return;
        }
        var currentColumns = event.columns.slice(0, event.columns.length - 1);
        if (event.end) {
            timelineSvgRef.current.style.left = '0px';
        }
        else {
            var timelineHeaderElement = getTimelineHeaderElement();
            if (!timelineHeaderElement) {
                return;
            }
            timelineSvgRef.current.style.left = timelineHeaderElement.offsetLeft - svgLeftRef.current + 'px';
            positionTimelineContent();
        }
        onColumnResize(__assign(__assign({}, event), { columns: currentColumns }));
    }, [onColumnResize]);
    var onColumnReorderHandler = React.useCallback(function (event) {
        var currentColumns = event.columns.slice(0, event.columns.length - 1);
        onColumnReorder(__assign(__assign({}, event), { columns: currentColumns }));
    }, [onColumnResize]);
    var handleDependencyHandlePress = React.useCallback(function (dragEvent) {
        var ownerDocument = contentRef.current && contentRef.current.ownerDocument ? contentRef.current.ownerDocument : document;
        var targetElement = ownerDocument.elementFromPoint(dragEvent.clientX, dragEvent.clientY);
        var contentElement = contentRef.current;
        if (!targetElement || !targetElement.parentElement || !contentElement) {
            return;
        }
        var ganttWrapperElement = contentElement.parentElement;
        var scrollableContainer = contentElement.firstElementChild;
        if (!ganttWrapperElement || !scrollableContainer) {
            return;
        }
        var dragDirection = targetElement.getAttribute(DEPENDENCY_DRAG_HANDLE);
        if (dragDirection) {
            var contentOffsetTop = contentElement.offsetTop;
            var contentOffsetLeft = contentElement.offsetLeft;
            var ganttOffsetTop = ganttWrapperElement.offsetTop;
            var ganttOffsetLeft = ganttWrapperElement.offsetLeft;
            var scrollTop = scrollableContainer.scrollTop;
            var scrollLeft = scrollableContainer.scrollLeft;
            offsetXRef.current = contentOffsetLeft + ganttOffsetLeft;
            offsetYRef.current = contentOffsetTop + ganttOffsetTop;
            initialXRef.current = dragEvent.clientX - offsetXRef.current + scrollLeft;
            initialYRef.current = dragEvent.clientY - offsetYRef.current + scrollTop;
            startIdRef.current = targetElement.parentElement.getAttribute(TASK_ID_ATT);
            startDirectionRef.current = dragDirection;
        }
    }, []);
    var handleDependencyHandleDrag = React.useCallback(function (dragEvent) {
        var contentElement = contentRef.current;
        if (!contentElement) {
            return;
        }
        var scrollableContainer = contentElement.firstElementChild;
        if (!scrollableContainer) {
            return;
        }
        var scrollTop = scrollableContainer.scrollTop;
        var scrollLeft = scrollableContainer.scrollLeft;
        var endX = dragEvent.clientX - offsetXRef.current + scrollLeft;
        var endY = dragEvent.clientY - offsetYRef.current + scrollTop;
        if (Math.abs(initialXRef.current - endX) < 10 && Math.abs(initialYRef.current - endY) < 10) {
            return;
        }
        setCoordinates({
            startX: initialXRef.current,
            startY: initialYRef.current,
            endX: endX,
            endY: endY
        });
    }, []);
    var handleDependencyHandleRelease = React.useCallback(function (dragEvent) {
        var ownerDocument = contentRef.current && contentRef.current.ownerDocument ? contentRef.current.ownerDocument : document;
        var targetElement = ownerDocument.elementFromPoint(dragEvent.clientX, dragEvent.clientY);
        if (!targetElement || !targetElement.parentElement) {
            return;
        }
        var currentId = targetElement.parentElement.getAttribute(TASK_ID_ATT);
        var currentDragDirection = targetElement.getAttribute(DEPENDENCY_DRAG_HANDLE);
        if (currentDragDirection && currentId !== startIdRef.current) {
            if (onDependencyCreate) {
                // 0 - Finish-Finish
                // 1 - Finish-Start`
                // 2 - Start-Finish
                // 3 - Start-Start`
                var dependencyType = void 0;
                if (startDirectionRef.current === 'start') {
                    dependencyType = currentDragDirection === 'start' ? 3 : 2;
                }
                else {
                    dependencyType = currentDragDirection === 'start' ? 1 : 0;
                }
                onDependencyCreate({
                    fromId: startIdRef.current,
                    toId: currentId,
                    type: dependencyType
                });
            }
        }
        initialXRef.current = 0;
        initialYRef.current = 0;
        offsetXRef.current = 0;
        offsetYRef.current = 0;
        startIdRef.current = null;
        startDirectionRef.current = null;
        setCoordinates(null);
    }, [onDependencyCreate, setCoordinates]);
    return (React.createElement(GanttViewContext, { tasksStore: [tasksStore, dispatchTaskRef], timelineWidth: timelineWidth, dependencyDrag: {
            isEnabled: Boolean(onDependencyCreate),
            draggedId: startIdRef.current,
            onDependencyHandlePress: handleDependencyHandlePress,
            onDependencyHandleDrag: handleDependencyHandleDrag,
            onDependencyHandleRelease: handleDependencyHandleRelease
        } },
        React.createElement("div", { className: 'k-gantt-content', ref: contentRef, style: { height: "calc(100% - ".concat(toolbarHeight, "px)") } },
            React.createElement(GanttTreeList, { ref: treelistRef, extendedColumns: extendedColumns, columnsMap: columnsMap, dataItemKey: taskModelFields.id, data: tasksData, idPrefix: idPrefixRef.current, navigatable: navigatable, expandField: taskModelFields.isExpanded, subItemsField: taskModelFields.children, editField: taskModelFields.isInEdit, selectedField: taskModelFields.isSelected, onDataStateChange: onDataStateChange, onSortChange: onSortChange, onFilterChange: onFilterChange, onExpandChange: onExpandChange, onRowClick: onRowClick, onRowDoubleClick: onRowDoubleClick, onRowContextMenu: onRowContextMenu, onColumnResize: onColumnResizeHandler, onColumnReorder: onColumnReorderHandler, onColumnMenuFilterChange: onColumnMenuFilterChange, onKeyDown: onKeyDown, onSelectionChange: onSelectionChange, onHeaderSelectionChange: onHeaderSelectionChange, tableProps: { style: { width: columnsWidth }, className: 'k-table k-table-md k-table-layout-fixed' }, noRecords: noRecords, rowHeight: rowHeight, resizable: resizable, reorderable: reorderable, sortable: sortable, sort: sort, filter: filter, columnMenuFilter: columnMenuFilter, columnMenu: columnMenu, row: row, selectable: selectable, afterContent: (React.createElement(React.Fragment, null,
                    React.createElement("svg", { className: 'k-gantt-dependencies-svg', ref: timelineSvgRef, style: { left: 0, top: 0 } }, dependenciesData.map(function (dependency) { return React.createElement(GanttDependency, { key: getter(dependencyModelFields.id)(dependency), dependency: dependency }); })),
                    React.createElement("svg", { className: 'k-gantt-dependencies-svg', style: { left: 0, top: 0, zIndex: 3 } }, coordinates && (React.createElement("polyline", { points: "".concat(coordinates.startX, ",").concat(coordinates.startY, " ").concat(coordinates.endX, ",").concat(coordinates.endY) }))),
                    tasksData && tasksData.length ? timelineContent : null)) }))));
});
BaseView.displayName = 'KendoReactGanttBaseView';
