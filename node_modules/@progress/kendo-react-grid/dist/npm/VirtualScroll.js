"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualScroll = void 0;
var React = require("react");
/**
 * @hidden
 */
var VirtualScroll = /** @class */ (function () {
    function VirtualScroll(cached) {
        var _this = this;
        this.table = null;
        this.containerHeight = 0;
        this.topCacheCount = 0; // 4;
        this.attendedSkip = 0; // -4;
        this.propsSkip = 0;
        this.total = 0;
        this.scrollableVirtual = false;
        this.realSkip = 0;
        this.pageSize = 0;
        this.PageChange = null;
        this.tableBodyRef = React.createRef();
        this.fixedScroll = false;
        this.askedSkip = undefined;
        this.containerRef = React.createRef();
        this.tableTransform = '';
        this.prevScrollPos = 0;
        this.tableTranslate = 0;
        this.scrollSyncing = false;
        this.reactVersion = Number.parseFloat(React.version);
        this.topItems = function (heights, skipTopBuffer) {
            if (!_this.container || skipTopBuffer) {
                return { topItemsCount: 0, topItemsHeight: 0 };
            }
            var screenHeight = _this.container.clientHeight;
            var itemsOnScreen = Math.ceil(screenHeight / heights[0].line);
            var topItemsCount = Math.ceil((heights.length - itemsOnScreen) / 2);
            var topItemsHeight = 0;
            for (var i = 0; i < topItemsCount; i++) {
                topItemsHeight += heights[i].line + heights[i].acc;
            }
            return {
                topItemsCount: topItemsCount,
                topItemsHeight: topItemsHeight,
                itemsNeededOnScreen: itemsOnScreen + itemsOnScreen / 2
            };
        };
        this.horizontalScrollbarHeight = function () {
            if (!_this.container) {
                return 0;
            }
            return _this.container.offsetHeight - _this.container.clientHeight;
        };
        if (cached) {
            this.topCacheCount = 4;
            this.attendedSkip = -this.topCacheCount;
        }
        this.scrollHandler = this.scrollHandler.bind(this);
    }
    Object.defineProperty(VirtualScroll.prototype, "container", {
        get: function () {
            return this.containerRef.current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VirtualScroll.prototype, "rowHeights", {
        /**
         * @return - The row heights in an array.
         */
        get: function () {
            var result = [];
            var allRows = this.tableBodyRef.current && this.tableBodyRef.current.children || [];
            var accumulate = 0;
            for (var i = 0; i < allRows.length; i++) {
                if (allRows[i].className.indexOf('k-grouping-row') > -1) {
                    accumulate += allRows[i].scrollHeight;
                    continue;
                }
                if (allRows[i].className.indexOf('k-detail-row') > -1) {
                    result[result.length - 1].line += allRows[i].scrollHeight;
                }
                else {
                    result.push({
                        line: allRows[i].scrollHeight,
                        acc: accumulate
                    });
                    accumulate = 0;
                }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    VirtualScroll.prototype.changePage = function (skip, e) {
        this.attendedSkip = skip - this.topCacheCount;
        if (this.PageChange) {
            this.PageChange({
                skip: Math.max(0, skip - this.topCacheCount),
                take: this.pageSize
            }, e);
        }
    };
    VirtualScroll.prototype.translate = function (dY, forceSet) {
        this.tableTranslate = dY;
        if (this.scrollableVirtual && this.table) {
            if (this.reactVersion <= 17 || forceSet) {
                this.table.style.transform = 'translateY(' + dY + 'px)';
            }
            else {
                this.tableTransform = 'translateY(' + dY + 'px)';
            }
        }
    };
    VirtualScroll.prototype.reset = function () {
        this.scrollSyncing = true;
        if (this.fixedScroll) {
            return;
        }
        if (this.container) {
            this.container.scrollTop = 0;
        }
        this.translate(0, true);
    };
    VirtualScroll.prototype.localScrollUp = function (e) {
        if (!this.container) {
            return;
        }
        var heights = this.rowHeights;
        var scrollTop = this.container.scrollTop;
        var targetTranslate = this.tableTranslate;
        var rowsCount = 0;
        var _a = this.topItems(heights, Boolean(this.topCacheCount)), topItemsCount = _a.topItemsCount, topItemsHeight = _a.topItemsHeight, itemsNeededOnScreen = _a.itemsNeededOnScreen;
        var additionalOnTop = scrollTop - targetTranslate;
        if ((additionalOnTop > topItemsHeight) || heights.length <= itemsNeededOnScreen) {
            return;
        }
        while ((rowsCount < this.topCacheCount + this.attendedSkip - this.realSkip + topItemsCount)
            && this.propsSkip - rowsCount > 0 &&
            !(targetTranslate + (heights[heights.length - 1 - rowsCount].line + heights[heights.length - 1 - rowsCount].acc) + additionalOnTop <= scrollTop)) {
            targetTranslate -= heights[heights.length - 1 - rowsCount].line +
                heights[heights.length - 1 - rowsCount].acc;
            rowsCount++;
        }
        if (rowsCount === 0 && this.topCacheCount === 0 && this.attendedSkip > 0) {
            // allows local scrolling up, when top caching is disabled
            // for variable heights 'topCacheCount' should be atleast 1 to avoid flickering
            targetTranslate = Math.max(targetTranslate - heights[0].line, 0);
            rowsCount = 1;
        }
        if (this.propsSkip - rowsCount <= 0 && targetTranslate > scrollTop) {
            this.translate(0);
            this.changePage(0, e);
            this.container.scrollTop = 0;
            return;
        }
        if (targetTranslate > scrollTop) {
            targetTranslate = scrollTop;
            // need to handle these cases
            // if the item height is not available:
            //    floor the translate to beginning of the item in absolute value
        }
        if (targetTranslate !== this.tableTranslate) {
            this.translate(Math.max(0, targetTranslate - topItemsHeight));
            var nextSkip = Math.max(0, this.propsSkip - rowsCount - topItemsCount);
            this.changePage(nextSkip, e);
        }
    };
    VirtualScroll.prototype.localScrollDown = function (e) {
        if (!this.container) {
            return;
        }
        var heights = this.rowHeights;
        var scrollTop = this.container.scrollTop;
        var targetTranslate = this.tableTranslate;
        var rowsCount = 0;
        var _a = this.topItems(heights, Boolean(this.topCacheCount)), topItemsCount = _a.topItemsCount, topItemsHeight = _a.topItemsHeight, itemsNeededOnScreen = _a.itemsNeededOnScreen;
        while (rowsCount < heights.length - this.topCacheCount &&
            !(targetTranslate + heights[rowsCount].line + heights[rowsCount].acc > scrollTop)) {
            targetTranslate += heights[rowsCount].line + heights[rowsCount].acc;
            rowsCount++;
        }
        if ((topItemsCount > this.propsSkip + rowsCount) || heights.length <= itemsNeededOnScreen) {
            return;
        }
        if (rowsCount >= heights.length - this.topCacheCount && this.propsSkip + rowsCount >= this.total) {
            this.translate(targetTranslate - topItemsHeight);
            this.changePage(this.total - 1 - topItemsCount, e);
        }
        else if (targetTranslate !== this.tableTranslate && this.propsSkip + rowsCount - topItemsCount !== this.propsSkip) {
            this.translate(targetTranslate - topItemsHeight);
            this.changePage(this.propsSkip + rowsCount - topItemsCount, e);
        }
    };
    VirtualScroll.prototype.scrollNonStrict = function (e) {
        var floatRowIndex = this.total * this.prevScrollPos / (this.containerHeight);
        var rowIndex = Math.floor(floatRowIndex);
        if (rowIndex >= this.total) {
            rowIndex = this.total - 1;
        }
        var rowpercentage = Math.min(floatRowIndex - rowIndex, 1);
        var microAdjust = 0;
        var rowIndexOffset = rowIndex - this.propsSkip;
        var heights = this.rowHeights;
        if (rowIndexOffset >= 0 && rowIndexOffset <= 1) {
            microAdjust = -((heights[0].line + heights[0].acc) * rowpercentage);
        }
        else if (rowIndexOffset === -1) {
            microAdjust = -((heights[heights.length - 1].line + heights[heights.length - 1].acc) * rowpercentage);
        }
        var _a = this.topItems(heights, Boolean(this.topCacheCount)), topItemsCount = _a.topItemsCount, topItemsHeight = _a.topItemsHeight;
        this.translate(Math.max(0, microAdjust - topItemsHeight - this.horizontalScrollbarHeight() + this.containerHeight * floatRowIndex / this.total));
        this.changePage(rowIndex - topItemsCount, e);
    };
    VirtualScroll.prototype.scrollHandler = function (e) {
        if (!this.scrollableVirtual) {
            return;
        }
        if (this.scrollSyncing || !this.container || !this.table) {
            this.scrollSyncing = false;
            return;
        }
        var scrollTop = this.container.scrollTop;
        var prev = this.prevScrollPos;
        this.prevScrollPos = scrollTop;
        if (this.askedSkip !== undefined) {
            this.translate(this.containerHeight * this.askedSkip / this.total);
            this.changePage(this.askedSkip, e);
            this.prevScrollPos = scrollTop;
            this.askedSkip = undefined;
            return;
        }
        if (scrollTop - prev < 0 && scrollTop > this.tableTranslate - this.table.scrollHeight / 10) {
            this.localScrollUp(e);
        }
        else if (scrollTop - prev > 0 && scrollTop < this.tableTranslate + this.table.scrollHeight * 2 / 3) {
            this.localScrollDown(e);
        }
        else {
            this.scrollNonStrict(e);
        }
        this.prevScrollPos = scrollTop;
    };
    return VirtualScroll;
}());
exports.VirtualScroll = VirtualScroll;
