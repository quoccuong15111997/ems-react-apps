var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { Draggable, Keys, getTabIndex } from '@progress/kendo-react-common';
import { SortableOnDragStartEvent } from './events/SortableOnDragStartEvent';
import { SortableOnDragOverEvent } from './events/SortableOnDragOverEvent';
import { SortableOnDragEndEvent } from './events/SortableOnDragEndEvent';
import { SortableOnNavigateEvent } from './events/SortableOnNavigateEvent';
import { provideLocalizationService, registerForLocalization } from '@progress/kendo-react-intl';
import { messages, noData } from './messages';
import { find, findIndex, hasClasses, isFocusable, closest, relativeContextElement } from './utils/utils';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from './package-metadata';
import { getter } from '@progress/kendo-react-common';
/**
 * @hidden
 */
var ANIMATION_DURATION = 200;
/**
 * @hidden
 */
var SORTABLE_ITEM_ATTRIBUTE = 'data-sortable-id';
/**
 * @hidden
 */
var SORTABLE_COMPONENT_ATTRIBUTE = 'data-sortable-component';
/**
 * @hidden
 */
var SORTABLE_ATTRIBUTE_PROP = (_a = {}, _a[SORTABLE_COMPONENT_ATTRIBUTE] = true, _a);
var Sortable = /** @class */ (function (_super) {
    __extends(Sortable, _super);
    function Sortable(props) {
        var _this = _super.call(this, props) || this;
        /**
         * @hidden
         */
        _this.state = {
            clientX: 0,
            clientY: 0,
            isDragging: false,
            activeId: '',
            dragCueWidth: 0,
            dragCueHeight: 0
        };
        _this.isRtl = false;
        _this.itemRefsMap = {};
        _this.oldSizesMap = {};
        _this.animatingItemMap = {};
        _this.draggableRef = null;
        _this.isUnmounted = false;
        _this.focusActiveId = false;
        _this.isKeyboardNavigated = false;
        _this.isDragPrevented = false;
        /**
         * @hidden
         */
        _this.swapItems = function (newState, source, destination) {
            var b = newState[source];
            newState[source] = newState[destination];
            newState[destination] = b;
            source = destination;
            return source;
        };
        /**
         * @hidden
         */
        _this.generateNewState = function (prevIndex, nextIndex) {
            var data = _this.props.data;
            var newState = __spreadArray([], data, true);
            var isReversed = prevIndex > nextIndex;
            if (isReversed) {
                for (var i = prevIndex - 1; i >= nextIndex; i--) {
                    var nextItem = data[i];
                    if (!_this.isItemDisabled(nextItem)) {
                        prevIndex = _this.swapItems(newState, prevIndex, i);
                    }
                }
            }
            else {
                for (var i = prevIndex + 1; i <= nextIndex; i++) {
                    var nextItem = data[i];
                    if (!_this.isItemDisabled(nextItem)) {
                        prevIndex = _this.swapItems(newState, prevIndex, i);
                    }
                }
            }
            return newState;
        };
        /**
         * @hidden
         */
        _this.closestSortableItem = function (target) {
            var currentTarget = target;
            while (currentTarget) {
                var id = currentTarget.getAttribute(SORTABLE_ITEM_ATTRIBUTE);
                if (id && _this.itemRefsMap[id] === currentTarget) {
                    return {
                        id: id,
                        element: currentTarget
                    };
                }
                currentTarget = currentTarget.parentElement;
            }
            return {
                id: '',
                element: null
            };
        };
        /**
         * @hidden
         */
        _this.isSortable = function (target) {
            return Boolean(target.hasAttribute(SORTABLE_COMPONENT_ATTRIBUTE));
        };
        /**
         * @hidden
         */
        _this.closestSortable = function (target) {
            var currentTarget = target;
            while (currentTarget) {
                if (_this.isSortable(currentTarget)) {
                    return currentTarget;
                }
                currentTarget = currentTarget.parentElement;
            }
            return null;
        };
        /**
         * @hidden
         */
        _this.isSameSortable = function (element) {
            var closestSortable = _this.closestSortable(element);
            return closestSortable === _this.container;
        };
        /**
         * @hidden
         */
        _this.idComparer = function (id1, id2) {
            return id1 + '' === id2 + '';
        };
        /**
         * @hidden
         */
        _this.findItem = function (id) {
            var _a = _this.props, data = _a.data, idField = _a.idField;
            if (!(id + '')) {
                return;
            }
            var idGetter = getter(idField);
            return find(data, function (item) { return _this.idComparer(idGetter(item), id); });
        };
        /**
         * @hidden
         */
        _this.findIndex = function (id) {
            var _a = _this.props, data = _a.data, idField = _a.idField;
            if (!(id + '')) {
                return -1;
            }
            return findIndex(data, function (item) { return _this.idComparer(item[idField], id); });
        };
        /**
         * @hidden
         */
        _this.isItemDisabled = function (item) {
            return item && item[_this.props.disabledField || ''] === true;
        };
        /**
         * @hidden
         */
        _this.shouldResetActive = function () {
            if (document.activeElement instanceof HTMLElement) {
                var closestItemElement = _this.closestSortableItem(document.activeElement).element;
                return !Boolean(closestItemElement);
            }
            return false;
        };
        /**
         * @hidden
         */
        _this.widgetTarget = function (target) {
            var element = closest(target, function (node) { return hasClasses(node, 'k-widget') || _this.isSortable(node); });
            return element && !_this.isSortable(element);
        };
        /**
         * @hidden
         */
        _this.allowDrag = function (target) {
            return target.hasAttribute(SORTABLE_ITEM_ATTRIBUTE) || !(isFocusable(target) || _this.widgetTarget(target));
        };
        /**
         * @hidden
         */
        _this.onDragStart = function (eventData) {
            var event = eventData.event;
            var onDragStart = _this.props.onDragStart;
            var targetElement = document.elementFromPoint(event.clientX, event.clientY);
            var _a = _this.closestSortableItem(targetElement), activeId = _a.id, activeElement = _a.element;
            var activeItem = _this.findItem(activeId);
            if (!activeId ||
                (activeItem && _this.isItemDisabled(activeItem)) ||
                !_this.allowDrag(targetElement) ||
                !_this.isSameSortable(targetElement)) {
                _this.isDragPrevented = true;
                return;
            }
            if (event.isTouch) {
                event.originalEvent.preventDefault();
            }
            var dragStartEvent = new SortableOnDragStartEvent(_this, _this.findIndex(activeId), targetElement);
            if (onDragStart) {
                onDragStart.call(undefined, dragStartEvent);
            }
            _this.isDragPrevented = dragStartEvent.isDefaultPrevented();
            if (_this.isDragPrevented) {
                event.originalEvent.preventDefault();
            }
            else {
                _this.offsetParent = relativeContextElement(_this.container);
                _this.setState({
                    activeId: activeId,
                    dragCueWidth: (activeElement && activeElement.clientWidth) || 0,
                    dragCueHeight: (activeElement && activeElement.clientHeight) || 0
                });
            }
        };
        /**
         * @hidden
         */
        _this.onDragOver = function (eventData) {
            var event = eventData.event;
            var _a = _this.props, onDragOver = _a.onDragOver, data = _a.data;
            if (_this.isDragPrevented) {
                return;
            }
            event.originalEvent.preventDefault();
            var prevIndex = _this.findIndex(_this.state.activeId);
            if (prevIndex === -1) {
                _this.resetState();
                return;
            }
            var targetElement = document.elementFromPoint(event.clientX, event.clientY);
            var closestSortable = _this.closestSortableItem(targetElement);
            var nextIndex = _this.findIndex(closestSortable.id);
            var nextItem = data[nextIndex];
            if (onDragOver &&
                nextIndex > -1 &&
                prevIndex !== nextIndex &&
                !_this.isItemDisabled(nextItem) &&
                !_this.animatingItemMap[closestSortable.id] &&
                _this.shouldReorder(closestSortable.element, event.clientX, event.clientY)) {
                var dragOverEvent = new SortableOnDragOverEvent(_this, prevIndex, nextIndex, _this.generateNewState(prevIndex, nextIndex));
                onDragOver.call(undefined, dragOverEvent);
            }
            var offset = _this.parentOffset();
            _this.setState({
                clientX: event.clientX - offset.left,
                clientY: event.clientY - offset.top,
                isDragging: true
            });
        };
        /**
         * @hidden
         */
        _this.onDragEnd = function (eventData) {
            var event = eventData.event;
            var resetActive = _this.shouldResetActive();
            if (_this.isDragPrevented) {
                return;
            }
            var _a = _this.props, onDragEnd = _a.onDragEnd, data = _a.data;
            var targetElement = document.elementFromPoint(event.clientX, event.clientY);
            var closestSortableItem = _this.closestSortableItem(targetElement);
            var nextIndex = _this.findIndex(closestSortableItem.id);
            var prevIndex = _this.findIndex(_this.state.activeId);
            var isNextDisabled = _this.isItemDisabled(data[nextIndex]);
            if (nextIndex === -1 || isNextDisabled) {
                nextIndex = prevIndex;
            }
            if (onDragEnd) {
                var nextState = _this.generateNewState(prevIndex, nextIndex);
                if (!isNextDisabled) {
                    var rect = _this.thresholdRect(closestSortableItem.element);
                    if (rect && (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom)) {
                        var prev = prevIndex;
                        prevIndex = nextIndex;
                        nextIndex = prev;
                        nextState = _this.props.data.slice();
                    }
                }
                var dragEndEvent = new SortableOnDragEndEvent(_this, prevIndex, nextIndex, nextState);
                onDragEnd.call(undefined, dragEndEvent);
            }
            _this.resetState(resetActive);
        };
        /**
         * @hidden
         */
        _this.shouldReorder = function (draggerOverElement, clientX, clientY) {
            var rect = _this.thresholdRect(draggerOverElement);
            return rect && clientX > rect.left && clientX < rect.right && clientY > rect.top && clientY < rect.bottom;
        };
        /**
         * @hidden
         */
        _this.thresholdRect = function (draggerOverElement) {
            var activeId = _this.state.activeId;
            var root = _this.container;
            var elements = root ? Array.from(root.childNodes) : [];
            var activeElement = elements.find(function (e) { return e instanceof HTMLElement && e.getAttribute(SORTABLE_ITEM_ATTRIBUTE) === activeId; });
            if (!draggerOverElement || !activeElement) {
                return null;
            }
            var _a = activeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            var rect = draggerOverElement.getBoundingClientRect();
            var top = rect.top + (rect.height / 2) - (height / 2);
            var left = rect.left + (rect.width / 2) - (width / 2);
            var bottom = top + height;
            var right = left + width;
            return { top: top, left: left, bottom: bottom, right: right };
        };
        /**
         * @hidden
         */
        _this.onItemBlur = function () {
            // As IE have no support for relatedTarget
            window.setTimeout(function () {
                if (_this.isUnmounted) {
                    return;
                }
                if (_this.shouldResetActive() && !_this.state.isDragging) {
                    _this.setState({
                        activeId: '' // what happends on destroyed component
                    });
                }
            });
        };
        /**
         * @hidden
         */
        _this.onItemFocus = function (event) {
            var _a = _this.closestSortableItem(event.currentTarget), activeId = _a.id, element = _a.element;
            if (!_this.idComparer(activeId, _this.state.activeId) &&
                _this.isSameSortable(event.target) &&
                element === event.target) {
                _this.setState({
                    activeId: activeId
                });
            }
        };
        /**
         * @hidden
         */
        _this.onKeyDown = function (event) {
            var _a = _this.props, data = _a.data, idField = _a.idField, onNavigate = _a.onNavigate, navigation = _a.navigation;
            var activeId = _this.state.activeId;
            if (!navigation || !activeId || !_this.isSameSortable(event.target)) {
                return;
            }
            var isRtl = _this.isRtl;
            var enabledItems = data.filter(function (item) { return !_this.isItemDisabled(item); });
            var prevIndex = findIndex(enabledItems, function (item) { return _this.idComparer(item[idField], activeId); });
            var maxNavIndex = enabledItems.length - 1;
            var nextIndex = prevIndex;
            if (event.keyCode === Keys.left) {
                if (isRtl) {
                    event.keyCode = Keys.down;
                }
                else {
                    event.keyCode = Keys.up;
                }
            }
            if (event.keyCode === Keys.right) {
                if (isRtl) {
                    event.keyCode = Keys.up;
                }
                else {
                    event.keyCode = Keys.down;
                }
            }
            switch (event.keyCode) {
                case Keys.up:
                    if (prevIndex > 0) {
                        nextIndex = prevIndex - 1;
                    }
                    break;
                case Keys.down:
                    if (prevIndex < maxNavIndex) {
                        nextIndex = prevIndex + 1;
                    }
                    break;
                default:
            }
            if (nextIndex === prevIndex) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            var nextItem = enabledItems[nextIndex];
            var nextItemId = nextItem ? nextItem[idField] : '';
            var prevItem = enabledItems[prevIndex];
            var prevItemId = prevItem ? prevItem[idField] : '';
            if (event.ctrlKey) {
                if (onNavigate) {
                    var actualPrevIndex = _this.findIndex(prevItemId);
                    var actualNextIndex = _this.findIndex(nextItemId);
                    var navigateEvent = new SortableOnNavigateEvent(_this, actualPrevIndex, actualNextIndex, _this.generateNewState(actualPrevIndex, actualNextIndex));
                    _this.isKeyboardNavigated = true;
                    onNavigate.call(undefined, navigateEvent);
                }
            }
            else {
                _this.focusActiveId = true;
                _this.setState({
                    activeId: nextItemId + ''
                });
            }
        };
        /**
         * @hidden
         */
        _this.resetState = function (resetActive) {
            _this.isDragPrevented = false;
            _this.setState({
                clientX: 0,
                clientY: 0,
                isDragging: false,
                dragCueWidth: 0,
                dragCueHeight: 0,
                activeId: resetActive ? '' : _this.state.activeId
            });
        };
        /**
         * @hidden
         */
        _this.renderData = function () {
            var _a = _this.props, data = _a.data, UIComponent = _a.itemUI, idField = _a.idField, tabIndex = _a.tabIndex;
            return data.map(function (item) {
                var _a;
                var idGetter = getter(idField);
                var id = idGetter(item);
                var isDisabled = _this.isItemDisabled(item);
                var isActive = _this.idComparer(_this.state.activeId, id);
                return (React.createElement(UIComponent, { key: id, forwardRef: function (ele) { return _this.refAssign(ele, id); }, dataItem: item, isDisabled: isDisabled, isActive: isActive, isDragged: isActive && _this.state.isDragging, isDragCue: false, attributes: (_a = {},
                        _a[SORTABLE_ITEM_ATTRIBUTE] = id,
                        _a['aria-disabled'] = isDisabled,
                        _a['aria-grabbed'] = isActive && _this.state.isDragging && !_this.isDragPrevented,
                        _a['aria-dropeffect'] = isDisabled ? 'none' : 'move',
                        _a.tabIndex = getTabIndex(tabIndex, isDisabled),
                        _a.onFocus = _this.onItemFocus,
                        _a.onBlur = _this.onItemBlur,
                        _a), style: {
                        cursor: !isDisabled ? 'move' : 'auto',
                        MozUserSelect: 'none',
                        msUserSelect: 'none',
                        WebkitUserSelect: 'none',
                        userSelect: 'none'
                    } }));
            });
        };
        /**
         * @hidden
         */
        _this.renderNoData = function () {
            var UIComponent = _this.props.emptyItemUI;
            var localizationService = provideLocalizationService(_this);
            var noDataMessage = localizationService
                .toLanguageString(noData, messages[noData]);
            if (UIComponent) {
                return React.createElement(UIComponent, { message: noDataMessage });
            }
        };
        /**
         * @hidden
         */
        _this.renderDragCue = function () {
            var UIComponent = _this.props.itemUI;
            var _a = _this.state, isDragging = _a.isDragging, activeId = _a.activeId, clientX = _a.clientX, clientY = _a.clientY;
            var dataItem = _this.findItem(activeId);
            if (!isDragging || !dataItem) {
                return;
            }
            return (React.createElement(UIComponent, { dataItem: dataItem, isDisabled: false, isActive: true, isDragged: true, isDragCue: true, style: {
                    position: 'fixed',
                    top: clientY + 10,
                    left: clientX + 10,
                    width: _this.state.dragCueWidth,
                    height: _this.state.dragCueHeight
                }, attributes: {} }));
        };
        /**
         * @hidden
         */
        _this.refAssign = function (element, id) {
            if (!element) {
                delete _this.itemRefsMap[id];
            }
            else {
                _this.itemRefsMap[id] = element;
            }
        };
        /**
         * @hidden
         */
        _this.draggableRefAssign = function (ref) {
            _this.draggableRef = ref;
        };
        validatePackage(packageMetadata);
        return _this;
    }
    Object.defineProperty(Sortable.prototype, "container", {
        get: function () {
            return this.draggableRef && this.draggableRef.element;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    Sortable.prototype.getSnapshotBeforeUpdate = function () {
        var _this = this;
        var _a = this.props, idField = _a.idField, animation = _a.animation;
        this.oldSizesMap = {};
        if (!animation) {
            return null;
        }
        this.props.data.forEach(function (item) {
            var id = item[idField];
            var ref = _this.itemRefsMap[id];
            var domNode = ReactDOM.findDOMNode(ref);
            if (domNode) {
                _this.oldSizesMap[id] = domNode.getBoundingClientRect();
            }
        });
        return null;
    };
    /**
     * @hidden
     */
    Sortable.prototype.componentDidUpdate = function (previousProps) {
        var _this = this;
        var _a = this.props, idField = _a.idField, animation = _a.animation;
        if (this.focusActiveId) {
            this.focusActiveId = false;
            this.itemRefsMap[this.state.activeId].focus();
        }
        if (!animation || (!this.state.isDragging && !this.isKeyboardNavigated)) {
            return;
        }
        this.isKeyboardNavigated = false;
        previousProps.data.forEach(function (item) {
            var id = item[idField];
            var domNode = _this.itemRefsMap[id];
            var newBox = domNode.getBoundingClientRect();
            var oldBox = _this.oldSizesMap[id];
            var deltaX = oldBox.left - newBox.left;
            var deltaY = oldBox.top - newBox.top;
            if (deltaX === 0 && deltaY === 0) {
                return;
            }
            requestAnimationFrame(function () {
                _this.animatingItemMap[id] = true;
                // Before the DOM paints, Invert it to its old position
                // TODO: optimize - animate all items in one animation frame, not each in different
                // TODO: optimize - when already animated element is going to change calculate correct delta first.
                domNode.style.transform = "translate(".concat(deltaX, "px, ").concat(deltaY, "px)");
                domNode.style.transition = 'transform 0s';
                requestAnimationFrame(function () {
                    // Then, remove the transform reverting it to its natural
                    // state and apply a transition so the process goes smoothly.
                    domNode.style.transform = '';
                    domNode.style.transition = "transform ".concat(ANIMATION_DURATION, "ms cubic-bezier(0.2, 0, 0, 1) 0s");
                    window.setTimeout(function () { return _this.animatingItemMap[id] = false; }, ANIMATION_DURATION);
                });
            });
        });
    };
    /**
     * @hidden
     */
    Sortable.prototype.componentDidMount = function () {
        this.isRtl = this.container && (getComputedStyle(this.container).direction === 'rtl') || false;
    };
    /**
     * @hidden
     */
    Sortable.prototype.componentWillUnmount = function () {
        this.isUnmounted = true;
    };
    /**
     * @hidden
     */
    Sortable.prototype.parentOffset = function () {
        var offsetParent = this.offsetParent;
        if (offsetParent && offsetParent.ownerDocument) {
            if (offsetParent !== offsetParent.ownerDocument.body) {
                var rect = offsetParent.getBoundingClientRect();
                return {
                    left: rect.left - offsetParent.scrollLeft,
                    top: rect.top - offsetParent.scrollTop
                };
            }
        }
        return { left: 0, top: 0 };
    };
    /**
     * @hidden
     */
    Sortable.prototype.render = function () {
        var _a = this.props, data = _a.data, style = _a.style, className = _a.className, itemsWrapUI = _a.itemsWrapUI;
        var Wrapper = itemsWrapUI || 'div';
        return (React.createElement(Draggable, { onDragStart: this.onDragStart, onDrag: this.onDragOver, onDragEnd: this.onDragEnd, ref: this.draggableRefAssign },
            React.createElement(Wrapper, __assign({}, SORTABLE_ATTRIBUTE_PROP, { className: className, style: __assign({ touchAction: 'none' }, style), onKeyDown: this.onKeyDown }),
                data && data.length ?
                    this.renderData() : this.renderNoData(),
                this.renderDragCue())));
    };
    /**
     * @hidden
     */
    Sortable.defaultProps = {
        navigation: true,
        animation: true,
        emptyItemUI: function (props) { return React.createElement("div", null, props.message); }
    };
    /**
     * @hidden
     */
    Sortable.propTypes = {
        idField: PropTypes.string.isRequired,
        disabledField: PropTypes.string,
        data: PropTypes.array.isRequired,
        tabIndex: PropTypes.number,
        navigation: PropTypes.bool,
        animation: PropTypes.bool,
        itemsWrapUI: PropTypes.any,
        itemUI: PropTypes.func.isRequired,
        emptyItemUI: PropTypes.func,
        style: PropTypes.object,
        className: PropTypes.string,
        onDragStart: PropTypes.func,
        onDragOver: PropTypes.func,
        onDragEnd: PropTypes.func,
        onNavigate: PropTypes.func
    };
    return Sortable;
}(React.Component));
export { Sortable };
registerForLocalization(Sortable);
